<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="自定义View," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Android中的Veiw从内存中到呈现在UI界面上需要依次经历三个阶段：量算 -&amp;gt; 布局 -&amp;gt; 绘图，关于View的量算、布局、绘图的总体机制可参见博文《 Android中View的布局及绘图机制》。如果想了解layout布局的细节，可参见博文《源码解析Android中View的layout布局过程》。量算是布局和绘图的基础，所以量算是很重要的一个环节。本文将从源码角度解析View的">
<meta property="og:type" content="article">
<meta property="og:title" content="源码解析Android中View的Measure量算过程">
<meta property="og:url" content="http://yoursite.com/2016/12/17/源码解析Android中View的Measure量算过程/index.html">
<meta property="og:site_name" content="fastabler">
<meta property="og:description" content="Android中的Veiw从内存中到呈现在UI界面上需要依次经历三个阶段：量算 -&amp;gt; 布局 -&amp;gt; 绘图，关于View的量算、布局、绘图的总体机制可参见博文《 Android中View的布局及绘图机制》。如果想了解layout布局的细节，可参见博文《源码解析Android中View的layout布局过程》。量算是布局和绘图的基础，所以量算是很重要的一个环节。本文将从源码角度解析View的">
<meta property="og:updated_time" content="2017-02-11T09:21:12.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="源码解析Android中View的Measure量算过程">
<meta name="twitter:description" content="Android中的Veiw从内存中到呈现在UI界面上需要依次经历三个阶段：量算 -&amp;gt; 布局 -&amp;gt; 绘图，关于View的量算、布局、绘图的总体机制可参见博文《 Android中View的布局及绘图机制》。如果想了解layout布局的细节，可参见博文《源码解析Android中View的layout布局过程》。量算是布局和绘图的基础，所以量算是很重要的一个环节。本文将从源码角度解析View的">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/12/17/源码解析Android中View的Measure量算过程/"/>





  <title> 源码解析Android中View的Measure量算过程 | fastabler </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ad1350e91810844821a7ad3e1f8ac561";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">fastabler</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">黄金龙的博客</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/17/源码解析Android中View的Measure量算过程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://okzxn9yra.bkt.clouddn.com/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="fastabler">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="fastabler" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                源码解析Android中View的Measure量算过程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-17T17:04:06+08:00">
                2016-12-17
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/17/源码解析Android中View的Measure量算过程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/17/源码解析Android中View的Measure量算过程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Android中的Veiw从内存中到呈现在UI界面上需要依次经历三个阶段：量算 -&gt; 布局 -&gt; 绘图，关于View的量算、布局、绘图的总体机制可参见博文<a href="http://fastabler.online/2016/12/11/Android中View的量算、布局以及绘图机制/" target="_blank" rel="external">《 Android中View的布局及绘图机制》</a>。如果想了解layout布局的细节，可参见博文<a href="http://fastabler.online/2016/12/18/源码解析Android中View的layout布局过程/" target="_blank" rel="external">《源码解析Android中View的layout布局过程》</a>。量算是布局和绘图的基础，所以量算是很重要的一个环节。本文将从源码角度解析View的量算过程，这其中会涉及某些关键类以及关键方法。</p>
<p>对View进行量算的目的是让View的父控件知道View想要多大的尺寸。</p>
<p>##量算过程概述</p>
<p>如果要进行量算的View是ViewGroup类型，那么ViewGroup会在onMeasure方法内会遍历子View依次进行量算，本文重点说明非ViewGroup的View的量算过程，因为我们一旦了解了非ViewGroup的View的量算过程，ViewGroup的量算理解起来就要简单许多，主要是ViewGroup在其内部对子View再依次执行量算。</p>
<p>整个应用量算的起点是ViewRootImpl类，从它开始依次对子View进行量算，如果子View是一个ViewGroup，那么又会遍历该ViewGroup的子View依次进行量算。也就是说，量算会从View树的根结点，纵向递归进行，从而实现自上而下对View树进行量算，直至完成对叶子节点View的量算。</p>
<p>那么到底如何对一个View进行量算呢？Android通过调用View的measure()方法对View进行量算，让该View的父控件知道该View想要多大的尺寸空间。</p>
<p>具体来说，View的父控件ViewGroup会调用View的measure方法，ViewGroup会将一些宽度和高度的限制条件传递给View的measure方法。</p>
<p>在View的measure方法会首先从成员变量中读取以前缓存过的量算结果，如果能找到该缓存值，那么就基本完事了，如果没有找到缓存值，那么measure方法会执行onMeasure回调方法，measure方法会将上述的宽度和高度的限制条件依次传递给onMeasure方法。onMeasure方法会完成具体的量算工作，并将量算的结果通过调用View的setMeasuredDimension方法保存到View的成员变量mMeasuredWidth 和mMeasuredHeight中。</p>
<p>量算完成之后，View的父控件就可以通过调用getMeasuredWidth、getMeasuredState、getMeasuredWidthAndState这三个方法获取View的量算结果。</p>
<p>以上就是非ViewGroup类型的View量算的总体过程。</p>
<p>##MeasureSpec简介</p>
<p>上面我们提到ViewGroup在调用View的measure方法时，会传入ViewGroup对View的宽度及高度的限制条件，这是合理的，例如ViewGroup的空间有限，它需要告诉子View要量算的尺寸的上限。</p>
<p>上面提到的尺寸的限制条件就是MeasureSpec，它可以通过一个Int类型的值来表示的，该Int值会同时包含两种信息：mode和size，即模式和尺寸。我们知道Java中Int类型的值是4个字节的，Android会用第一个高位字节存储mode，然后用剩余的三个字节存储size。</p>
<p>View有一个静态内部类MeasureSpec，该类有几个静态方法以及静态常量，我们可以用这些方法将mode和size打包成一个Int值或者是从一个Int值中解析出mode和size。</p>
<p>假设我们已有了一个包含MeasureSpec信息的Int值measureSpec，那么</p>
<p>通过调用MeasureSpec.getSize(int measureSpec)即可从measureSpec解析出三个字节所包含的尺寸size信息，该方法返回Int类型，也就是说我们得到的size实际上就是对原有的measureSpec的高位字节的8个二进制位都设置为0，该方法的返回值size虽然也是4个字节的Int值，但是已经完全不包含mode信息。</p>
<p>通过调用MeasureSpec.getMode(int measureSpec)即可从measureSpec解析出高位字节所包含的模式mode信息，该方法返回Int类型，也就是说我们得到的mode实际上对原有的measureSpec的低位的三个字节的24个二进制码都设置为0，该方法的返回值mode虽然也是4个字节的Int值，但是已经完全不包含size信息。</p>
<p>对于尺寸size，我们很好理解，比如表示某个宽度值或者表示某个高度值。那么mode是什么呢？</p>
<p>mode的取值有三种，分别是：</p>
<p>MeasureSpec.AT_MOST，即0x80000000，该值表示View最大可以取其父ViewGroup给其指定的尺寸，例如现在有个Int值widthMeasureSpec，ViewGroup将其传递给了View的measure方法，如果widthMeasureSpec中的mode值是AT_MOST，size是200，那么表示View能取的最大的宽度是200。</p>
<p>MeasureSpec.EXACTLY，即0x40000000，该值表示View必须使用其父ViewGroup指定的尺寸，还是以widthMeasureSpec为例，如果其mode值是EXACTLY，size是200，那么表示View的宽度必须是200，不多不少才行。</p>
<p>MeasureSpec.UNSPECIFIED，即0x00000000，该值表示View的父ViewGroup没有给View在尺寸上设置限制条件，这种情况下View可以忽略measureSpec中的size，View可以取自己想要的值作为量算的尺寸。</p>
<p>更多信息可参考API文档 android/view/View.MeasureSpec。</p>
<p>##measure方法</p>
<p>measure()的方法签名是public final void measure(int widthMeasureSpec, int heightMeasureSpec)。</p>
<p>当View的父控件ViewGroup对View进行量算时，会调用View的measure方法，ViewGroup会传入widthMeasureSpec和heightMeasureSpec，分别表示父控件对View的宽度和高度的一些限制条件。</p>
<p>measure方法的源码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">    //首先判断当前View的layoutMode是不是特例LAYOUT_MODE_OPTICAL_BOUNDS</div><div class="line">    boolean optical = isLayoutModeOptical(this);</div><div class="line">    if (optical != isLayoutModeOptical(mParent)) &#123;</div><div class="line">        //LAYOUT_MODE_OPTICAL_BOUNDS是特例情况，比较少见</div><div class="line">        Insets insets = getOpticalInsets();</div><div class="line">        int oWidth  = insets.left + insets.right;</div><div class="line">        int oHeight = insets.top  + insets.bottom;</div><div class="line">        widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);</div><div class="line">        heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//根据widthMeasureSpec和heightMeasureSpec计算key值，我们在下面用key值作为键，缓存我们量算的结果</div><div class="line">    long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL;</div><div class="line">    //mMeasureCache是LongSparseLongArray类型的成员变量，</div><div class="line">    //其缓存着View在不同widthMeasureSpec、heightMeasureSpec下量算过的结果</div><div class="line">    //如果mMeasureCache为空，我们就新new一个对象赋值给mMeasureCache</div><div class="line">    if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2);</div><div class="line">    //mOldWidthMeasureSpec和mOldHeightMeasureSpec分别表示上次对View进行量算时的widthMeasureSpec和heightMeasureSpec</div><div class="line">    //执行View的measure方法时，View总是先检查一下是不是真的有必要费很大力气去做真正的量算工作</div><div class="line">    //mPrivateFlags是一个Int类型的值，其记录了View的各种状态位</div><div class="line">    //如果(mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT，</div><div class="line">    //那么表示当前View需要强制进行layout（比如执行了View的forceLayout方法），所以这种情况下要尝试进行量算</div><div class="line">    //如果新传入的widthMeasureSpec/heightMeasureSpec与上次量算时的mOldWidthMeasureSpec/mOldHeightMeasureSpec不等，</div><div class="line">    //那么也就是说该View的父ViewGroup对该View的尺寸的限制情况有变化，这种情况下要尝试进行量算</div><div class="line">    if ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</div><div class="line">            widthMeasureSpec != mOldWidthMeasureSpec ||</div><div class="line">            heightMeasureSpec != mOldHeightMeasureSpec) &#123;</div><div class="line"></div><div class="line">        //通过按位操作，重置View的状态mPrivateFlags，将其标记为未量算状态</div><div class="line">        mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</div><div class="line"></div><div class="line">        //对阿拉伯语、希伯来语等从右到左书写、布局的语言进行特殊处理</div><div class="line">        resolveRtlPropertiesIfNeeded();</div><div class="line"></div><div class="line">        //在View真正进行量算之前，View还想进一步确认能不能从已有的缓存mMeasureCache中读取缓存过的量算结果</div><div class="line">        //如果是强制layout导致的量算，那么将cacheIndex设置为-1，即不从缓存中读取量算结果</div><div class="line">        //如果不是强制layout导致的量算，那么我们就用上面根据measureSpec计算出来的key值作为缓存索引cacheIndex。</div><div class="line">        int cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -1 :</div><div class="line">                mMeasureCache.indexOfKey(key);</div><div class="line"></div><div class="line">        //sIgnoreMeasureCache是一个boolean类型的成员变量，其值是在View的构造函数中计算的，而且只计算一次</div><div class="line">        //一些老的App希望在一次layou过程中，onMeasure方法总是被调用，</div><div class="line">        //具体来说其值是通过如下计算的: sIgnoreMeasureCache = targetSdkVersion &lt; KITKAT;</div><div class="line">        //也就是说如果targetSdkVersion的API版本低于KITKAT，即API level小于19，那么sIgnoreMeasureCache为true</div><div class="line"></div><div class="line">        if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123;</div><div class="line">            //如果运行到此处，表示我们没有从缓存中找到量算过的尺寸或者是sIgnoreMeasureCache为true导致我们要忽略缓存结果</div><div class="line">            //此处调用onMeasure方法，并把尺寸限制条件widthMeasureSpec和heightMeasureSpec传入进去</div><div class="line">            //onMeasure方法中将会进行实际的量算工作，并把量算的结果保存到成员变量中</div><div class="line">            onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">            //onMeasure执行完后，通过位操作，重置View的状态mPrivateFlags，将其标记为在layout之前不必再进行量算的状态</div><div class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">        &#125; else &#123;</div><div class="line">            //如果运行到此处，那么表示当前的条件允许View从缓存成员变量mMeasureCache中读取量算过的结果</div><div class="line">            //用上面得到的cacheIndex从缓存mMeasureCache中取出值，不必在调用onMeasure方法进行量算了</div><div class="line">            long value = mMeasureCache.valueAt(cacheIndex);</div><div class="line">            //一旦我们从缓存中读到值，我们就可以调用setMeasuredDimensionRaw方法将当前量算的结果到成员变量中</div><div class="line">            setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value);</div><div class="line">            mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //如果我们自定义的View重写了onMeasure方法，但是没有调用setMeasuredDimension()方法，</div><div class="line">        //那么此处就会抛出异常，提醒开发者在onMeasure方法中调用setMeasuredDimension()方法</div><div class="line">        //Android是如何知道我们有没有在onMeasure方法中调用setMeasuredDimension()方法的呢？</div><div class="line">        //方法很简单，还是通过解析状态位mPrivateFlags。</div><div class="line">        //setMeasuredDimension()方法中会将mPrivateFlags设置为PFLAG_MEASURED_DIMENSION_SET状态，即已量算状态，</div><div class="line">        //此处就检查mPrivateFlags是否含有PFLAG_MEASURED_DIMENSION_SET状态即可判断setMeasuredDimension是否被调用</div><div class="line">        if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</div><div class="line">            throw new IllegalStateException(&quot;View with id &quot; + getId() + &quot;: &quot;</div><div class="line">                    + getClass().getName() + &quot;#onMeasure() did not set the&quot;</div><div class="line">                    + &quot; measured dimension by calling&quot;</div><div class="line">                    + &quot; setMeasuredDimension()&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //mOldWidthMeasureSpec和mOldHeightMeasureSpec保存着最近一次量算时的MeasureSpec，</div><div class="line">    //在量算完成后将这次新传入的MeasureSpec赋值给它们</div><div class="line">    mOldWidthMeasureSpec = widthMeasureSpec;</div><div class="line">    mOldHeightMeasureSpec = heightMeasureSpec;</div><div class="line"></div><div class="line">    //最后用上面计算出的key作为键，量算结果作为值，将该键值对放入成员变量mMeasureCache中，</div><div class="line">    //这样就实现了对本次量算结果的缓存，以便在下次measure方法执行的时候，有可能将其从中直接读出，</div><div class="line">    //从而省去实际量算的步骤</div><div class="line">    mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 |</div><div class="line">            (long) mMeasuredHeight &amp; 0xffffffffL);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>上面的注释对每行代码都进行了详细的说明，如果大家仔细读了的话，相信能一目了然，这里根据上面的注释简单总结一下measure方法都干了什么事：</p>
<p>首先，我们要知道并不是只要View的measure方法执行的时候View就一定要傻傻的真的去做量算工作，View也喜欢偷懒，如果View发现没有必要去量算的话，那它就不会真的去做量算的工作。</p>
<p>具体来说，View先查看是不是要强制量算以及这次measure中传入的MeasureSpec与上次量算的MeasureSpec是否相同，如果不是强制量算或者MeasureSpec与上次的量算的MeasureSpec相同，那么View就不必真的去量算了。</p>
<p>如果不满足上述条件，View就考虑去做量算工作。但是在量算之前，View还想偷懒，它会以MeasureSpec计算出的key值作为键，去成员变量mMeasureCache中查找是否缓存过对应key的量算结果，如果能找到，那么就简单调用一下setMeasuredDimensionRaw方法，将从缓存中读到的量算结果保存到成员变量mMeasuredWidth和mMeasuredHeight中。</p>
<p>如果不能从mMeasureCache中读到缓存过的量算结果，那么这次View就真的不能再偷懒了，只能乖乖地调用onMeasure方法去完成实际的量算工作，并且将尺寸限制条件widthMeasureSpec和heightMeasureSpec传递给onMeasure方法。关于onMeasure方法，我们会在下面详细介绍。</p>
<p>不论上面代码走了哪个判断的分支，最终View都会得到量算的结果，并且将结果缓存到成员变量mMeasureCache中，以便下次执行measure方法时能够从其中读取缓存值。</p>
<p>需要说明的是，View有一个成员变量mPrivateFlags，用以保存View的各种状态位，在量算开始前，会将其设置为未量算状态，在量算完成后会将其设置为已量算状态。</p>
<p>##onMeasure方法</p>
<p>我们在上面提到，当View在measure方法中发现不得不进行实际的量算工作时，将会调用onMeasure方法，并且将尺寸限制条件widthMeasureSpec和heightMeasureSpec作为参数传递给onMeasure方法。View的onMeasure方法不是空方法，它提供了一个默认的具体实现。<br>onMeasure方法的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">    //onMeasure调用了setMeasuredDimension方法，</div><div class="line">    //setMeasuredDimension又需要调用getDefaultSize方法，</div><div class="line">    //getDefaultSize又需要调用getSuggestedMinimumWidth和getSuggestedMinimumHeight方法</div><div class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们发现onMeasure方法中会调用setMeasuredDimension方法，setMeasuredDimension又需要调用getDefaultSize方法，getDefaultSize又需要调用getSuggestedMinimumWidth和getSuggestedMinimumHeight方法，即<br>setMeasuredDimension -&gt; getDefaultSize -&gt; getSuggestedMinimumWidth/Height</p>
<p>那我们就先研究getSuggestedMinimumWidth/Height，然后再依次研究getDefaultSize和setMeasuredDimension，这样就能把onMeasure方法搞明白了。其实getSuggestedMinimumWidth和getSuggestedMinimumHeight的实现逻辑基本一样，我们此处只研究getSuggestedMinimumWidth方法即可。</p>
<p>getSuggestedMinimumWidth方法</p>
<p>getSuggestedMinimumWidth用于返回View推荐的最小宽度，其代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">protected int getSuggestedMinimumWidth() &#123;</div><div class="line">    //如果没有给View设置背景，那么就返回View本身的最小宽度mMinWidth</div><div class="line">    //如果给View设置了背景，那么就取View本身最小宽度mMinWidth和背景的最小宽度的最大值</div><div class="line">    return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果没有给View设置背景，那么就返回View本身的最小宽度mMinWidth</p>
<p>如果给View设置了背景，那么就取View本身最小宽度mMinWidth和背景的最小宽度的最大值</p>
<p>那你可能有疑问，View中保存的最小宽度mMinWidth的值是从哪来的呢？实际上有两种办法给View设置最小宽度。</p>
<p>第一种情况是，mMinWidth是在View的构造函数中被赋值的，View通过读取XML中定义的minWidth的值来设置View的最小宽度mMinWidth，以下代码片段是View构造函数中解析minWidth的部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//遍历到XML中定义的minWith属性</div><div class="line">case R.styleable.View_minWidth:</div><div class="line">//读取XML中定义的属性值作为mMinWidth，如果XML中未定义，则设置为0</div><div class="line">mMinWidth = a.getDimensionPixelSize(attr, 0);</div><div class="line">break;</div></pre></td></tr></table></figure></p>
<p>第二种情况是调用View的setMinimumWidth方法给View的最小宽度mMinWidth赋值，setMinimumWidth方法的代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void setMinimumWidth(int minWidth) &#123;</div><div class="line">    mMinWidth = minWidth;</div><div class="line">    requestLayout();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样我们就搞明白了getSuggestedMinimumWidth方法是怎么执行的了，getSuggestedMinimumHeight方法与其逻辑完全一致，只不过是把宽度换成了高度，在此就不再赘述了。</p>
<p>getDefaultSize</p>
<p>我们在onMeasure方法中发现，onMeasure会执行以下两行代码：getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec)<br>getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)</p>
<p>我们已经研究了getSuggestedMinimumWidth/Height，知道其会返回View的最小宽度和高度，现在我们开始研究getDefaultSize方法。</p>
<p>Android会将View想要的尺寸以及其父控件对其尺寸限制信息measureSpec传递给getDefaultSize方法，该方法要根据这些综合信息计算最终的量算的尺寸。</p>
<p>其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public static int getDefaultSize(int size, int measureSpec) &#123;</div><div class="line">    //size表示的是View想要的尺寸信息，比如最小宽度或最小高度</div><div class="line">    int result = size;</div><div class="line">    //从measureSpec中解析出specMode信息</div><div class="line">    int specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">    //从measureSpec中解析出specSize信息，不要将specSize与上面的size变量搞混</div><div class="line">    int specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">    switch (specMode) &#123;</div><div class="line">    //如果mode是UNSPECIFIED，表示View的父ViewGroup没有给View在尺寸上设置限制条件</div><div class="line">    case MeasureSpec.UNSPECIFIED:</div><div class="line">        //此处当mode是UNSPECIFIED时，View就直接用自己想要的尺寸size作为量算的结果</div><div class="line">        result = size;</div><div class="line">        break;</div><div class="line">    //如果mode是UNSPECIFIED，那么表示View最大可以取其父ViewGroup给其指定的尺寸</div><div class="line">    //如果mode是EXACTLY，那么表示View必须使用其父ViewGroup指定的尺寸</div><div class="line">    case MeasureSpec.AT_MOST:</div><div class="line">    case MeasureSpec.EXACTLY:</div><div class="line">        //此处mode是UNSPECIFIED或EXACTLY时，View就用其父ViewGroup指定的尺寸作为量算的结果</div><div class="line">        result = specSize;      </div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过以上代码，我们就会发现View的父ViewGroup传递给View的限制条件measureSpec的作用在该方法中体现的淋漓尽致。</p>
<p>首先根据measuredSpec解析出对应的specMode和specSize</p>
<p>当mode是UNSPECIFIED时，View就直接用自己想要的尺寸size作为量算的结果</p>
<p>当mode是UNSPECIFIED或EXACTLY时，View就用其父ViewGroup指定的尺寸作为量算的结果</p>
<p>最终，View会根据measuredSpec限制条件，得到最终的量算的尺寸。</p>
<p>这样在onMeasure方法中，<br>当执行getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec)时，我们就得到了最终量算到的宽度值；<br>当执行getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)时，我们就得到了最终量算到的高度值。</p>
<p>##setMeasuredDimension</p>
<p>在前面我们研究onMeasure方法时就已经看到setMeasuredDimension会调用getDefaultSize方法，会将已经量算到的宽度值和高度值作为参数传递给setMeasuredDimension方法，我们研究一下该方法。</p>
<p>其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123;</div><div class="line">    boolean optical = isLayoutModeOptical(this);</div><div class="line">    if (optical != isLayoutModeOptical(mParent)) &#123;</div><div class="line">        //layoutMode是LAYOUT_MODE_OPTICAL_BOUNDS的特殊情况，我们不考虑</div><div class="line">        Insets insets = getOpticalInsets();</div><div class="line">        int opticalWidth  = insets.left + insets.right;</div><div class="line">        int opticalHeight = insets.top  + insets.bottom;</div><div class="line"></div><div class="line">        measuredWidth  += optical ? opticalWidth  : -opticalWidth;</div><div class="line">        measuredHeight += optical ? opticalHeight : -opticalHeight;</div><div class="line">    &#125;</div><div class="line">    //最终调用setMeasuredDimensionRaw方法，将量算结果传入进去</div><div class="line">    setMeasuredDimensionRaw(measuredWidth, measuredHeight);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法会在开始判断layoutMode是不是LAYOUT_MODE_OPTICAL_BOUNDS的特殊情况，这种特例很少见，我们直接忽略掉。</p>
<p>setMeasuredDimension方法最后将量算的结果传递给方法setMeasuredDimensionRaw，我们再研究一下setMeasuredDimensionRaw这方法。</p>
<p>setMeasuredDimensionRaw</p>
<p>setMeasuredDimensionRaw接收两个参数，分别是已经量算完成的宽度和高度。</p>
<p>其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123;</div><div class="line">    //将量算完成的宽度measuredWidth保存到View的成员变量mMeasuredWidth中</div><div class="line">    mMeasuredWidth = measuredWidth;</div><div class="line">    //将量算完成的高度measuredHeight保存到View的成员变量mMeasuredHeight中</div><div class="line">    mMeasuredHeight = measuredHeight;</div><div class="line">    //最后将View的状态位mPrivateFlags设置为已量算状态</div><div class="line">    mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们发现，在该方法中做了三件事：</p>
<p>将量算完成的宽度measuredWidth保存到View的成员变量mMeasuredWidth中</p>
<p>将量算完成的高度measuredHeight保存到View的成员变量mMeasuredHeight中</p>
<p>最后将View的状态位mPrivateFlags设置为已量算状态</p>
<p>量算完成的尺寸的state</p>
<p>至此，View的量算过程就完成了，但是View的父ViewGroup如何读取到View量算的结果呢？</p>
<p>为此，View提供了三组方法，分别是： </p>
<ol>
<li>getMeasuredWidth和getMeasuredHeight方法 </li>
<li>getMeasuredWidthAndState和getMeasuredHeightAndState方法 </li>
<li>getMeasuredState方法</li>
</ol>
<p>有些人可能会纳闷，只要有了第一组方法不就行了吗？后面那两组方法有啥用？</p>
<p>此处我们要再仔细研究一下View中保存量算结果的成员变量mMeasuredWidth和mMeasuredHeight，下面的讨论我们都只讨论宽度，理解了宽度的处理方式，高度也是完全一样的。</p>
<p>mMeasuredWidth是一个Int类型的值，其是由4个字节组成的。</p>
<p>我们先假设mMeasuredWidth只存储了量算完成的宽度信息，而且View的父ViewGroup可以通过相关方法得到该值。但是存在这样一种情况：View在量算时，父ViewGroup给其传递的widthMeasureSpec中的specMode的值是AT_MOST，specSize是100，但是View的最小宽度是200，显然父ViewGroup指定的specSize不能满足View的大小，但是由于specMode的值是AT_MOST，View在getDefaultSize方法中不得不妥协，只能含泪将量算的最终宽度设置为100。然后其父ViewGroup通过某些方法获取到该View的量算宽度为100时，ViewGroup以为子View只需要100就够了，最终给了子View宽度为100的空间，这就导致了在UI界面上View特别窄，用户体验也就不好。</p>
<p>Android为让其View的父控件获取更多的信息，就在mMeasuredWidth上下了很大功夫，虽然是一个Int值，但是想让它存储更多信息，具体来说就是把mMeasuredWidth分成两部分：</p>
<p>其高位的第一个字节为第一部分，用于标记量算完的尺寸是不是达到了View想要的宽度，我们称该信息为量算的state信息。<br>其低位的三个字节为第二部分，用于存储实际的量算到的宽度。<br>由此我们可以看出Android真是物尽其用，一个变量能包含两个信息，这个有点类似于measureSpec的道理，但是二者又有不同：</p>
<p>measureSpec是将限制条件mode从ViewGroup传递给其子View。<br>mMeasuredWidth、mMeasuredHeight是将带有量算结果的state标志位信息从View传递给其父ViewGroup。<br>那么你可能会问，在本文中我们没看到对mMeasuredWidth的高位字节进行特殊处理啊？我们下面看一下View中的resolveSizeAndState方法。</p>
<p>resolveSizeAndState</p>
<p>resolveSizeAndState方法与getDefaultSize方法类似，其内部实现的逻辑是一样的，但是又有区别，getDefaultSize仅仅返回最终量算的尺寸信息，但resolveSizeAndState除了返回最终尺寸信息还会有可能返回量算的state标志位信息。</p>
<p>resolveSizeAndState方法的源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) &#123;</div><div class="line">    final int specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">    final int specSize = MeasureSpec.getSize(measureSpec);</div><div class="line">    final int result;</div><div class="line">    switch (specMode) &#123;</div><div class="line">        case MeasureSpec.AT_MOST:</div><div class="line">            if (specSize &lt; size) &#123;</div><div class="line">                //当specMode为AT_MOST，并且父控件指定的尺寸specSize小于View自己想要的尺寸时，</div><div class="line">                //我们就会用掩码MEASURED_STATE_TOO_SMALL向量算结果加入尺寸太小的标记</div><div class="line">                //这样其父ViewGroup就可以通过该标记其给子View的尺寸太小了，</div><div class="line">                //然后可能分配更大一点的尺寸给子View</div><div class="line">                result = specSize | MEASURED_STATE_TOO_SMALL;</div><div class="line">            &#125; else &#123;</div><div class="line">                result = size;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        case MeasureSpec.EXACTLY:</div><div class="line">            result = specSize;</div><div class="line">            break;</div><div class="line">        case MeasureSpec.UNSPECIFIED:</div><div class="line">        default:</div><div class="line">            result = size;</div><div class="line">    &#125;</div><div class="line">    return result | (childMeasuredState &amp; MEASURED_STATE_MASK);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当specMode为AT_MOST，并且父控件指定的尺寸specSize小于View自己想要的尺寸时，我们就会用掩码MEASURED_STATE_TOO_SMALL向量算结果加入尺寸太小的标记，这样其父ViewGroup就可以通过该标记其给子View的尺寸太小了，然后可能分配更大一点的尺寸给子View。</p>
<p>getDefaultSize方法只是onMeasure方法中获取最终尺寸的默认实现，其返回的信息比resolveSizeAndState要少，那么什么时候才会调用resolveSizeAndState方法呢？ 主要有两种情况：</p>
<p>Android中的许多layout类都调用了resolveSizeAndState方法，比如LinearLayout在量算过程中会调用resolveSizeAndState方法而非getDefaultSize方法。<br>我们自己在实现自定义的View或ViewGroup时，我们可以重写onMeasure方法，并在该方法内调用resolveSizeAndState方法。<br>getMeasuredXXX系列方法</p>
<p>现在我们再回过头来看以下三组方法：</p>
<p>getMeasuredWidth和getMeasuredHeight方法<br>该组方法只返回量算结果中的的尺寸信息，去掉了高位字节的state信息，以getMeasuredWidth方法为例，其源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public final int getMeasuredWidth() &#123;</div><div class="line">    //MEASURED_SIZE_MASK的值为0x00ffffff，用mMeasuredWidth与掩码MEASURED_SIZE_MASK进行按位与运算，</div><div class="line">    //可以将返回值中的高位字节的8个bit位全置为0，从而去掉了高位字节的state信息</div><div class="line">    return mMeasuredWidth &amp; MEASURED_SIZE_MASK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>MEASURED_SIZE_MASK的值为0x00ffffff，用mMeasuredWidth与掩码MEASURED_SIZE_MASK进行按位与运算，可以将返回值中的高位字节的8个bit位全置为0，从而去掉了高位字节的state信息</p>
<p>getMeasuredWidthAndState和getMeasuredHeightAndState方法<br>该组方法返回的量算结果中同时包含尺寸和state信息（如果state存在的话），以getMeasuredWidthAndState方法为例，其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final int getMeasuredWidthAndState() &#123;</div><div class="line">    //该方法直接返回成员变量mMeasuredWidth，因为mMeasuredWidth本身已经包含了尺寸以及可能的state信息</div><div class="line">    return mMeasuredWidth;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法直接返回成员变量mMeasuredWidth，因为mMeasuredWidth本身已经包含了尺寸以及可能的state信息</p>
<p>getMeasuredState方法<br>该方法返回的Int值中同时包含宽度量算的state以及高度量算的state，不包含任何的尺寸信息，其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final int getMeasuredState() &#123;</div><div class="line">    //将宽度量算的state存储在Int值的第一个字节中，即高位首字节</div><div class="line">    //将高度量算的state存储在Int值的第三个字节中</div><div class="line">    return (mMeasuredWidth&amp;MEASURED_STATE_MASK)</div><div class="line">            | ((mMeasuredHeight&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT)</div><div class="line">                    &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们简单分析一下以上代码：</p>
<p>掩码MEASURED_STATE_MASK的值为常量0xff000000，其高位字节的8个bit位全为1，剩余低位字节的三个字节的24个bit位全为0</p>
<p>MEASURED_HEIGHT_STATE_SHIFT的值为常量16</p>
<p>当执行(mMeasuredWidth&amp;MEASURED_STATE_MASK)时，将mMeasuredWidth与MEASURED_STATE_MASK进行按位与操作，该表达式的值高位字节保留了量算后宽度的state，过滤掉了其低位三个字节所存储的宽度size</p>
<p>由于我们已经用高位首字节存储了量算后宽度的state，所以高度的state就不能存储在高位首字节了。Android打算把它存储在第三个字节中。(mMeasuredHeight&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT)表示将mMeasuredHeight向右移16位，这样高度的state字节就从原来的第一个字节右移动到了第三个字节，由于高度的state向右移动了，所以其对应的掩码也有相应移动。(MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT)表示state的掩码也从第一个字节右移16位到了第三个字节，即掩码从0xff000000变成了0x0000ff00。然后用右移后的state与右移后的掩码执行按位与操作，这样就在第三个字节保留了高度的state信息，并且过滤掉了第1、2、4字节中的信息，即将这三个字节中的24个bit位置为0。</p>
<p>最后，将我们得到的宽度的state与高度的state进行按位或操作，这样就将宽度和高度的state都保存在一个Int值中：第一个字节存储宽度的state，第三个字节存储高度的state。</p>
<p>##总结</p>
<p>至此，View中量算的关键类以及方法我们基本都涉及到了，我们发现View的measure方法还是比较聪明的，知道如何偷懒利用以前量算过的数据，如果情况有变，那么就调用onMeasure方法进行实际的量算工作，在onMeasure中，View要根据父ViewGroup给其传递进来的widthMeasureSpec和heightMeasureSpec，并结合View自身想要的尺寸，综合考虑，计算出最终的量算的宽度和高度，并存储到相应的成员变量中，这才标志着该View量算有效的完成了，如果没有将值存入到成员变量中，View会抛出异常。在该成员变量中有可能也存储了量算过程中的state信息。由于View的measure已经实现了很多逻辑判断，所以我们在自定义View或ViewGroup时，都不应该重写measure方法，而应该重写onMeasure方法，在其中实现我们自己的量算逻辑。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/自定义View/" rel="tag"># 自定义View</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/11/Android中View的量算、布局以及绘图机制/" rel="next" title="Android中View的量算、布局以及绘图机制">
                <i class="fa fa-chevron-left"></i> Android中View的量算、布局以及绘图机制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/18/源码解析Android中View的layout布局过程/" rel="prev" title="源码解析Android中View的layout布局过程">
                源码解析Android中View的layout布局过程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2016/12/17/源码解析Android中View的Measure量算过程/"
     data-title="源码解析Android中View的Measure量算过程"
     data-content=""
     data-url="http://yoursite.com/2016/12/17/源码解析Android中View的Measure量算过程/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/12/17/源码解析Android中View的Measure量算过程/"
           data-title="源码解析Android中View的Measure量算过程" data-url="http://yoursite.com/2016/12/17/源码解析Android中View的Measure量算过程/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://okzxn9yra.bkt.clouddn.com/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg"
               alt="fastabler" />
          <p class="site-author-name" itemprop="name">fastabler</p>
          <p class="site-description motion-element" itemprop="description">Efforts can only pass,hard to be excellent.</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fastabler</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"fastabler"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  

  

  

  

  


</body>
</html>

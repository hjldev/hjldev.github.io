<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Rxjava," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="创建操作以下操作符用于创建Observable。create： 使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe#call方法中检查订阅状态，以便及时停止发射数据或者运算。Observable.create(new Observable.OnSubscribe&amp;lt;String&amp;gt;() {

    @">
<meta property="og:type" content="article">
<meta property="og:title" content="Rxjava操作符大全">
<meta property="og:url" content="http://yoursite.com/2017/01/06/Rxjava操作符大全/index.html">
<meta property="og:site_name" content="fastabler">
<meta property="og:description" content="创建操作以下操作符用于创建Observable。create： 使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe#call方法中检查订阅状态，以便及时停止发射数据或者运算。Observable.create(new Observable.OnSubscribe&amp;lt;String&amp;gt;() {

    @">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/1a7gi8os6u4kgk7aahzmj1d0/image_1arcl6d0a1iej60e6ccp48qic9.png">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/bu67z13p279yu074arzslsyd/image_1ard6160913ui3r6orodc41pntm.png">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/tuo7jn6ijtzsa1c3ak77umtu/image_1ard609fsi3p9n7160iq0r1rqe9.png">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/6dbl77xvh2z02hxil00juave/image_1argc8a1n17a61t441s5p1gln8231g.png">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/9w3o5vxc0lzznbrpn4vwa78w/image_1argbe0o1atfqtbrj51gu0jho9.png">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/791vkq1lxpl2etqaql85a6e8/image_1argbhutoi1a1b6a18s9il6npvm.png">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/xqw7fto75revvct4zu3d56a5/image_1argc0tbetbj1rkj1etf4fcb1p13.png">
<meta property="og:updated_time" content="2017-02-08T05:57:10.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rxjava操作符大全">
<meta name="twitter:description" content="创建操作以下操作符用于创建Observable。create： 使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe#call方法中检查订阅状态，以便及时停止发射数据或者运算。Observable.create(new Observable.OnSubscribe&amp;lt;String&amp;gt;() {

    @">
<meta name="twitter:image" content="http://static.zybuluo.com/maplejaw/1a7gi8os6u4kgk7aahzmj1d0/image_1arcl6d0a1iej60e6ccp48qic9.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/01/06/Rxjava操作符大全/"/>





  <title> Rxjava操作符大全 | fastabler </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ad1350e91810844821a7ad3e1f8ac561";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">fastabler</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">黄金龙的博客</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/06/Rxjava操作符大全/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="fastabler">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="fastabler" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Rxjava操作符大全
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-06T18:19:52+08:00">
                2017-01-06
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="创建操作"><a href="#创建操作" class="headerlink" title="创建操作"></a>创建操作</h2><h3 id="以下操作符用于创建Observable。"><a href="#以下操作符用于创建Observable。" class="headerlink" title="以下操作符用于创建Observable。"></a>以下操作符用于创建Observable。</h3><h4 id="create：-使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe-call方法中检查订阅状态，以便及时停止发射数据或者运算。"><a href="#create：-使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe-call方法中检查订阅状态，以便及时停止发射数据或者运算。" class="headerlink" title="create： 使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe#call方法中检查订阅状态，以便及时停止发射数据或者运算。"></a>create： 使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe#call方法中检查订阅状态，以便及时停止发射数据或者运算。</h4><pre><code>Observable.create(new Observable.OnSubscribe&lt;String&gt;() {

    @Override
    public void call(Subscriber&lt;? super String&gt; subscriber) {

        subscriber.onNext(&quot;item1&quot;);
        subscriber.onNext(&quot;item2&quot;);
        subscriber.onCompleted();
    }
});
</code></pre><h4 id="from：-将一个Iterable-一个Future-或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。"><a href="#from：-将一个Iterable-一个Future-或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。" class="headerlink" title="from： 将一个Iterable, 一个Future, 或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。"></a>from： 将一个Iterable, 一个Future, 或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。</h4><p><img src="http://static.zybuluo.com/maplejaw/1a7gi8os6u4kgk7aahzmj1d0/image_1arcl6d0a1iej60e6ccp48qic9.png" alt="Markdown preferences pane"></p>
<pre><code>//Iterable
List&lt;String&gt; list=new ArrayList&lt;&gt;();
...
Observable.from(list)
        .subscribe(new Action1&lt;String&gt;() {
    @Override
    public void call(String s) {

    }
});

//Future
 Future&lt;String&gt; futrue= Executors.newSingleThreadExecutor().submit(new Callable&lt;String&gt;() {

    @Override
    public String call() throws Exception {
        Thread.sleep(1000);
        return &quot;maplejaw&quot;;
    }
});

Observable.from(futrue)
          .subscribe(new Action1&lt;String&gt;() {
    @Override
    public void call(String s) {

    }
});
</code></pre><h4 id="just：-将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。"><a href="#just：-将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。" class="headerlink" title="just： 将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。"></a>just： 将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。</h4><h4 id="empty：-创建一个什么都不做直接通知完成的Observable"><a href="#empty：-创建一个什么都不做直接通知完成的Observable" class="headerlink" title="empty： 创建一个什么都不做直接通知完成的Observable"></a>empty： 创建一个什么都不做直接通知完成的Observable</h4><h4 id="error：-创建一个什么都不做直接通知错误的Observable"><a href="#error：-创建一个什么都不做直接通知错误的Observable" class="headerlink" title="error： 创建一个什么都不做直接通知错误的Observable"></a>error： 创建一个什么都不做直接通知错误的Observable</h4><h4 id="never：-创建一个什么都不做的Observable"><a href="#never：-创建一个什么都不做的Observable" class="headerlink" title="never： 创建一个什么都不做的Observable"></a>never： 创建一个什么都不做的Observable</h4><pre><code>Observable observable1=Observable.empty();//直接调用onCompleted。
Observable observable2=Observable.error(new RuntimeException());//直接调用onError。这里可以自定义异常
Observable observable3=Observable.never();//啥都不做
</code></pre><h4 id="timer：-创建一个在给定的延时之后发射数据项为0的Observable-内部通过OnSubscribeTimerOnce工作"><a href="#timer：-创建一个在给定的延时之后发射数据项为0的Observable-内部通过OnSubscribeTimerOnce工作" class="headerlink" title="timer： 创建一个在给定的延时之后发射数据项为0的Observable,内部通过OnSubscribeTimerOnce工作"></a>timer： 创建一个在给定的延时之后发射数据项为0的Observable<long>,内部通过OnSubscribeTimerOnce工作</long></h4><pre><code>Observable.timer(1000,TimeUnit.MILLISECONDS)
        .subscribe(new Action1&lt;Long&gt;() {
            @Override
            public void call(Long aLong) {
                Log.d(&quot;JG&quot;,aLong.toString()); // 0
            }
        });
</code></pre><h4 id="interval：-创建一个按照给定的时间间隔发射从0开始的整数序列的Observable，内部通过OnSubscribeTimerPeriodically工作。"><a href="#interval：-创建一个按照给定的时间间隔发射从0开始的整数序列的Observable，内部通过OnSubscribeTimerPeriodically工作。" class="headerlink" title="interval： 创建一个按照给定的时间间隔发射从0开始的整数序列的Observable，内部通过OnSubscribeTimerPeriodically工作。"></a>interval： 创建一个按照给定的时间间隔发射从0开始的整数序列的Observable<long>，内部通过OnSubscribeTimerPeriodically工作。</long></h4><pre><code>Observable.interval(1, TimeUnit.SECONDS)
        .subscribe(new Action1&lt;Long&gt;() {
            @Override
            public void call(Long aLong) {
                 //每隔1秒发送数据项，从0开始计数
                 //0,1,2,3....
            }
        });
</code></pre><h4 id="range：-创建一个发射指定范围的整数序列的Observable"><a href="#range：-创建一个发射指定范围的整数序列的Observable" class="headerlink" title="range： 创建一个发射指定范围的整数序列的Observable"></a>range： 创建一个发射指定范围的整数序列的Observable<integer></integer></h4><pre><code>Observable.range(2,5).subscribe(new Action1&lt;Integer&gt;() {
    @Override
    public void call(Integer integer) {
        Log.d(&quot;JG&quot;,integer.toString());// 2,3,4,5,6 从2开始发射5个数据
    }
});
</code></pre><h5 id="defer：-只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。"><a href="#defer：-只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。" class="headerlink" title="defer： 只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。"></a>defer： 只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。</h5><pre><code>Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() {
    @Override
    public Observable&lt;String&gt; call() {
        return Observable.just(&quot;hello&quot;);
    }
}).subscribe(new Action1&lt;String&gt;() {
    @Override
    public void call(String s) {
        Log.d(&quot;JG&quot;,s);
    }
});
</code></pre><h2 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h2><p>以下操作符用于组合多个Observable。</p>
<p>注意，为了使结构更加清晰以及缩小代码量，之后的例子部分地方将会使用Lambda表达式书写，如果你对Lambda表达式不太熟悉的话，可以阅读JAVA8 Lambda表达式完全解析这篇文章。</p>
<h4 id="concat：-按顺序连接多个Observables。需要注意的是Observable-concat-a-b-等价于a-concatWith-b-。"><a href="#concat：-按顺序连接多个Observables。需要注意的是Observable-concat-a-b-等价于a-concatWith-b-。" class="headerlink" title="concat： 按顺序连接多个Observables。需要注意的是Observable.concat(a,b)等价于a.concatWith(b)。"></a>concat： 按顺序连接多个Observables。需要注意的是Observable.concat(a,b)等价于a.concatWith(b)。</h4><pre><code>Observable&lt;Integer&gt; observable1=Observable.just(1,2,3,4);
Observable&lt;Integer&gt;  observable2=Observable.just(4,5,6);

Observable.concat(observable1,observable2)
        .subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString()));//1,2,3,4,4,5,6
</code></pre><h4 id="startWith：-在数据序列的开头增加一项数据。startWith的内部也是调用了concat"><a href="#startWith：-在数据序列的开头增加一项数据。startWith的内部也是调用了concat" class="headerlink" title="startWith： 在数据序列的开头增加一项数据。startWith的内部也是调用了concat"></a>startWith： 在数据序列的开头增加一项数据。startWith的内部也是调用了concat</h4><pre><code>Observable.just(1,2,3,4,5)
        .startWith(6,7,8)
.subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString()));//6,7,8,1,2,3,4,5
</code></pre><h4 id="merge：-将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。"><a href="#merge：-将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。" class="headerlink" title="merge： 将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。"></a>merge： 将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。</h4><h4 id="zip：-使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过OperatorZip进行压合。"><a href="#zip：-使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过OperatorZip进行压合。" class="headerlink" title="zip： 使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过OperatorZip进行压合。"></a>zip： 使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过OperatorZip进行压合。</h4><p>Observable<integer>  observable1=Observable.just(1,2,3,4);<br>Observable<integer>  observable2=Observable.just(4,5,6);</integer></integer></p>
<pre><code>Observable.zip(observable1, observable2, new Func2&lt;Integer, Integer, String&gt;() {
    @Override
    public String call(Integer item1, Integer item2) {
        return item1+&quot;and&quot;+item2;
    }
})
.subscribe(item-&gt;Log.d(&quot;JG&quot;,item)); //1and4,2and5,3and6
</code></pre><h4 id="combineLatest：-当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable最近的数据压合。具体请看下面流程图。"><a href="#combineLatest：-当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable最近的数据压合。具体请看下面流程图。" class="headerlink" title="combineLatest： 当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable最近的数据压合。具体请看下面流程图。"></a>combineLatest： 当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable最近的数据压合。具体请看下面流程图。</h4><p>zip工作流程<br><img src="http://static.zybuluo.com/maplejaw/bu67z13p279yu074arzslsyd/image_1ard6160913ui3r6orodc41pntm.png" alt="Markdown preferences pane"></p>
<p>combineLatest工作流程<br><img src="http://static.zybuluo.com/maplejaw/tuo7jn6ijtzsa1c3ak77umtu/image_1ard609fsi3p9n7160iq0r1rqe9.png" alt="Markdown preferences pane"></p>
<h2 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h2><h4 id="filter：-过滤数据。内部通过OnSubscribeFilter过滤数据。"><a href="#filter：-过滤数据。内部通过OnSubscribeFilter过滤数据。" class="headerlink" title="filter： 过滤数据。内部通过OnSubscribeFilter过滤数据。"></a>filter： 过滤数据。内部通过OnSubscribeFilter过滤数据。</h4><pre><code>Observable.just(3,4,5,6)
        .filter(new Func1&lt;Integer, Boolean&gt;() {
            @Override
            public Boolean call(Integer integer) {
                return integer&gt;4;
            }
        })
.subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString())); //5,6 
</code></pre><h4 id="ofType：-过滤指定类型的数据，与filter类似，"><a href="#ofType：-过滤指定类型的数据，与filter类似，" class="headerlink" title="ofType： 过滤指定类型的数据，与filter类似，"></a>ofType： 过滤指定类型的数据，与filter类似，</h4><pre><code>Observable.just(1,2,&quot;3&quot;)
        .ofType(Integer.class)
        .subscribe(item -&gt; Log.d(&quot;JG&quot;,item.toString()));
</code></pre><h4 id="take：-只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。"><a href="#take：-只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。" class="headerlink" title="take： 只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。"></a>take： 只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。</h4><pre><code>Observable.just(3,4,5,6)
        .take(3)//发射前三个数据项
        .take(100, TimeUnit.MILLISECONDS)//发射100ms内的数据
</code></pre><h4 id="takeLast：-只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。"><a href="#takeLast：-只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。" class="headerlink" title="takeLast： 只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。"></a>takeLast： 只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。</h4><pre><code>Observable.just(3,4,5,6)
        .takeLast(3)
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));//4,5,6
</code></pre><h4 id="takeFirst：提取满足条件的第一项。内部实现源码如下："><a href="#takeFirst：提取满足条件的第一项。内部实现源码如下：" class="headerlink" title="takeFirst：提取满足条件的第一项。内部实现源码如下："></a>takeFirst：提取满足条件的第一项。内部实现源码如下：</h4><pre><code>public final Observable&lt;T&gt; takeFirst(Func1&lt;? super T, Boolean&gt; predicate) {
  return filter(predicate).take(1); //先过滤，后提取
}
</code></pre><h4 id="first-firstOrDefault：只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。"><a href="#first-firstOrDefault：只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。" class="headerlink" title="first/firstOrDefault：只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。"></a>first/firstOrDefault：只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。</h4><pre><code>Observable.just(3,4,5,6)
        .first()
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));//3

Observable.just(3,4,5,6)
           .first(new Func1&lt;Integer, Boolean&gt;() {
               @Override
               public Boolean call(Integer integer) {
                   return integer&gt;3;
               }
           }) .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));//4
</code></pre><h4 id="last-lastOrDefault：只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。"><a href="#last-lastOrDefault：只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。" class="headerlink" title="last/lastOrDefault：只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。"></a>last/lastOrDefault：只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。</h4><h4 id="skip：跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。"><a href="#skip：跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。" class="headerlink" title="skip：跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。"></a>skip：跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。</h4><pre><code>Observable.just(3,4,5,6)
           .skip(1)
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));//4,5,6
</code></pre><h4 id="skipLast：跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。"><a href="#skipLast：跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。" class="headerlink" title="skipLast：跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。"></a>skipLast：跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。</h4><h4 id="elementAt-elementAtOrDefault：发射某一项数据，如果超过了范围可以的指定默认值。内部通过OperatorElementAt过滤。"><a href="#elementAt-elementAtOrDefault：发射某一项数据，如果超过了范围可以的指定默认值。内部通过OperatorElementAt过滤。" class="headerlink" title="elementAt/elementAtOrDefault：发射某一项数据，如果超过了范围可以的指定默认值。内部通过OperatorElementAt过滤。"></a>elementAt/elementAtOrDefault：发射某一项数据，如果超过了范围可以的指定默认值。内部通过OperatorElementAt过滤。</h4><pre><code>Observable.just(3,4,5,6)
         .elementAt(2)
.subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString())); //5
</code></pre><h4 id="ignoreElements：丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。"><a href="#ignoreElements：丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。" class="headerlink" title="ignoreElements：丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。"></a>ignoreElements：丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。</h4><h4 id="distinct：过滤重复数据，内部通过OperatorDistinct实现。"><a href="#distinct：过滤重复数据，内部通过OperatorDistinct实现。" class="headerlink" title="distinct：过滤重复数据，内部通过OperatorDistinct实现。"></a>distinct：过滤重复数据，内部通过OperatorDistinct实现。</h4><pre><code>Observable.just(3,4,5,6,3,3,4,9)
   .distinct()
  .subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString())); //3,4,5,6,9
</code></pre><h4 id="distinctUntilChanged：过滤掉连续重复的数据。内部通过OperatorDistinctUntilChanged实现"><a href="#distinctUntilChanged：过滤掉连续重复的数据。内部通过OperatorDistinctUntilChanged实现" class="headerlink" title="distinctUntilChanged：过滤掉连续重复的数据。内部通过OperatorDistinctUntilChanged实现"></a>distinctUntilChanged：过滤掉连续重复的数据。内部通过OperatorDistinctUntilChanged实现</h4><pre><code>Observable.just(3,4,5,6,3,3,4,9)
   .distinctUntilChanged()
  .subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString())); //3,4,5,6,3,4,9
</code></pre><h4 id="throttleFirst：定期发射Observable发射的第一项数据。内部通过OperatorThrottleFirst实现。"><a href="#throttleFirst：定期发射Observable发射的第一项数据。内部通过OperatorThrottleFirst实现。" class="headerlink" title="throttleFirst：定期发射Observable发射的第一项数据。内部通过OperatorThrottleFirst实现。"></a>throttleFirst：定期发射Observable发射的第一项数据。内部通过OperatorThrottleFirst实现。</h4><pre><code>Observable.create(subscriber -&gt; {
    subscriber.onNext(1);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(2);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }

    subscriber.onNext(3);
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(4);
    subscriber.onNext(5);
    subscriber.onCompleted();

}).throttleFirst(999, TimeUnit.MILLISECONDS)
        .subscribe(item-&gt; Log.d(&quot;JG&quot;,item.toString())); //结果为1,3,4
</code></pre><h4 id="throttleWithTimeout-debounce：发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据-直到指定时间内都没有新数据发射时"><a href="#throttleWithTimeout-debounce：发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据-直到指定时间内都没有新数据发射时" class="headerlink" title="throttleWithTimeout/debounce：发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据,直到指定时间内都没有新数据发射时"></a>throttleWithTimeout/debounce：发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据,直到指定时间内都没有新数据发射时</h4><p>才进行发射</p>
<pre><code>Observable.create(subscriber -&gt; {
    subscriber.onNext(1);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(2);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }

    subscriber.onNext(3);
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(4);
    subscriber.onNext(5);
    subscriber.onCompleted();

}).debounce(999, TimeUnit.MILLISECONDS)//或者为throttleWithTimeout(1000, TimeUnit.MILLISECONDS)
        .subscribe(item-&gt; Log.d(&quot;JG&quot;,item.toString())); //结果为3,5
</code></pre><h4 id="sample-throttleLast：定期发射Observable最近的数据。内部通过OperatorSampleWithTime实现。"><a href="#sample-throttleLast：定期发射Observable最近的数据。内部通过OperatorSampleWithTime实现。" class="headerlink" title="sample/throttleLast：定期发射Observable最近的数据。内部通过OperatorSampleWithTime实现。"></a>sample/throttleLast：定期发射Observable最近的数据。内部通过OperatorSampleWithTime实现。</h4><pre><code>Observable.create(subscriber -&gt; {
    subscriber.onNext(1);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(2);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }

    subscriber.onNext(3);
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(4);
    subscriber.onNext(5);
    subscriber.onCompleted();

}).sample(999, TimeUnit.MILLISECONDS)//或者为throttleLast(1000, TimeUnit.MILLISECONDS)
        .subscribe(item-&gt; Log.d(&quot;JG&quot;,item.toString())); //结果为2,3,5
</code></pre><h4 id="timeout：-如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。"><a href="#timeout：-如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。" class="headerlink" title="timeout： 如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。"></a>timeout： 如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。</h4><pre><code>Observable.create(( subscriber) -&gt; {
    subscriber.onNext(1);
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(2);

    subscriber.onCompleted();

}).timeout(999, TimeUnit.MILLISECONDS,Observable.just(99,100))//如果不指定备用Observable将会抛出异常
        .subscribe(item-&gt; Log.d(&quot;JG&quot;,item.toString()),error-&gt;Log.d(&quot;JG&quot;,&quot;onError&quot;)); //结果为1,99,100  如果不指定备用Observable结果为1,onError
}
</code></pre><h3 id="条件-布尔操作"><a href="#条件-布尔操作" class="headerlink" title="条件/布尔操作"></a>条件/布尔操作</h3><h4 id="all：-判断所有的数据项是否满足某个条件，内部通过OperatorAll实现。"><a href="#all：-判断所有的数据项是否满足某个条件，内部通过OperatorAll实现。" class="headerlink" title="all： 判断所有的数据项是否满足某个条件，内部通过OperatorAll实现。"></a>all： 判断所有的数据项是否满足某个条件，内部通过OperatorAll实现。</h4><pre><code>Observable.just(2,3,4,5)
        .all(new Func1&lt;Integer, Boolean&gt;() {
            @Override
            public Boolean call(Integer integer) {
                return integer&gt;3;
            }
        })
.subscribe(new Action1&lt;Boolean&gt;() {
    @Override
    public void call(Boolean aBoolean) {
        Log.d(&quot;JG&quot;,aBoolean.toString()); //false
    }
})
;
</code></pre><h4 id="exists：-判断是否存在数据项满足某个条件。内部通过OperatorAny实现。"><a href="#exists：-判断是否存在数据项满足某个条件。内部通过OperatorAny实现。" class="headerlink" title="exists： 判断是否存在数据项满足某个条件。内部通过OperatorAny实现。"></a>exists： 判断是否存在数据项满足某个条件。内部通过OperatorAny实现。</h4><pre><code>Observable.just(2,3,4,5)
        .exists(integer -&gt; integer&gt;3)
        .subscribe(aBoolean -&gt; Log.d(&quot;JG&quot;,aBoolean.toString())); //true
</code></pre><h4 id="contains：-判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是exists"><a href="#contains：-判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是exists" class="headerlink" title="contains： 判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是exists"></a>contains： 判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是exists</h4><pre><code>Observable.just(2,3,4,5)
        .contains(3)
        .subscribe(aBoolean -&gt; Log.d(&quot;JG&quot;,aBoolean.toString())); //true
</code></pre><h4 id="sequenceEqual：-用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。"><a href="#sequenceEqual：-用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。" class="headerlink" title="sequenceEqual： 用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。"></a>sequenceEqual： 用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。</h4><pre><code>Observable.sequenceEqual(Observable.just(2,3,4,5),Observable.just(2,3,4,5))
        .subscribe(aBoolean -&gt; Log.d(&quot;JG&quot;,aBoolean.toString()));//true
</code></pre><h4 id="isEmpty：-用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。"><a href="#isEmpty：-用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。" class="headerlink" title="isEmpty： 用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。"></a>isEmpty： 用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。</h4><pre><code>Observable.just(3,4,5,6)
           .isEmpty()
          .subscribe(item -&gt; Log.d(&quot;JG&quot;,item.toString()));//false
</code></pre><p>amb： 给定多个Observable，只让第一个发射数据的Observable发射全部数据，其他Observable将会被忽略。</p>
<pre><code>Observable&lt;Integer&gt; observable1=Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() {
    @Override
    public void call(Subscriber&lt;? super Integer&gt; subscriber) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            subscriber.onError(e);
        }
        subscriber.onNext(1);
        subscriber.onNext(2);
        subscriber.onCompleted();
    }
}).subscribeOn(Schedulers.computation());

Observable&lt;Integer&gt; observable2=Observable.create(subscriber -&gt; {
    subscriber.onNext(3);
    subscriber.onNext(4);
    subscriber.onCompleted();
});

Observable.amb(observable1,observable2)
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString())); //3,4
</code></pre><h4 id="switchIfEmpty：-如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。"><a href="#switchIfEmpty：-如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。" class="headerlink" title="switchIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。"></a>switchIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。</h4><pre><code>Observable.empty()
        .switchIfEmpty(Observable.just(2,3,4))
.subscribe(o -&gt; Log.d(&quot;JG&quot;,o.toString())); //2,3,4
</code></pre><h4 id="defaultIfEmpty：-如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值-内部调用的switchIfEmpty。"><a href="#defaultIfEmpty：-如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值-内部调用的switchIfEmpty。" class="headerlink" title="defaultIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值,内部调用的switchIfEmpty。"></a>defaultIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值,内部调用的switchIfEmpty。</h4><h4 id="takeUntil：-当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据。"><a href="#takeUntil：-当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据。" class="headerlink" title="takeUntil： 当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据。"></a>takeUntil： 当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据。</h4><pre><code>Observable.just(2,3,4,5)
        .takeUntil(new Func1&lt;Integer, Boolean&gt;() {
            @Override
            public Boolean call(Integer integer) {
                return integer==4;
            }
        }).subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString())); //2,3,4
</code></pre><h4 id="takeWhile：-当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。"><a href="#takeWhile：-当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。" class="headerlink" title="takeWhile： 当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。"></a>takeWhile： 当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。</h4><pre><code>Observable.just(2,3,4,5)
        .takeWhile(new Func1&lt;Integer, Boolean&gt;() {
            @Override
            public Boolean call(Integer integer) {
                return integer==4;
            }
        })
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString())); //2,3
</code></pre><h4 id="skipUntil：-丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）"><a href="#skipUntil：-丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）" class="headerlink" title="skipUntil： 丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）"></a>skipUntil： 丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）</h4><h4 id="skipWhile：-丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）"><a href="#skipWhile：-丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）" class="headerlink" title="skipWhile： 丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）"></a>skipWhile： 丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）</h4><h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><h4 id="reduce：-对序列使用reduce-函数并发射最终的结果-内部使用OnSubscribeReduce实现。"><a href="#reduce：-对序列使用reduce-函数并发射最终的结果-内部使用OnSubscribeReduce实现。" class="headerlink" title="reduce： 对序列使用reduce()函数并发射最终的结果,内部使用OnSubscribeReduce实现。"></a>reduce： 对序列使用reduce()函数并发射最终的结果,内部使用OnSubscribeReduce实现。</h4><pre><code>Observable.just(2,3,4,5)
        .reduce(new Func2&lt;Integer, Integer, Integer&gt;() {
            @Override
            public Integer call(Integer sum, Integer item) {
                return sum+item;
            }
        })
</code></pre><h4 id="collect：-使用collect收集数据到一个可变的数据结构。"><a href="#collect：-使用collect收集数据到一个可变的数据结构。" class="headerlink" title="collect： 使用collect收集数据到一个可变的数据结构。"></a>collect： 使用collect收集数据到一个可变的数据结构。</h4><pre><code>Observable.just(3,4,5,6)
           .collect(new Func0&lt;List&lt;Integer&gt;&gt;() { //创建数据结构

               @Override
               public List&lt;Integer&gt; call() {
                   return new ArrayList&lt;Integer&gt;();
               }
           }, new Action2&lt;List&lt;Integer&gt;, Integer&gt;() { //收集器
               @Override
               public void call(List&lt;Integer&gt; integers, Integer integer) {
                   integers.add(integer);
               }
           })
          .subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {
              @Override
              public void call(List&lt;Integer&gt; integers) {

              }
          });
</code></pre><h4 id="count-countLong：-计算发射的数量，内部调用的是reduce"><a href="#count-countLong：-计算发射的数量，内部调用的是reduce" class="headerlink" title="count/countLong： 计算发射的数量，内部调用的是reduce."></a>count/countLong： 计算发射的数量，内部调用的是reduce.</h4><h2 id="转换操作"><a href="#转换操作" class="headerlink" title="转换操作"></a>转换操作</h2><h4 id="toList：-收集原始Observable发射的所有数据到一个列表，然后返回这个列表"><a href="#toList：-收集原始Observable发射的所有数据到一个列表，然后返回这个列表" class="headerlink" title="toList： 收集原始Observable发射的所有数据到一个列表，然后返回这个列表."></a>toList： 收集原始Observable发射的所有数据到一个列表，然后返回这个列表.</h4><pre><code>Observable.just(2,3,4,5)
        .toList()
        .subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {
            @Override
            public void call(List&lt;Integer&gt; integers) {

            }
        });
</code></pre><h4 id="toSortedList：-收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表。"><a href="#toSortedList：-收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表。" class="headerlink" title="toSortedList： 收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表。"></a>toSortedList： 收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表。</h4><pre><code>Observable.just(6,2,3,4,5)
        .toSortedList(new Func2&lt;Integer, Integer, Integer&gt;() {//自定义排序
            @Override
            public Integer call(Integer integer, Integer integer2) {
                return integer-integer2; //&gt;0 升序 ，&lt;0 降序
            }
        })
        .subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {
            @Override
            public void call(List&lt;Integer&gt; integers) {
                Log.d(&quot;JG&quot;,integers.toString()); // [2, 3, 4, 5, 6]
            }
        });
</code></pre><h4 id="toMap：-将序列数据转换为一个Map。我们可以根据数据项生成key和生成value。"><a href="#toMap：-将序列数据转换为一个Map。我们可以根据数据项生成key和生成value。" class="headerlink" title="toMap： 将序列数据转换为一个Map。我们可以根据数据项生成key和生成value。"></a>toMap： 将序列数据转换为一个Map。我们可以根据数据项生成key和生成value。</h4><pre><code>Observable.just(6,2,3,4,5)
        .toMap(new Func1&lt;Integer, String&gt;() {
            @Override
            public String call(Integer integer) {
                return &quot;key：&quot; + integer; //根据数据项生成map的key
            }
        }, new Func1&lt;Integer, String&gt;() {
            @Override
            public String call(Integer integer) {
                return &quot;value：&quot;+integer; //根据数据项生成map的kvalue
            }
        }).subscribe(new Action1&lt;Map&lt;String, String&gt;&gt;() {
    @Override
    public void call(Map&lt;String, String&gt; stringStringMap) {
        Log.d(&quot;JG&quot;,stringStringMap.toString()); // {key：6=value：6, key：5=value：5, key：4=value：4, key：2=value：2, key：3=value：3}
    }
});
</code></pre><h4 id="toMultiMap：-类似于toMap，不同的地方在于map的value是一个集合。"><a href="#toMultiMap：-类似于toMap，不同的地方在于map的value是一个集合。" class="headerlink" title="toMultiMap： 类似于toMap，不同的地方在于map的value是一个集合。"></a>toMultiMap： 类似于toMap，不同的地方在于map的value是一个集合。</h4><h2 id="变换操作"><a href="#变换操作" class="headerlink" title="变换操作"></a>变换操作</h2><h4 id="map：-对Observable发射的每一项数据都应用一个函数来变换。"><a href="#map：-对Observable发射的每一项数据都应用一个函数来变换。" class="headerlink" title="map： 对Observable发射的每一项数据都应用一个函数来变换。"></a>map： 对Observable发射的每一项数据都应用一个函数来变换。</h4><pre><code>Observable.just(6,2,3,4,5)
        .map(integer -&gt; &quot;item:&quot;+integer)
        .subscribe(s -&gt; Log.d(&quot;JG&quot;,s));//item:6,item:2....
</code></pre><h4 id="cast：-在发射之前强制将Observable发射的所有数据转换为指定类型"><a href="#cast：-在发射之前强制将Observable发射的所有数据转换为指定类型" class="headerlink" title="cast： 在发射之前强制将Observable发射的所有数据转换为指定类型"></a>cast： 在发射之前强制将Observable发射的所有数据转换为指定类型</h4><h4 id="flatMap：-将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。"><a href="#flatMap：-将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。" class="headerlink" title="flatMap： 将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。"></a>flatMap： 将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。</h4><pre><code>   Observable.just(2,3,5)
        .flatMap(new Func1&lt;Integer, Observable&lt;String&gt;&gt;() {
            @Override
            public Observable&lt;String&gt; call(Integer integer) {
                return Observable.create(subscriber -&gt; {
                    subscriber.onNext(integer*10+&quot;&quot;);
                    subscriber.onNext(integer*100+&quot;&quot;);
                    subscriber.onCompleted();
                });
            }
        })
.subscribe(o -&gt; Log.d(&quot;JG&quot;,o)) //20,200,30,300,50,500
</code></pre><h4 id="flatMapIterable：-和flatMap的作用一样，只不过生成的是Iterable而不是Observable。"><a href="#flatMapIterable：-和flatMap的作用一样，只不过生成的是Iterable而不是Observable。" class="headerlink" title="flatMapIterable： 和flatMap的作用一样，只不过生成的是Iterable而不是Observable。"></a>flatMapIterable： 和flatMap的作用一样，只不过生成的是Iterable而不是Observable。</h4><pre><code>    Observable.just(2,3,5)
        .flatMapIterable(new Func1&lt;Integer, Iterable&lt;String&gt;&gt;() {
            @Override
            public Iterable&lt;String&gt; call(Integer integer) {
                return Arrays.asList(integer*10+&quot;&quot;,integer*100+&quot;&quot;);
            }
        }).subscribe(new Action1&lt;String&gt;() {
          @Override
          public void call(String s) {

          }
});
</code></pre><h4 id="concatMap：-类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。"><a href="#concatMap：-类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。" class="headerlink" title="concatMap： 类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。"></a>concatMap： 类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。</h4><h4 id="switchMap：-和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。"><a href="#switchMap：-和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。" class="headerlink" title="switchMap： 和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。"></a>switchMap： 和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。</h4><pre><code>Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() {

    @Override
    public void call(Subscriber&lt;? super Integer&gt; subscriber) {
        for(int i=1;i&lt;4;i++){
            subscriber.onNext(i);
            Utils.sleep(500,subscriber);//线程休眠500ms
        }

        subscriber.onCompleted();
    }
}).subscribeOn(Schedulers.newThread())
  .switchMap(new Func1&lt;Integer, Observable&lt;Integer&gt;&gt;() {
         @Override
       public Observable&lt;Integer&gt; call(Integer integer) {
               //每当接收到新的数据，之前的Observable将会被取消订阅
                return Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() {
                    @Override
                    public void call(Subscriber&lt;? super Integer&gt; subscriber) {
                        subscriber.onNext(integer*10);
                        Utils.sleep(500,subscriber);
                        subscriber.onNext(integer*100);
                        subscriber.onCompleted();
                    }
                }).subscribeOn(Schedulers.newThread());
            }
        })
        .subscribe(s -&gt; Log.d(&quot;JG&quot;,s.toString()));//10,20,30,300
</code></pre><h4 id="scan：-与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值。"><a href="#scan：-与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值。" class="headerlink" title="scan： 与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值。"></a>scan： 与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值。</h4><pre><code>Observable.just(2,3,5)
        .scan(new Func2&lt;Integer, Integer, Integer&gt;() {
            @Override
            public Integer call(Integer sum, Integer item) {
                return sum+item;
            }
        })
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString())) //2,5,10
</code></pre><h4 id="groupBy：-将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据。"><a href="#groupBy：-将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据。" class="headerlink" title="groupBy： 将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据。"></a>groupBy： 将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据。</h4><pre><code>Observable.just(2,3,5,6)
        .groupBy(new Func1&lt;Integer, String&gt;() {
            @Override
            public String call(Integer integer) {//分组
                return integer%2==0?&quot;偶数&quot;:&quot;奇数&quot;;
            }
        })
.subscribe(new Action1&lt;GroupedObservable&lt;String, Integer&gt;&gt;() {
    @Override
    public void call(GroupedObservable&lt;String, Integer&gt; o) {

        o.subscribe(new Action1&lt;Integer&gt;() {
            @Override
            public void call(Integer integer) {
                Log.d(&quot;JG&quot;,o.getKey()+&quot;:&quot;+integer.toString()); //偶数：2，奇数：3，...
            }
        });
    }
})
</code></pre><h4 id="buffer：-它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个"><a href="#buffer：-它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个" class="headerlink" title="buffer： 它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个"></a>buffer： 它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个</h4><pre><code>Observable.just(2,3,5,6)
        .buffer(3)
        .subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {
            @Override
            public void call(List&lt;Integer&gt; integers) {

            }
        })
</code></pre><h4 id="window：-定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。"><a href="#window：-定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。" class="headerlink" title="window： 定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。"></a>window： 定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。</h4><pre><code>Observable.just(2,3,5,6)
        .window(3)
        .subscribe(new Action1&lt;Observable&lt;Integer&gt;&gt;() {
            @Override
            public void call(Observable&lt;Integer&gt; integerObservable) {
                integerObservable.subscribe(new Action1&lt;Integer&gt;() {
                    @Override
                    public void call(Integer integer) {

                    }
                });
            }
        })
</code></pre><p>##错误处理/重试机制</p>
<h4 id="onErrorResumeNext：-当原始Observable在遇到错误时，使用备用Observable。。"><a href="#onErrorResumeNext：-当原始Observable在遇到错误时，使用备用Observable。。" class="headerlink" title="onErrorResumeNext： 当原始Observable在遇到错误时，使用备用Observable。。"></a>onErrorResumeNext： 当原始Observable在遇到错误时，使用备用Observable。。</h4><pre><code>Observable.just(1,&quot;2&quot;,3)
.cast(Integer.class)
.onErrorResumeNext(Observable.just(1,2,3))
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString())) //1,2,3
;
</code></pre><h4 id="onExceptionResumeNext：-当原始Observable在遇到异常时，使用备用的Observable。与onErrorResumeNext类似，区别在于onErrorResumeNext可以处理所有的错误，onExceptionResumeNext只能处理异常。"><a href="#onExceptionResumeNext：-当原始Observable在遇到异常时，使用备用的Observable。与onErrorResumeNext类似，区别在于onErrorResumeNext可以处理所有的错误，onExceptionResumeNext只能处理异常。" class="headerlink" title="onExceptionResumeNext： 当原始Observable在遇到异常时，使用备用的Observable。与onErrorResumeNext类似，区别在于onErrorResumeNext可以处理所有的错误，onExceptionResumeNext只能处理异常。"></a>onExceptionResumeNext： 当原始Observable在遇到异常时，使用备用的Observable。与onErrorResumeNext类似，区别在于onErrorResumeNext可以处理所有的错误，onExceptionResumeNext只能处理异常。</h4><h4 id="onErrorReturn：-当原始Observable在遇到错误时发射一个特定的数据。"><a href="#onErrorReturn：-当原始Observable在遇到错误时发射一个特定的数据。" class="headerlink" title="onErrorReturn： 当原始Observable在遇到错误时发射一个特定的数据。"></a>onErrorReturn： 当原始Observable在遇到错误时发射一个特定的数据。</h4><pre><code>Observable.just(1,&quot;2&quot;,3)
        .cast(Integer.class)
        .onErrorReturn(new Func1&lt;Throwable, Integer&gt;() {
            @Override
            public Integer call(Throwable throwable) {
                return 4;
            }
        }).subscribe(new Action1&lt;Integer&gt;() {
    @Override
    public void call(Integer integer) {
        Log.d(&quot;JG&quot;,integer.toString());1,4
    }
});
</code></pre><h4 id="retry：-当原始Observable在遇到错误时进行重试。"><a href="#retry：-当原始Observable在遇到错误时进行重试。" class="headerlink" title="retry： 当原始Observable在遇到错误时进行重试。"></a>retry： 当原始Observable在遇到错误时进行重试。</h4><pre><code>Observable.just(1,&quot;2&quot;,3)
.cast(Integer.class)
.retry(3)
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()),throwable -&gt; Log.d(&quot;JG&quot;,&quot;onError&quot;))
;//1,1,1,1,onError
</code></pre><h4 id="retryWhen：-当原始Observable在遇到错误，将错误传递给另一个Observable来决定是否要重新订阅这个Observable-内部调用的是retry。"><a href="#retryWhen：-当原始Observable在遇到错误，将错误传递给另一个Observable来决定是否要重新订阅这个Observable-内部调用的是retry。" class="headerlink" title="retryWhen： 当原始Observable在遇到错误，将错误传递给另一个Observable来决定是否要重新订阅这个Observable,内部调用的是retry。"></a>retryWhen： 当原始Observable在遇到错误，将错误传递给另一个Observable来决定是否要重新订阅这个Observable,内部调用的是retry。</h4><pre><code>Observable.just(1,&quot;2&quot;,3)
.cast(Integer.class)
.retryWhen(new Func1&lt;Observable&lt;? extends Throwable&gt;, Observable&lt;Long&gt;&gt;() {
    @Override
    public Observable&lt;Long&gt; call(Observable&lt;? extends Throwable&gt; observable) {
        return Observable.timer(1, TimeUnit.SECONDS);
    }
})
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()),throwable -&gt; Log.d(&quot;JG&quot;,&quot;onError&quot;));
//1,1
</code></pre><h2 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h2><h4 id="ConnectableObservable与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect-被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。"><a href="#ConnectableObservable与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect-被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。" class="headerlink" title="ConnectableObservable与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect()被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。"></a>ConnectableObservable与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect()被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。</h4><h4 id="ConnectableObservable-connect-指示一个可连接的Observable开始发射数据"><a href="#ConnectableObservable-connect-指示一个可连接的Observable开始发射数据" class="headerlink" title="ConnectableObservable.connect()指示一个可连接的Observable开始发射数据."></a>ConnectableObservable.connect()指示一个可连接的Observable开始发射数据.</h4><h4 id="Observable-publish-将一个Observable转换为一个可连接的Observable"><a href="#Observable-publish-将一个Observable转换为一个可连接的Observable" class="headerlink" title="Observable.publish()将一个Observable转换为一个可连接的Observable"></a>Observable.publish()将一个Observable转换为一个可连接的Observable</h4><h4 id="Observable-replay-确保所有的订阅者看到相同的数据序列的ConnectableObservable，即使它们在Observable开始发射数据之后才订阅。"><a href="#Observable-replay-确保所有的订阅者看到相同的数据序列的ConnectableObservable，即使它们在Observable开始发射数据之后才订阅。" class="headerlink" title="Observable.replay()确保所有的订阅者看到相同的数据序列的ConnectableObservable，即使它们在Observable开始发射数据之后才订阅。"></a>Observable.replay()确保所有的订阅者看到相同的数据序列的ConnectableObservable，即使它们在Observable开始发射数据之后才订阅。</h4><h4 id="ConnectableObservable-refCount-让一个可连接的Observable表现得像一个普通的Observable。"><a href="#ConnectableObservable-refCount-让一个可连接的Observable表现得像一个普通的Observable。" class="headerlink" title="ConnectableObservable.refCount()让一个可连接的Observable表现得像一个普通的Observable。"></a>ConnectableObservable.refCount()让一个可连接的Observable表现得像一个普通的Observable。</h4><pre><code>ConnectableObservable&lt;Integer&gt; co= Observable.just(1,2,3)
         .publish();

 co .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()) );
 co.connect();//此时开始发射数据
</code></pre><h2 id="阻塞操作"><a href="#阻塞操作" class="headerlink" title="阻塞操作"></a>阻塞操作</h2><h4 id="BlockingObservable是一个阻塞的Observable。普通的Observable-转换为BlockingObservable，可以使用-Observable-toBlocking-方法或者BlockingObservable-from-方法。内部通过CountDownLatch实现了阻塞操作。"><a href="#BlockingObservable是一个阻塞的Observable。普通的Observable-转换为BlockingObservable，可以使用-Observable-toBlocking-方法或者BlockingObservable-from-方法。内部通过CountDownLatch实现了阻塞操作。" class="headerlink" title="BlockingObservable是一个阻塞的Observable。普通的Observable 转换为BlockingObservable，可以使用 Observable.toBlocking( )方法或者BlockingObservable.from( )方法。内部通过CountDownLatch实现了阻塞操作。"></a>BlockingObservable是一个阻塞的Observable。普通的Observable 转换为BlockingObservable，可以使用 Observable.toBlocking( )方法或者BlockingObservable.from( )方法。内部通过CountDownLatch实现了阻塞操作。</h4><p>以下的操作符可以用于BlockingObservable，如果是普通的Observable，务必使用Observable.toBlocking()转为阻塞Observable后使用，否则达不到预期的效果。</p>
<h4 id="forEach：-对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。"><a href="#forEach：-对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。" class="headerlink" title="forEach： 对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。"></a>forEach： 对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。</h4><pre><code>Observable.just(2,3).observeOn(Schedulers.newThread()).toBlocking()
      .forEach(integer -&gt; {
          Log.d(&quot;JG&quot;,integer.toString()+&quot; &quot;+Thread.currentThread().getName());
          Utils.sleep(500);
      });

Log.d(&quot;JG&quot;,Thread.currentThread().getName());
// 2 RxNewThreadScheduler-1
// 3 RxNewThreadScheduler-1
// main
</code></pre><h4 id="first-firstOrDefault-last-lastOrDefault：这几个操作符之前有介绍过。也可以用于阻塞操作。"><a href="#first-firstOrDefault-last-lastOrDefault：这几个操作符之前有介绍过。也可以用于阻塞操作。" class="headerlink" title="first/firstOrDefault/last/lastOrDefault：这几个操作符之前有介绍过。也可以用于阻塞操作。"></a>first/firstOrDefault/last/lastOrDefault：这几个操作符之前有介绍过。也可以用于阻塞操作。</h4><h4 id="single-singleOrDefault：如果Observable终止时只发射了一个值，返回那个值，否则抛出异常或者发射默认值。"><a href="#single-singleOrDefault：如果Observable终止时只发射了一个值，返回那个值，否则抛出异常或者发射默认值。" class="headerlink" title="single/singleOrDefault：如果Observable终止时只发射了一个值，返回那个值，否则抛出异常或者发射默认值。"></a>single/singleOrDefault：如果Observable终止时只发射了一个值，返回那个值，否则抛出异常或者发射默认值。</h4><h4 id="mostRecent：返回一个总是返回Observable最近发射的数据的Iterable。"><a href="#mostRecent：返回一个总是返回Observable最近发射的数据的Iterable。" class="headerlink" title="mostRecent：返回一个总是返回Observable最近发射的数据的Iterable。"></a>mostRecent：返回一个总是返回Observable最近发射的数据的Iterable。</h4><h4 id="next：-返回一个Iterable，会阻塞直到Observable发射了第二个值，然后返回那个值。"><a href="#next：-返回一个Iterable，会阻塞直到Observable发射了第二个值，然后返回那个值。" class="headerlink" title="next： 返回一个Iterable，会阻塞直到Observable发射了第二个值，然后返回那个值。"></a>next： 返回一个Iterable，会阻塞直到Observable发射了第二个值，然后返回那个值。</h4><h4 id="latest：-返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值"><a href="#latest：-返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值" class="headerlink" title="latest： 返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值"></a>latest： 返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值</h4><h4 id="toFuture：-将Observable转换为一个Future"><a href="#toFuture：-将Observable转换为一个Future" class="headerlink" title="toFuture： 将Observable转换为一个Future"></a>toFuture： 将Observable转换为一个Future</h4><h4 id="toIterable：将一个发射数据序列的Observable转换为一个Iterable。"><a href="#toIterable：将一个发射数据序列的Observable转换为一个Iterable。" class="headerlink" title="toIterable：将一个发射数据序列的Observable转换为一个Iterable。"></a>toIterable：将一个发射数据序列的Observable转换为一个Iterable。</h4><h4 id="getIterator：将一个发射数据序列的Observable转换为一个Iterator工具集"><a href="#getIterator：将一个发射数据序列的Observable转换为一个Iterator工具集" class="headerlink" title="getIterator：将一个发射数据序列的Observable转换为一个Iterator工具集"></a>getIterator：将一个发射数据序列的Observable转换为一个Iterator工具集</h4><h4 id="materialize：-将Observable转换成一个通知列表。"><a href="#materialize：-将Observable转换成一个通知列表。" class="headerlink" title="materialize： 将Observable转换成一个通知列表。"></a>materialize： 将Observable转换成一个通知列表。</h4><pre><code>Observable.just(1,2,3)
       .materialize()
       .subscribe(new Action1&lt;Notification&lt;Integer&gt;&gt;() {
           @Override
           public void call(Notification&lt;Integer&gt; notification) {
               Log.d(&quot;JG&quot;,notification.getKind()+&quot; &quot;+notification.getValue());
               //OnNext 1
               //OnNext 2
               //OnNext 3
               //OnCompleted null
           }
       });
</code></pre><h4 id="dematerialize：-与上面的作用相反，将通知逆转回一个Observable。"><a href="#dematerialize：-与上面的作用相反，将通知逆转回一个Observable。" class="headerlink" title="dematerialize： 与上面的作用相反，将通知逆转回一个Observable。"></a>dematerialize： 与上面的作用相反，将通知逆转回一个Observable。</h4><h4 id="timestamp：-给Observable发射的每个数据项添加一个时间戳。"><a href="#timestamp：-给Observable发射的每个数据项添加一个时间戳。" class="headerlink" title="timestamp： 给Observable发射的每个数据项添加一个时间戳。"></a>timestamp： 给Observable发射的每个数据项添加一个时间戳。</h4><pre><code>Observable.just(1,2,3)
       .timestamp()
       .subscribe(new Action1&lt;Timestamped&lt;Integer&gt;&gt;() {
           @Override
           public void call(Timestamped&lt;Integer&gt; timestamped) {
               Log.d(&quot;JG&quot;,timestamped.getTimestampMillis()+&quot; &quot;+timestamped.getValue());
               //1472627510548 1
               //1472627510549 2
               //1472627510549 3
           }
       });
</code></pre><h4 id="timeInterval：给Observable发射的两个数据项间添加一个时间差，实现在OperatorTimeInterval中"><a href="#timeInterval：给Observable发射的两个数据项间添加一个时间差，实现在OperatorTimeInterval中" class="headerlink" title="timeInterval：给Observable发射的两个数据项间添加一个时间差，实现在OperatorTimeInterval中"></a>timeInterval：给Observable发射的两个数据项间添加一个时间差，实现在OperatorTimeInterval中</h4><p><img src="http://static.zybuluo.com/maplejaw/6dbl77xvh2z02hxil00juave/image_1argc8a1n17a61t441s5p1gln8231g.png" alt="Markdown preferences pane"></p>
<h4 id="serialize：-强制Observable按次序发射数据并且要求功能是完好的"><a href="#serialize：-强制Observable按次序发射数据并且要求功能是完好的" class="headerlink" title="serialize： 强制Observable按次序发射数据并且要求功能是完好的"></a>serialize： 强制Observable按次序发射数据并且要求功能是完好的</h4><h4 id="cache：-缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者"><a href="#cache：-缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者" class="headerlink" title="cache： 缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者"></a>cache： 缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者</h4><h4 id="observeOn：-指定观察者观察Observable的调度器"><a href="#observeOn：-指定观察者观察Observable的调度器" class="headerlink" title="observeOn： 指定观察者观察Observable的调度器"></a>observeOn： 指定观察者观察Observable的调度器</h4><h4 id="subscribeOn：-指定Observable执行任务的调度器"><a href="#subscribeOn：-指定Observable执行任务的调度器" class="headerlink" title="subscribeOn： 指定Observable执行任务的调度器"></a>subscribeOn： 指定Observable执行任务的调度器</h4><h4 id="doOnEach：-注册一个动作，对Observable发射的每个数据项使用"><a href="#doOnEach：-注册一个动作，对Observable发射的每个数据项使用" class="headerlink" title="doOnEach： 注册一个动作，对Observable发射的每个数据项使用"></a>doOnEach： 注册一个动作，对Observable发射的每个数据项使用</h4><pre><code>Observable.just(2,3)
        .doOnEach(new Action1&lt;Notification&lt;? super Integer&gt;&gt;() {
            @Override
            public void call(Notification&lt;? super Integer&gt; notification) {
                Log.d(&quot;JG&quot;,&quot;--doOnEach--&quot;+notification.toString());
            }
        })
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));
</code></pre><p>//结果为：<br> // –doOnEach–[rx.Notification@133c40b0 OnNext 2]<br>// 2<br> // –doOnEach–[rx.Notification@133c40b0 OnNext 3]<br>// 3<br>// –doOnEach–[rx.Notification@df4db0e OnCompleted]</p>
<h4 id="doOnCompleted：-注册一个动作，对正常完成的Observable使用"><a href="#doOnCompleted：-注册一个动作，对正常完成的Observable使用" class="headerlink" title="doOnCompleted： 注册一个动作，对正常完成的Observable使用"></a>doOnCompleted： 注册一个动作，对正常完成的Observable使用</h4><h4 id="doOnError：-注册一个动作，对发生错误的Observable使用"><a href="#doOnError：-注册一个动作，对发生错误的Observable使用" class="headerlink" title="doOnError： 注册一个动作，对发生错误的Observable使用"></a>doOnError： 注册一个动作，对发生错误的Observable使用</h4><h4 id="doOnTerminate：注册一个动作，对完成的Observable使用，无论是否发生错误"><a href="#doOnTerminate：注册一个动作，对完成的Observable使用，无论是否发生错误" class="headerlink" title="doOnTerminate：注册一个动作，对完成的Observable使用，无论是否发生错误"></a>doOnTerminate：注册一个动作，对完成的Observable使用，无论是否发生错误</h4><pre><code>Observable.just(2,3)
        .doOnTerminate(new Action0() {
            @Override
            public void call() {
                Log.d(&quot;JG&quot;,&quot;--doOnTerminate--&quot;);
            }
        })
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));// 2 , 3 , --doOnTerminate--
</code></pre><h4 id="doOnSubscribe：-注册一个动作，在观察者订阅时使用。内部由OperatorDoOnSubscribe实现，"><a href="#doOnSubscribe：-注册一个动作，在观察者订阅时使用。内部由OperatorDoOnSubscribe实现，" class="headerlink" title="doOnSubscribe： 注册一个动作，在观察者订阅时使用。内部由OperatorDoOnSubscribe实现，"></a>doOnSubscribe： 注册一个动作，在观察者订阅时使用。内部由OperatorDoOnSubscribe实现，<img src="http://static.zybuluo.com/maplejaw/9w3o5vxc0lzznbrpn4vwa78w/image_1argbe0o1atfqtbrj51gu0jho9.png" alt="Markdown preferences pane"></h4><h4 id="doOnUnsubscribe：-注册一个动作，在观察者取消订阅时使用。内部由OperatorDoOnUnsubscribe实现，在call中加入一个解绑动作。"><a href="#doOnUnsubscribe：-注册一个动作，在观察者取消订阅时使用。内部由OperatorDoOnUnsubscribe实现，在call中加入一个解绑动作。" class="headerlink" title="doOnUnsubscribe： 注册一个动作，在观察者取消订阅时使用。内部由OperatorDoOnUnsubscribe实现，在call中加入一个解绑动作。"></a>doOnUnsubscribe： 注册一个动作，在观察者取消订阅时使用。内部由OperatorDoOnUnsubscribe实现，在call中加入一个解绑动作。</h4><p><img src="http://static.zybuluo.com/maplejaw/791vkq1lxpl2etqaql85a6e8/image_1argbhutoi1a1b6a18s9il6npvm.png" alt="Markdown preferences pane"></p>
<h4 id="finallyDo-doAfterTerminate：-注册一个动作，在Observable完成时使用"><a href="#finallyDo-doAfterTerminate：-注册一个动作，在Observable完成时使用" class="headerlink" title="finallyDo/doAfterTerminate： 注册一个动作，在Observable完成时使用"></a>finallyDo/doAfterTerminate： 注册一个动作，在Observable完成时使用</h4><pre><code>Observable.just(2,3)
        .doAfterTerminate(new Action0() {
            @Override
            public void call() {
                Log.d(&quot;JG&quot;,&quot;--doAfterTerminate--&quot;);
            }
        })
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));
    //2,3,  --doAfterTerminate-- 
</code></pre><h4 id="delay：-延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。"><a href="#delay：-延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。" class="headerlink" title="delay： 延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。"></a>delay： 延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。</h4><h4 id="delaySubscription：-延时处理订阅请求。实现在OnSubscribeDelaySubscription中"><a href="#delaySubscription：-延时处理订阅请求。实现在OnSubscribeDelaySubscription中" class="headerlink" title="delaySubscription： 延时处理订阅请求。实现在OnSubscribeDelaySubscription中"></a>delaySubscription： 延时处理订阅请求。实现在OnSubscribeDelaySubscription中</h4><p><img src="http://static.zybuluo.com/maplejaw/xqw7fto75revvct4zu3d56a5/image_1argc0tbetbj1rkj1etf4fcb1p13.png" alt="Markdown preferences pane"></p>
<h4 id="using：-创建一个只在Observable生命周期存在的资源，当Observable终止时这个资源会被自动释放。"><a href="#using：-创建一个只在Observable生命周期存在的资源，当Observable终止时这个资源会被自动释放。" class="headerlink" title="using： 创建一个只在Observable生命周期存在的资源，当Observable终止时这个资源会被自动释放。"></a>using： 创建一个只在Observable生命周期存在的资源，当Observable终止时这个资源会被自动释放。</h4><pre><code>Observable.using(new Func0&lt;File&gt;() {//资源工厂
    @Override
    public File call() {

        File file = new File(getCacheDir(), &quot;a.txt&quot;);
        if(!file.exists()){
            try {
                Log.d(&quot;JG&quot;,&quot;--create--&quot;);
                file.createNewFile();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return file;
    }
}, new Func1&lt;File, Observable&lt;String&gt;&gt;() { //Observable
    @Override
    public Observable&lt;String&gt; call(File file) {
        return Observable.just(file.exists() ? &quot;exist&quot; : &quot;no exist&quot;);
    }
}, new Action1&lt;File&gt;() {//释放资源动作
    @Override
    public void call(File file) {
        if(file!=null&amp;&amp;file.exists()){
            Log.d(&quot;JG&quot;,&quot;--delete--&quot;);
            file.delete();
        }
    }
})
.subscribe(s -&gt; Log.d(&quot;JG&quot;,s))
;
//--create--
//exist
//--delete--
</code></pre><h4 id="single-singleOrDefault：-强制返回单个数据，否则抛出异常或默认数据。"><a href="#single-singleOrDefault：-强制返回单个数据，否则抛出异常或默认数据。" class="headerlink" title="single/singleOrDefault： 强制返回单个数据，否则抛出异常或默认数据。"></a>single/singleOrDefault： 强制返回单个数据，否则抛出异常或默认数据。</h4><p>关于RxJava标准库的操作符已经介绍完毕，纯粹当个备忘录。如有错误之处，欢迎指出。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Rxjava/" rel="tag"># Rxjava</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/26/Android中的TouchEvent触摸事件机制/" rel="next" title="Android中的TouchEvent触摸事件机制">
                <i class="fa fa-chevron-left"></i> Android中的TouchEvent触摸事件机制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/01/08/属性动画的使用原理/" rel="prev" title="属性动画的使用原理">
                属性动画的使用原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg"
               alt="fastabler" />
          <p class="site-author-name" itemprop="name">fastabler</p>
          <p class="site-description motion-element" itemprop="description">Efforts can only pass,hard to be excellent.</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建操作"><span class="nav-number">1.</span> <span class="nav-text">创建操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#以下操作符用于创建Observable。"><span class="nav-number">1.1.</span> <span class="nav-text">以下操作符用于创建Observable。</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#create：-使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe-call方法中检查订阅状态，以便及时停止发射数据或者运算。"><span class="nav-number">1.1.1.</span> <span class="nav-text">create： 使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe#call方法中检查订阅状态，以便及时停止发射数据或者运算。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#from：-将一个Iterable-一个Future-或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。"><span class="nav-number">1.1.2.</span> <span class="nav-text">from： 将一个Iterable, 一个Future, 或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#just：-将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。"><span class="nav-number">1.1.3.</span> <span class="nav-text">just： 将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#empty：-创建一个什么都不做直接通知完成的Observable"><span class="nav-number">1.1.4.</span> <span class="nav-text">empty： 创建一个什么都不做直接通知完成的Observable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#error：-创建一个什么都不做直接通知错误的Observable"><span class="nav-number">1.1.5.</span> <span class="nav-text">error： 创建一个什么都不做直接通知错误的Observable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#never：-创建一个什么都不做的Observable"><span class="nav-number">1.1.6.</span> <span class="nav-text">never： 创建一个什么都不做的Observable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#timer：-创建一个在给定的延时之后发射数据项为0的Observable-内部通过OnSubscribeTimerOnce工作"><span class="nav-number">1.1.7.</span> <span class="nav-text">timer： 创建一个在给定的延时之后发射数据项为0的Observable,内部通过OnSubscribeTimerOnce工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#interval：-创建一个按照给定的时间间隔发射从0开始的整数序列的Observable，内部通过OnSubscribeTimerPeriodically工作。"><span class="nav-number">1.1.8.</span> <span class="nav-text">interval： 创建一个按照给定的时间间隔发射从0开始的整数序列的Observable，内部通过OnSubscribeTimerPeriodically工作。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#range：-创建一个发射指定范围的整数序列的Observable"><span class="nav-number">1.1.9.</span> <span class="nav-text">range： 创建一个发射指定范围的整数序列的Observable</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#defer：-只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。"><span class="nav-number">1.1.9.1.</span> <span class="nav-text">defer： 只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合并操作"><span class="nav-number">2.</span> <span class="nav-text">合并操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#concat：-按顺序连接多个Observables。需要注意的是Observable-concat-a-b-等价于a-concatWith-b-。"><span class="nav-number">2.0.1.</span> <span class="nav-text">concat： 按顺序连接多个Observables。需要注意的是Observable.concat(a,b)等价于a.concatWith(b)。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#startWith：-在数据序列的开头增加一项数据。startWith的内部也是调用了concat"><span class="nav-number">2.0.2.</span> <span class="nav-text">startWith： 在数据序列的开头增加一项数据。startWith的内部也是调用了concat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#merge：-将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。"><span class="nav-number">2.0.3.</span> <span class="nav-text">merge： 将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#zip：-使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过OperatorZip进行压合。"><span class="nav-number">2.0.4.</span> <span class="nav-text">zip： 使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过OperatorZip进行压合。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#combineLatest：-当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable最近的数据压合。具体请看下面流程图。"><span class="nav-number">2.0.5.</span> <span class="nav-text">combineLatest： 当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable最近的数据压合。具体请看下面流程图。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过滤操作"><span class="nav-number">3.</span> <span class="nav-text">过滤操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#filter：-过滤数据。内部通过OnSubscribeFilter过滤数据。"><span class="nav-number">3.0.1.</span> <span class="nav-text">filter： 过滤数据。内部通过OnSubscribeFilter过滤数据。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ofType：-过滤指定类型的数据，与filter类似，"><span class="nav-number">3.0.2.</span> <span class="nav-text">ofType： 过滤指定类型的数据，与filter类似，</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#take：-只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。"><span class="nav-number">3.0.3.</span> <span class="nav-text">take： 只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#takeLast：-只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。"><span class="nav-number">3.0.4.</span> <span class="nav-text">takeLast： 只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#takeFirst：提取满足条件的第一项。内部实现源码如下："><span class="nav-number">3.0.5.</span> <span class="nav-text">takeFirst：提取满足条件的第一项。内部实现源码如下：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#first-firstOrDefault：只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。"><span class="nav-number">3.0.6.</span> <span class="nav-text">first/firstOrDefault：只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#last-lastOrDefault：只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。"><span class="nav-number">3.0.7.</span> <span class="nav-text">last/lastOrDefault：只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#skip：跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。"><span class="nav-number">3.0.8.</span> <span class="nav-text">skip：跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#skipLast：跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。"><span class="nav-number">3.0.9.</span> <span class="nav-text">skipLast：跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#elementAt-elementAtOrDefault：发射某一项数据，如果超过了范围可以的指定默认值。内部通过OperatorElementAt过滤。"><span class="nav-number">3.0.10.</span> <span class="nav-text">elementAt/elementAtOrDefault：发射某一项数据，如果超过了范围可以的指定默认值。内部通过OperatorElementAt过滤。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ignoreElements：丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。"><span class="nav-number">3.0.11.</span> <span class="nav-text">ignoreElements：丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#distinct：过滤重复数据，内部通过OperatorDistinct实现。"><span class="nav-number">3.0.12.</span> <span class="nav-text">distinct：过滤重复数据，内部通过OperatorDistinct实现。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#distinctUntilChanged：过滤掉连续重复的数据。内部通过OperatorDistinctUntilChanged实现"><span class="nav-number">3.0.13.</span> <span class="nav-text">distinctUntilChanged：过滤掉连续重复的数据。内部通过OperatorDistinctUntilChanged实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#throttleFirst：定期发射Observable发射的第一项数据。内部通过OperatorThrottleFirst实现。"><span class="nav-number">3.0.14.</span> <span class="nav-text">throttleFirst：定期发射Observable发射的第一项数据。内部通过OperatorThrottleFirst实现。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#throttleWithTimeout-debounce：发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据-直到指定时间内都没有新数据发射时"><span class="nav-number">3.0.15.</span> <span class="nav-text">throttleWithTimeout/debounce：发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据,直到指定时间内都没有新数据发射时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sample-throttleLast：定期发射Observable最近的数据。内部通过OperatorSampleWithTime实现。"><span class="nav-number">3.0.16.</span> <span class="nav-text">sample/throttleLast：定期发射Observable最近的数据。内部通过OperatorSampleWithTime实现。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#timeout：-如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。"><span class="nav-number">3.0.17.</span> <span class="nav-text">timeout： 如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件-布尔操作"><span class="nav-number">3.1.</span> <span class="nav-text">条件/布尔操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#all：-判断所有的数据项是否满足某个条件，内部通过OperatorAll实现。"><span class="nav-number">3.1.1.</span> <span class="nav-text">all： 判断所有的数据项是否满足某个条件，内部通过OperatorAll实现。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exists：-判断是否存在数据项满足某个条件。内部通过OperatorAny实现。"><span class="nav-number">3.1.2.</span> <span class="nav-text">exists： 判断是否存在数据项满足某个条件。内部通过OperatorAny实现。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#contains：-判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是exists"><span class="nav-number">3.1.3.</span> <span class="nav-text">contains： 判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是exists</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sequenceEqual：-用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。"><span class="nav-number">3.1.4.</span> <span class="nav-text">sequenceEqual： 用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#isEmpty：-用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。"><span class="nav-number">3.1.5.</span> <span class="nav-text">isEmpty： 用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#switchIfEmpty：-如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。"><span class="nav-number">3.1.6.</span> <span class="nav-text">switchIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defaultIfEmpty：-如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值-内部调用的switchIfEmpty。"><span class="nav-number">3.1.7.</span> <span class="nav-text">defaultIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值,内部调用的switchIfEmpty。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#takeUntil：-当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据。"><span class="nav-number">3.1.8.</span> <span class="nav-text">takeUntil： 当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#takeWhile：-当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。"><span class="nav-number">3.1.9.</span> <span class="nav-text">takeWhile： 当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#skipUntil：-丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）"><span class="nav-number">3.1.10.</span> <span class="nav-text">skipUntil： 丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#skipWhile：-丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）"><span class="nav-number">3.1.11.</span> <span class="nav-text">skipWhile： 丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚合操作"><span class="nav-number">3.2.</span> <span class="nav-text">聚合操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#reduce：-对序列使用reduce-函数并发射最终的结果-内部使用OnSubscribeReduce实现。"><span class="nav-number">3.2.1.</span> <span class="nav-text">reduce： 对序列使用reduce()函数并发射最终的结果,内部使用OnSubscribeReduce实现。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collect：-使用collect收集数据到一个可变的数据结构。"><span class="nav-number">3.2.2.</span> <span class="nav-text">collect： 使用collect收集数据到一个可变的数据结构。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#count-countLong：-计算发射的数量，内部调用的是reduce"><span class="nav-number">3.2.3.</span> <span class="nav-text">count/countLong： 计算发射的数量，内部调用的是reduce.</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#转换操作"><span class="nav-number">4.</span> <span class="nav-text">转换操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#toList：-收集原始Observable发射的所有数据到一个列表，然后返回这个列表"><span class="nav-number">4.0.1.</span> <span class="nav-text">toList： 收集原始Observable发射的所有数据到一个列表，然后返回这个列表.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#toSortedList：-收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表。"><span class="nav-number">4.0.2.</span> <span class="nav-text">toSortedList： 收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#toMap：-将序列数据转换为一个Map。我们可以根据数据项生成key和生成value。"><span class="nav-number">4.0.3.</span> <span class="nav-text">toMap： 将序列数据转换为一个Map。我们可以根据数据项生成key和生成value。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#toMultiMap：-类似于toMap，不同的地方在于map的value是一个集合。"><span class="nav-number">4.0.4.</span> <span class="nav-text">toMultiMap： 类似于toMap，不同的地方在于map的value是一个集合。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变换操作"><span class="nav-number">5.</span> <span class="nav-text">变换操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#map：-对Observable发射的每一项数据都应用一个函数来变换。"><span class="nav-number">5.0.1.</span> <span class="nav-text">map： 对Observable发射的每一项数据都应用一个函数来变换。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cast：-在发射之前强制将Observable发射的所有数据转换为指定类型"><span class="nav-number">5.0.2.</span> <span class="nav-text">cast： 在发射之前强制将Observable发射的所有数据转换为指定类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flatMap：-将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。"><span class="nav-number">5.0.3.</span> <span class="nav-text">flatMap： 将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flatMapIterable：-和flatMap的作用一样，只不过生成的是Iterable而不是Observable。"><span class="nav-number">5.0.4.</span> <span class="nav-text">flatMapIterable： 和flatMap的作用一样，只不过生成的是Iterable而不是Observable。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#concatMap：-类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。"><span class="nav-number">5.0.5.</span> <span class="nav-text">concatMap： 类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#switchMap：-和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。"><span class="nav-number">5.0.6.</span> <span class="nav-text">switchMap： 和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scan：-与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值。"><span class="nav-number">5.0.7.</span> <span class="nav-text">scan： 与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#groupBy：-将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据。"><span class="nav-number">5.0.8.</span> <span class="nav-text">groupBy： 将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#buffer：-它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个"><span class="nav-number">5.0.9.</span> <span class="nav-text">buffer： 它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#window：-定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。"><span class="nav-number">5.0.10.</span> <span class="nav-text">window： 定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#onErrorResumeNext：-当原始Observable在遇到错误时，使用备用Observable。。"><span class="nav-number">5.0.11.</span> <span class="nav-text">onErrorResumeNext： 当原始Observable在遇到错误时，使用备用Observable。。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#onExceptionResumeNext：-当原始Observable在遇到异常时，使用备用的Observable。与onErrorResumeNext类似，区别在于onErrorResumeNext可以处理所有的错误，onExceptionResumeNext只能处理异常。"><span class="nav-number">5.0.12.</span> <span class="nav-text">onExceptionResumeNext： 当原始Observable在遇到异常时，使用备用的Observable。与onErrorResumeNext类似，区别在于onErrorResumeNext可以处理所有的错误，onExceptionResumeNext只能处理异常。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#onErrorReturn：-当原始Observable在遇到错误时发射一个特定的数据。"><span class="nav-number">5.0.13.</span> <span class="nav-text">onErrorReturn： 当原始Observable在遇到错误时发射一个特定的数据。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#retry：-当原始Observable在遇到错误时进行重试。"><span class="nav-number">5.0.14.</span> <span class="nav-text">retry： 当原始Observable在遇到错误时进行重试。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#retryWhen：-当原始Observable在遇到错误，将错误传递给另一个Observable来决定是否要重新订阅这个Observable-内部调用的是retry。"><span class="nav-number">5.0.15.</span> <span class="nav-text">retryWhen： 当原始Observable在遇到错误，将错误传递给另一个Observable来决定是否要重新订阅这个Observable,内部调用的是retry。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连接操作"><span class="nav-number">6.</span> <span class="nav-text">连接操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ConnectableObservable与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect-被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。"><span class="nav-number">6.0.1.</span> <span class="nav-text">ConnectableObservable与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect()被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConnectableObservable-connect-指示一个可连接的Observable开始发射数据"><span class="nav-number">6.0.2.</span> <span class="nav-text">ConnectableObservable.connect()指示一个可连接的Observable开始发射数据.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Observable-publish-将一个Observable转换为一个可连接的Observable"><span class="nav-number">6.0.3.</span> <span class="nav-text">Observable.publish()将一个Observable转换为一个可连接的Observable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Observable-replay-确保所有的订阅者看到相同的数据序列的ConnectableObservable，即使它们在Observable开始发射数据之后才订阅。"><span class="nav-number">6.0.4.</span> <span class="nav-text">Observable.replay()确保所有的订阅者看到相同的数据序列的ConnectableObservable，即使它们在Observable开始发射数据之后才订阅。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConnectableObservable-refCount-让一个可连接的Observable表现得像一个普通的Observable。"><span class="nav-number">6.0.5.</span> <span class="nav-text">ConnectableObservable.refCount()让一个可连接的Observable表现得像一个普通的Observable。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阻塞操作"><span class="nav-number">7.</span> <span class="nav-text">阻塞操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BlockingObservable是一个阻塞的Observable。普通的Observable-转换为BlockingObservable，可以使用-Observable-toBlocking-方法或者BlockingObservable-from-方法。内部通过CountDownLatch实现了阻塞操作。"><span class="nav-number">7.0.1.</span> <span class="nav-text">BlockingObservable是一个阻塞的Observable。普通的Observable 转换为BlockingObservable，可以使用 Observable.toBlocking( )方法或者BlockingObservable.from( )方法。内部通过CountDownLatch实现了阻塞操作。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#forEach：-对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。"><span class="nav-number">7.0.2.</span> <span class="nav-text">forEach： 对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#first-firstOrDefault-last-lastOrDefault：这几个操作符之前有介绍过。也可以用于阻塞操作。"><span class="nav-number">7.0.3.</span> <span class="nav-text">first/firstOrDefault/last/lastOrDefault：这几个操作符之前有介绍过。也可以用于阻塞操作。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#single-singleOrDefault：如果Observable终止时只发射了一个值，返回那个值，否则抛出异常或者发射默认值。"><span class="nav-number">7.0.4.</span> <span class="nav-text">single/singleOrDefault：如果Observable终止时只发射了一个值，返回那个值，否则抛出异常或者发射默认值。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mostRecent：返回一个总是返回Observable最近发射的数据的Iterable。"><span class="nav-number">7.0.5.</span> <span class="nav-text">mostRecent：返回一个总是返回Observable最近发射的数据的Iterable。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#next：-返回一个Iterable，会阻塞直到Observable发射了第二个值，然后返回那个值。"><span class="nav-number">7.0.6.</span> <span class="nav-text">next： 返回一个Iterable，会阻塞直到Observable发射了第二个值，然后返回那个值。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#latest：-返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值"><span class="nav-number">7.0.7.</span> <span class="nav-text">latest： 返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#toFuture：-将Observable转换为一个Future"><span class="nav-number">7.0.8.</span> <span class="nav-text">toFuture： 将Observable转换为一个Future</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#toIterable：将一个发射数据序列的Observable转换为一个Iterable。"><span class="nav-number">7.0.9.</span> <span class="nav-text">toIterable：将一个发射数据序列的Observable转换为一个Iterable。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getIterator：将一个发射数据序列的Observable转换为一个Iterator工具集"><span class="nav-number">7.0.10.</span> <span class="nav-text">getIterator：将一个发射数据序列的Observable转换为一个Iterator工具集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#materialize：-将Observable转换成一个通知列表。"><span class="nav-number">7.0.11.</span> <span class="nav-text">materialize： 将Observable转换成一个通知列表。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dematerialize：-与上面的作用相反，将通知逆转回一个Observable。"><span class="nav-number">7.0.12.</span> <span class="nav-text">dematerialize： 与上面的作用相反，将通知逆转回一个Observable。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#timestamp：-给Observable发射的每个数据项添加一个时间戳。"><span class="nav-number">7.0.13.</span> <span class="nav-text">timestamp： 给Observable发射的每个数据项添加一个时间戳。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#timeInterval：给Observable发射的两个数据项间添加一个时间差，实现在OperatorTimeInterval中"><span class="nav-number">7.0.14.</span> <span class="nav-text">timeInterval：给Observable发射的两个数据项间添加一个时间差，实现在OperatorTimeInterval中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#serialize：-强制Observable按次序发射数据并且要求功能是完好的"><span class="nav-number">7.0.15.</span> <span class="nav-text">serialize： 强制Observable按次序发射数据并且要求功能是完好的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cache：-缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者"><span class="nav-number">7.0.16.</span> <span class="nav-text">cache： 缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#observeOn：-指定观察者观察Observable的调度器"><span class="nav-number">7.0.17.</span> <span class="nav-text">observeOn： 指定观察者观察Observable的调度器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#subscribeOn：-指定Observable执行任务的调度器"><span class="nav-number">7.0.18.</span> <span class="nav-text">subscribeOn： 指定Observable执行任务的调度器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#doOnEach：-注册一个动作，对Observable发射的每个数据项使用"><span class="nav-number">7.0.19.</span> <span class="nav-text">doOnEach： 注册一个动作，对Observable发射的每个数据项使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#doOnCompleted：-注册一个动作，对正常完成的Observable使用"><span class="nav-number">7.0.20.</span> <span class="nav-text">doOnCompleted： 注册一个动作，对正常完成的Observable使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#doOnError：-注册一个动作，对发生错误的Observable使用"><span class="nav-number">7.0.21.</span> <span class="nav-text">doOnError： 注册一个动作，对发生错误的Observable使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#doOnTerminate：注册一个动作，对完成的Observable使用，无论是否发生错误"><span class="nav-number">7.0.22.</span> <span class="nav-text">doOnTerminate：注册一个动作，对完成的Observable使用，无论是否发生错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#doOnSubscribe：-注册一个动作，在观察者订阅时使用。内部由OperatorDoOnSubscribe实现，"><span class="nav-number">7.0.23.</span> <span class="nav-text">doOnSubscribe： 注册一个动作，在观察者订阅时使用。内部由OperatorDoOnSubscribe实现，</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#doOnUnsubscribe：-注册一个动作，在观察者取消订阅时使用。内部由OperatorDoOnUnsubscribe实现，在call中加入一个解绑动作。"><span class="nav-number">7.0.24.</span> <span class="nav-text">doOnUnsubscribe： 注册一个动作，在观察者取消订阅时使用。内部由OperatorDoOnUnsubscribe实现，在call中加入一个解绑动作。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finallyDo-doAfterTerminate：-注册一个动作，在Observable完成时使用"><span class="nav-number">7.0.25.</span> <span class="nav-text">finallyDo/doAfterTerminate： 注册一个动作，在Observable完成时使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#delay：-延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。"><span class="nav-number">7.0.26.</span> <span class="nav-text">delay： 延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#delaySubscription：-延时处理订阅请求。实现在OnSubscribeDelaySubscription中"><span class="nav-number">7.0.27.</span> <span class="nav-text">delaySubscription： 延时处理订阅请求。实现在OnSubscribeDelaySubscription中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#using：-创建一个只在Observable生命周期存在的资源，当Observable终止时这个资源会被自动释放。"><span class="nav-number">7.0.28.</span> <span class="nav-text">using： 创建一个只在Observable生命周期存在的资源，当Observable终止时这个资源会被自动释放。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#single-singleOrDefault：-强制返回单个数据，否则抛出异常或默认数据。"><span class="nav-number">7.0.29.</span> <span class="nav-text">single/singleOrDefault： 强制返回单个数据，否则抛出异常或默认数据。</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fastabler</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid="></script>
      <!-- UY END -->
  




  
  

  

  

  

  


</body>
</html>

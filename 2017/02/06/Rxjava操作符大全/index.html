<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Rxjava操作符大全 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="创建操作以下操作符用于创建Observable。create： 使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe#call方法中检查订阅状态，以便及时停止发射数据或者运算。
Observable.create(new Observable.OnSubscribe&amp;lt;String&amp;gt;() {">
<meta property="og:type" content="article">
<meta property="og:title" content="Rxjava操作符大全">
<meta property="og:url" content="http://yoursite.com/2017/02/06/Rxjava操作符大全/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="创建操作以下操作符用于创建Observable。create： 使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe#call方法中检查订阅状态，以便及时停止发射数据或者运算。
Observable.create(new Observable.OnSubscribe&amp;lt;String&amp;gt;() {">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/1a7gi8os6u4kgk7aahzmj1d0/image_1arcl6d0a1iej60e6ccp48qic9.png">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/bu67z13p279yu074arzslsyd/image_1ard6160913ui3r6orodc41pntm.png">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/tuo7jn6ijtzsa1c3ak77umtu/image_1ard609fsi3p9n7160iq0r1rqe9.png">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/6dbl77xvh2z02hxil00juave/image_1argc8a1n17a61t441s5p1gln8231g.png">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/9w3o5vxc0lzznbrpn4vwa78w/image_1argbe0o1atfqtbrj51gu0jho9.png">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/791vkq1lxpl2etqaql85a6e8/image_1argbhutoi1a1b6a18s9il6npvm.png">
<meta property="og:image" content="http://static.zybuluo.com/maplejaw/xqw7fto75revvct4zu3d56a5/image_1argc0tbetbj1rkj1etf4fcb1p13.png">
<meta property="og:updated_time" content="2017-02-06T11:56:46.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rxjava操作符大全">
<meta name="twitter:description" content="创建操作以下操作符用于创建Observable。create： 使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe#call方法中检查订阅状态，以便及时停止发射数据或者运算。
Observable.create(new Observable.OnSubscribe&amp;lt;String&amp;gt;() {">
<meta name="twitter:image" content="http://static.zybuluo.com/maplejaw/1a7gi8os6u4kgk7aahzmj1d0/image_1arcl6d0a1iej60e6ccp48qic9.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Rxjava操作符大全" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/06/Rxjava操作符大全/" class="article-date">
  <time datetime="2017-02-06T10:19:52.000Z" itemprop="datePublished">2017-02-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Rxjava操作符大全
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="创建操作"><a href="#创建操作" class="headerlink" title="创建操作"></a>创建操作</h2><h3 id="以下操作符用于创建Observable。"><a href="#以下操作符用于创建Observable。" class="headerlink" title="以下操作符用于创建Observable。"></a>以下操作符用于创建Observable。</h3><p>create： 使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe#call方法中检查订阅状态，以便及时停止发射数据或者运算。</p>
<pre><code>Observable.create(new Observable.OnSubscribe&lt;String&gt;() {

    @Override
    public void call(Subscriber&lt;? super String&gt; subscriber) {

        subscriber.onNext(&quot;item1&quot;);
        subscriber.onNext(&quot;item2&quot;);
        subscriber.onCompleted();
    }
});
</code></pre><p>from： 将一个Iterable, 一个Future, 或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。<br><img src="http://static.zybuluo.com/maplejaw/1a7gi8os6u4kgk7aahzmj1d0/image_1arcl6d0a1iej60e6ccp48qic9.png" alt="Markdown preferences pane"></p>
<pre><code>//Iterable
List&lt;String&gt; list=new ArrayList&lt;&gt;();
...
Observable.from(list)
        .subscribe(new Action1&lt;String&gt;() {
    @Override
    public void call(String s) {

    }
});

//Future
 Future&lt;String&gt; futrue= Executors.newSingleThreadExecutor().submit(new Callable&lt;String&gt;() {

    @Override
    public String call() throws Exception {
        Thread.sleep(1000);
        return &quot;maplejaw&quot;;
    }
});

Observable.from(futrue)
          .subscribe(new Action1&lt;String&gt;() {
    @Override
    public void call(String s) {

    }
});
</code></pre><p>;</p>
<p>just： 将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。</p>
<p>empty： 创建一个什么都不做直接通知完成的Observable<br>error： 创建一个什么都不做直接通知错误的Observable<br>never： 创建一个什么都不做的Observable</p>
<pre><code>Observable observable1=Observable.empty();//直接调用onCompleted。
Observable observable2=Observable.error(new RuntimeException());//直接调用onError。这里可以自定义异常
Observable observable3=Observable.never();//啥都不做
</code></pre><p>timer： 创建一个在给定的延时之后发射数据项为0的Observable<long>,内部通过OnSubscribeTimerOnce工作</long></p>
<p> Observable.timer(1000,TimeUnit.MILLISECONDS)<br>            .subscribe(new Action1<long>() {<br>                @Override<br>                public void call(Long aLong) {<br>                    Log.d(“JG”,aLong.toString()); // 0<br>                }<br>            });</long></p>
<p>interval： 创建一个按照给定的时间间隔发射从0开始的整数序列的Observable<long>，内部通过OnSubscribeTimerPeriodically工作。</long></p>
<p>  Observable.interval(1, TimeUnit.SECONDS)<br>            .subscribe(new Action1<long>() {<br>                @Override<br>                public void call(Long aLong) {<br>                     //每隔1秒发送数据项，从0开始计数<br>                     //0,1,2,3….<br>                }<br>            });</long></p>
<p>range： 创建一个发射指定范围的整数序列的Observable<integer></integer></p>
<p> Observable.range(2,5).subscribe(new Action1<integer>() {<br>        @Override<br>        public void call(Integer integer) {<br>            Log.d(“JG”,integer.toString());// 2,3,4,5,6 从2开始发射5个数据<br>        }<br>    });</integer></p>
<p>defer： 只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。</p>
<p>  Observable.defer(new Func0<observable<string>&gt;() {<br>        @Override<br>        public Observable<string> call() {<br>            return Observable.just(“hello”);<br>        }<br>    }).subscribe(new Action1<string>() {<br>        @Override<br>        public void call(String s) {<br>            Log.d(“JG”,s);<br>        }<br>    });</string></string></observable<string></p>
<h2 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h2><p>以下操作符用于组合多个Observable。</p>
<p>注意，为了使结构更加清晰以及缩小代码量，之后的例子部分地方将会使用Lambda表达式书写，如果你对Lambda表达式不太熟悉的话，可以阅读JAVA8 Lambda表达式完全解析这篇文章。<br>concat： 按顺序连接多个Observables。需要注意的是Observable.concat(a,b)等价于a.concatWith(b)。</p>
<pre><code>Observable&lt;Integer&gt; observable1=Observable.just(1,2,3,4);
Observable&lt;Integer&gt;  observable2=Observable.just(4,5,6);

Observable.concat(observable1,observable2)
        .subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString()));//1,2,3,4,4,5,6
</code></pre><p>startWith： 在数据序列的开头增加一项数据。startWith的内部也是调用了concat</p>
<p> Observable.just(1,2,3,4,5)<br>            .startWith(6,7,8)<br>    .subscribe(item-&gt;Log.d(“JG”,item.toString()));//6,7,8,1,2,3,4,5</p>
<p>merge： 将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。 </p>
<p>zip： 使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过OperatorZip进行压合。</p>
<p>Observable<integer>  observable1=Observable.just(1,2,3,4);<br>Observable<integer>  observable2=Observable.just(4,5,6);</integer></integer></p>
<pre><code>Observable.zip(observable1, observable2, new Func2&lt;Integer, Integer, String&gt;() {
    @Override
    public String call(Integer item1, Integer item2) {
        return item1+&quot;and&quot;+item2;
    }
})
.subscribe(item-&gt;Log.d(&quot;JG&quot;,item)); //1and4,2and5,3and6
</code></pre><p>combineLatest： 。当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable最近的数据压合。具体请看下面流程图。<br>zip工作流程<br><img src="http://static.zybuluo.com/maplejaw/bu67z13p279yu074arzslsyd/image_1ard6160913ui3r6orodc41pntm.png" alt="Markdown preferences pane"></p>
<p>combineLatest工作流程<br><img src="http://static.zybuluo.com/maplejaw/tuo7jn6ijtzsa1c3ak77umtu/image_1ard609fsi3p9n7160iq0r1rqe9.png" alt="Markdown preferences pane"></p>
<h2 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h2><p>filter： 过滤数据。内部通过OnSubscribeFilter过滤数据。</p>
<p>  Observable.just(3,4,5,6)<br>            .filter(new Func1<integer, boolean="">() {<br>                @Override<br>                public Boolean call(Integer integer) {<br>                    return integer&gt;4;<br>                }<br>            })<br>    .subscribe(item-&gt;Log.d(“JG”,item.toString())); //5,6 </integer,></p>
<p>ofType： 过滤指定类型的数据，与filter类似，</p>
<p>Observable.just(1,2,”3”)<br>            .ofType(Integer.class)<br>            .subscribe(item -&gt; Log.d(“JG”,item.toString()));</p>
<p>take： 只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。</p>
<p>  Observable.just(3,4,5,6)<br>            .take(3)//发射前三个数据项<br>            .take(100, TimeUnit.MILLISECONDS)//发射100ms内的数据</p>
<p>takeLast： 只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。</p>
<p> Observable.just(3,4,5,6)<br>            .takeLast(3)<br>            .subscribe(integer -&gt; Log.d(“JG”,integer.toString()));//4,5,6</p>
<p>takeFirst：提取满足条件的第一项。内部实现源码如下：</p>
<p>public final Observable<t> takeFirst(Func1&lt;? super T, Boolean&gt; predicate) {<br>      return filter(predicate).take(1); //先过滤，后提取<br>}</t></p>
<p>first/firstOrDefault：只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。</p>
<p> Observable.just(3,4,5,6)<br>            .first()<br>            .subscribe(integer -&gt; Log.d(“JG”,integer.toString()));//3</p>
<pre><code>Observable.just(3,4,5,6)
           .first(new Func1&lt;Integer, Boolean&gt;() {
               @Override
               public Boolean call(Integer integer) {
                   return integer&gt;3;
               }
           }) .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));//4
</code></pre><p>last/lastOrDefault：只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。</p>
<p>skip：跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。</p>
<p>  Observable.just(3,4,5,6)<br>               .skip(1)<br>            .subscribe(integer -&gt; Log.d(“JG”,integer.toString()));//4,5,6</p>
<p>skipLast：跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。</p>
<p>elementAt/elementAtOrDefault：发射某一项数据，如果超过了范围可以的指定默认值。内部通过OperatorElementAt过滤。<br>        Observable.just(3,4,5,6)<br>                 .elementAt(2)<br>        .subscribe(item-&gt;Log.d(“JG”,item.toString())); //5</p>
<p>ignoreElements：丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。</p>
<p>distinct：过滤重复数据，内部通过OperatorDistinct实现。</p>
<p> Observable.just(3,4,5,6,3,3,4,9)<br>       .distinct()<br>      .subscribe(item-&gt;Log.d(“JG”,item.toString())); //3,4,5,6,9</p>
<p>distinctUntilChanged：过滤掉连续重复的数据。内部通过OperatorDistinctUntilChanged实现</p>
<p> Observable.just(3,4,5,6,3,3,4,9)<br>       .distinctUntilChanged()<br>      .subscribe(item-&gt;Log.d(“JG”,item.toString())); //3,4,5,6,3,4,9</p>
<p>throttleFirst：定期发射Observable发射的第一项数据。内部通过OperatorThrottleFirst实现。</p>
<p>Observable.create(subscriber -&gt; {<br>        subscriber.onNext(1);<br>        try {<br>            Thread.sleep(500);<br>        } catch (InterruptedException e) {<br>            throw Exceptions.propagate(e);<br>        }<br>        subscriber.onNext(2);<br>        try {<br>            Thread.sleep(500);<br>        } catch (InterruptedException e) {<br>            throw Exceptions.propagate(e);<br>        }</p>
<pre><code>    subscriber.onNext(3);
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(4);
    subscriber.onNext(5);
    subscriber.onCompleted();

}).throttleFirst(999, TimeUnit.MILLISECONDS)
        .subscribe(item-&gt; Log.d(&quot;JG&quot;,item.toString())); //结果为1,3,4
</code></pre><p>throttleWithTimeout/debounce：发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据,直到指定时间内都没有新数据发射时<br>才进行发射</p>
<p>Observable.create(subscriber -&gt; {<br>        subscriber.onNext(1);<br>        try {<br>            Thread.sleep(500);<br>        } catch (InterruptedException e) {<br>            throw Exceptions.propagate(e);<br>        }<br>        subscriber.onNext(2);<br>        try {<br>            Thread.sleep(500);<br>        } catch (InterruptedException e) {<br>            throw Exceptions.propagate(e);<br>        }</p>
<pre><code>    subscriber.onNext(3);
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(4);
    subscriber.onNext(5);
    subscriber.onCompleted();

}).debounce(999, TimeUnit.MILLISECONDS)//或者为throttleWithTimeout(1000, TimeUnit.MILLISECONDS)
        .subscribe(item-&gt; Log.d(&quot;JG&quot;,item.toString())); //结果为3,5
</code></pre><p>sample/throttleLast：定期发射Observable最近的数据。内部通过OperatorSampleWithTime实现。</p>
<p> Observable.create(subscriber -&gt; {<br>        subscriber.onNext(1);<br>        try {<br>            Thread.sleep(500);<br>        } catch (InterruptedException e) {<br>            throw Exceptions.propagate(e);<br>        }<br>        subscriber.onNext(2);<br>        try {<br>            Thread.sleep(500);<br>        } catch (InterruptedException e) {<br>            throw Exceptions.propagate(e);<br>        }</p>
<pre><code>    subscriber.onNext(3);
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(4);
    subscriber.onNext(5);
    subscriber.onCompleted();

}).sample(999, TimeUnit.MILLISECONDS)//或者为throttleLast(1000, TimeUnit.MILLISECONDS)
        .subscribe(item-&gt; Log.d(&quot;JG&quot;,item.toString())); //结果为2,3,5
</code></pre><p>timeout： 如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。</p>
<p>   Observable.create(( subscriber) -&gt; {<br>        subscriber.onNext(1);<br>        try {<br>            Thread.sleep(1000);<br>        } catch (InterruptedException e) {<br>            throw Exceptions.propagate(e);<br>        }<br>        subscriber.onNext(2);</p>
<pre><code>    subscriber.onCompleted();

}).timeout(999, TimeUnit.MILLISECONDS,Observable.just(99,100))//如果不指定备用Observable将会抛出异常
        .subscribe(item-&gt; Log.d(&quot;JG&quot;,item.toString()),error-&gt;Log.d(&quot;JG&quot;,&quot;onError&quot;)); //结果为1,99,100  如果不指定备用Observable结果为1,onError
</code></pre><p>}</p>
<p>条件/布尔操作</p>
<p>all： 判断所有的数据项是否满足某个条件，内部通过OperatorAll实现。</p>
<p>  Observable.just(2,3,4,5)<br>            .all(new Func1<integer, boolean="">() {<br>                @Override<br>                public Boolean call(Integer integer) {<br>                    return integer&gt;3;<br>                }<br>            })<br>    .subscribe(new Action1<boolean>() {<br>        @Override<br>        public void call(Boolean aBoolean) {<br>            Log.d(“JG”,aBoolean.toString()); //false<br>        }<br>    })<br>    ;</boolean></integer,></p>
<p>exists： 判断是否存在数据项满足某个条件。内部通过OperatorAny实现。</p>
<p>   Observable.just(2,3,4,5)<br>            .exists(integer -&gt; integer&gt;3)<br>            .subscribe(aBoolean -&gt; Log.d(“JG”,aBoolean.toString())); //true</p>
<p>contains： 判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是exists</p>
<p>  Observable.just(2,3,4,5)<br>            .contains(3)<br>            .subscribe(aBoolean -&gt; Log.d(“JG”,aBoolean.toString())); //true</p>
<p>sequenceEqual： 用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。</p>
<p> Observable.sequenceEqual(Observable.just(2,3,4,5),Observable.just(2,3,4,5))<br>            .subscribe(aBoolean -&gt; Log.d(“JG”,aBoolean.toString()));//true</p>
<p>isEmpty： 用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。</p>
<p>  Observable.just(3,4,5,6)<br>               .isEmpty()<br>              .subscribe(item -&gt; Log.d(“JG”,item.toString()));//false</p>
<p>amb： 给定多个Observable，只让第一个发射数据的Observable发射全部数据，其他Observable将会被忽略。</p>
<pre><code>Observable&lt;Integer&gt; observable1=Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() {
    @Override
    public void call(Subscriber&lt;? super Integer&gt; subscriber) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            subscriber.onError(e);
        }
        subscriber.onNext(1);
        subscriber.onNext(2);
        subscriber.onCompleted();
    }
}).subscribeOn(Schedulers.computation());

Observable&lt;Integer&gt; observable2=Observable.create(subscriber -&gt; {
    subscriber.onNext(3);
    subscriber.onNext(4);
    subscriber.onCompleted();
});

Observable.amb(observable1,observable2)
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString())); //3,4
</code></pre><p>switchIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。</p>
<p>   Observable.empty()<br>            .switchIfEmpty(Observable.just(2,3,4))<br>    .subscribe(o -&gt; Log.d(“JG”,o.toString())); //2,3,4</p>
<p>defaultIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值,内部调用的switchIfEmpty。<br>takeUntil： 当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据。</p>
<p> Observable.just(2,3,4,5)<br>            .takeUntil(new Func1<integer, boolean="">() {<br>                @Override<br>                public Boolean call(Integer integer) {<br>                    return integer==4;<br>                }<br>            }).subscribe(integer -&gt; Log.d(“JG”,integer.toString())); //2,3,4</integer,></p>
<p>takeWhile： 当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。</p>
<p>  Observable.just(2,3,4,5)<br>            .takeWhile(new Func1<integer, boolean="">() {<br>                @Override<br>                public Boolean call(Integer integer) {<br>                    return integer==4;<br>                }<br>            })<br>            .subscribe(integer -&gt; Log.d(“JG”,integer.toString())); //2,3</integer,></p>
<p>skipUntil： 丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）<br>skipWhile： 丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）<br>聚合操作</p>
<p>reduce： 对序列使用reduce()函数并发射最终的结果,内部使用OnSubscribeReduce实现。</p>
<p>  Observable.just(2,3,4,5)<br>            .reduce(new Func2<integer, integer,="" integer="">() {<br>                @Override<br>                public Integer call(Integer sum, Integer item) {<br>                    return sum+item;<br>                }<br>            })</integer,></p>
<p>collect： 使用collect收集数据到一个可变的数据结构。</p>
<p>  Observable.just(3,4,5,6)<br>               .collect(new Func0<list<integer>&gt;() { //创建数据结构</list<integer></p>
<pre><code>     @Override
     public List&lt;Integer&gt; call() {
         return new ArrayList&lt;Integer&gt;();
     }
 }, new Action2&lt;List&lt;Integer&gt;, Integer&gt;() { //收集器
     @Override
     public void call(List&lt;Integer&gt; integers, Integer integer) {
         integers.add(integer);
     }
 })
.subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {
    @Override
    public void call(List&lt;Integer&gt; integers) {

    }
});
</code></pre><p>count/countLong： 计算发射的数量，内部调用的是reduce.</p>
<h2 id="转换操作"><a href="#转换操作" class="headerlink" title="转换操作"></a>转换操作</h2><p>toList： 收集原始Observable发射的所有数据到一个列表，然后返回这个列表.</p>
<pre><code>Observable.just(2,3,4,5)
        .toList()
        .subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {
            @Override
            public void call(List&lt;Integer&gt; integers) {

            }
        });
</code></pre><p>toSortedList： 收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表。</p>
<p>   Observable.just(6,2,3,4,5)<br>            .toSortedList(new Func2<integer, integer,="" integer="">() {//自定义排序<br>                @Override<br>                public Integer call(Integer integer, Integer integer2) {<br>                    return integer-integer2; //&gt;0 升序 ，<0 降序="" }="" })="" .subscribe(new="" action1<list<integer="">&gt;() {<br>                @Override<br>                public void call(List<integer> integers) {<br>                    Log.d(“JG”,integers.toString()); // [2, 3, 4, 5, 6]<br>                }<br>            });</integer></0></integer,></p>
<p>toMap： 将序列数据转换为一个Map。我们可以根据数据项生成key和生成value。</p>
<pre><code>Observable.just(6,2,3,4,5)
        .toMap(new Func1&lt;Integer, String&gt;() {
            @Override
            public String call(Integer integer) {
                return &quot;key：&quot; + integer; //根据数据项生成map的key
            }
        }, new Func1&lt;Integer, String&gt;() {
            @Override
            public String call(Integer integer) {
                return &quot;value：&quot;+integer; //根据数据项生成map的kvalue
            }
        }).subscribe(new Action1&lt;Map&lt;String, String&gt;&gt;() {
    @Override
    public void call(Map&lt;String, String&gt; stringStringMap) {
        Log.d(&quot;JG&quot;,stringStringMap.toString()); // {key：6=value：6, key：5=value：5, key：4=value：4, key：2=value：2, key：3=value：3}
    }
});
</code></pre><p>toMultiMap： 类似于toMap，不同的地方在于map的value是一个集合。</p>
<h2 id="变换操作"><a href="#变换操作" class="headerlink" title="变换操作"></a>变换操作</h2><p>map： 对Observable发射的每一项数据都应用一个函数来变换。</p>
<p> Observable.just(6,2,3,4,5)<br>            .map(integer -&gt; “item:”+integer)<br>            .subscribe(s -&gt; Log.d(“JG”,s));//item:6,item:2….</p>
<p>cast： 在发射之前强制将Observable发射的所有数据转换为指定类型<br>flatMap： 将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。</p>
<pre><code>   Observable.just(2,3,5)
        .flatMap(new Func1&lt;Integer, Observable&lt;String&gt;&gt;() {
            @Override
            public Observable&lt;String&gt; call(Integer integer) {
                return Observable.create(subscriber -&gt; {
                    subscriber.onNext(integer*10+&quot;&quot;);
                    subscriber.onNext(integer*100+&quot;&quot;);
                    subscriber.onCompleted();
                });
            }
        })
.subscribe(o -&gt; Log.d(&quot;JG&quot;,o)) //20,200,30,300,50,500
</code></pre><p>flatMapIterable： 和flatMap的作用一样，只不过生成的是Iterable而不是Observable。</p>
<pre><code>    Observable.just(2,3,5)
        .flatMapIterable(new Func1&lt;Integer, Iterable&lt;String&gt;&gt;() {
            @Override
            public Iterable&lt;String&gt; call(Integer integer) {
                return Arrays.asList(integer*10+&quot;&quot;,integer*100+&quot;&quot;);
            }
        }).subscribe(new Action1&lt;String&gt;() {
          @Override
          public void call(String s) {

          }
});
</code></pre><p>concatMap： 类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。<br>switchMap： 和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。</p>
<p>  Observable.create(new Observable.OnSubscribe<integer>() {</integer></p>
<pre><code>    @Override
    public void call(Subscriber&lt;? super Integer&gt; subscriber) {
        for(int i=1;i&lt;4;i++){
            subscriber.onNext(i);
            Utils.sleep(500,subscriber);//线程休眠500ms
        }

        subscriber.onCompleted();
    }
}).subscribeOn(Schedulers.newThread())
  .switchMap(new Func1&lt;Integer, Observable&lt;Integer&gt;&gt;() {
         @Override
       public Observable&lt;Integer&gt; call(Integer integer) {
               //每当接收到新的数据，之前的Observable将会被取消订阅
                return Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() {
                    @Override
                    public void call(Subscriber&lt;? super Integer&gt; subscriber) {
                        subscriber.onNext(integer*10);
                        Utils.sleep(500,subscriber);
                        subscriber.onNext(integer*100);
                        subscriber.onCompleted();
                    }
                }).subscribeOn(Schedulers.newThread());
            }
        })
        .subscribe(s -&gt; Log.d(&quot;JG&quot;,s.toString()));//10,20,30,300
</code></pre><p>scan： 与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值。</p>
<p>  Observable.just(2,3,5)<br>            .scan(new Func2<integer, integer,="" integer="">() {<br>                @Override<br>                public Integer call(Integer sum, Integer item) {<br>                    return sum+item;<br>                }<br>            })<br>    .subscribe(integer -&gt; Log.d(“JG”,integer.toString())) //2,5,10</integer,></p>
<p>groupBy： 将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据。</p>
<p>   Observable.just(2,3,5,6)<br>            .groupBy(new Func1<integer, string="">() {<br>                @Override<br>                public String call(Integer integer) {//分组<br>                    return integer%2==0?”偶数”:”奇数”;<br>                }<br>            })<br>    .subscribe(new Action1<groupedobservable<string, integer="">&gt;() {<br>        @Override<br>        public void call(GroupedObservable<string, integer=""> o) {</string,></groupedobservable<string,></integer,></p>
<pre><code>        o.subscribe(new Action1&lt;Integer&gt;() {
            @Override
            public void call(Integer integer) {
                Log.d(&quot;JG&quot;,o.getKey()+&quot;:&quot;+integer.toString()); //偶数：2，奇数：3，...
            }
        });
    }
})
</code></pre><p>buffer： 它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个</p>
<pre><code>Observable.just(2,3,5,6)
        .buffer(3)
        .subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {
            @Override
            public void call(List&lt;Integer&gt; integers) {

            }
        })
</code></pre><p>window： 定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。</p>
<p>   Observable.just(2,3,5,6)<br>            .window(3)<br>            .subscribe(new Action1<observable<integer>&gt;() {<br>                @Override<br>                public void call(Observable<integer> integerObservable) {<br>                    integerObservable.subscribe(new Action1<integer>() {<br>                        @Override<br>                        public void call(Integer integer) {</integer></integer></observable<integer></p>
<pre><code>            }
        });
    }
})
</code></pre><p>##错误处理/重试机制</p>
<p>onErrorResumeNext： 当原始Observable在遇到错误时，使用备用Observable。。</p>
<p>  Observable.just(1,”2”,3)<br>    .cast(Integer.class)<br>    .onErrorResumeNext(Observable.just(1,2,3))<br>    .subscribe(integer -&gt; Log.d(“JG”,integer.toString())) //1,2,3<br>    ;</p>
<p>onExceptionResumeNext： 当原始Observable在遇到异常时，使用备用的Observable。与onErrorResumeNext类似，区别在于onErrorResumeNext可以处理所有的错误，onExceptionResumeNext只能处理异常。<br>onErrorReturn： 当原始Observable在遇到错误时发射一个特定的数据。</p>
<p> Observable.just(1,”2”,3)<br>            .cast(Integer.class)<br>            .onErrorReturn(new Func1<throwable, integer="">() {<br>                @Override<br>                public Integer call(Throwable throwable) {<br>                    return 4;<br>                }<br>            }).subscribe(new Action1<integer>() {<br>        @Override<br>        public void call(Integer integer) {<br>            Log.d(“JG”,integer.toString());1,4<br>        }<br>    });</integer></throwable,></p>
<p>retry： 当原始Observable在遇到错误时进行重试。</p>
<pre><code>Observable.just(1,&quot;2&quot;,3)
.cast(Integer.class)
.retry(3)
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()),throwable -&gt; Log.d(&quot;JG&quot;,&quot;onError&quot;))
;//1,1,1,1,onError
</code></pre><p>retryWhen： 当原始Observable在遇到错误，将错误传递给另一个Observable来决定是否要重新订阅这个Observable,内部调用的是retry。</p>
<p>  Observable.just(1,”2”,3)<br>    .cast(Integer.class)<br>    .retryWhen(new Func1<observable<? extends="" throwable="">, Observable<long>&gt;() {<br>        @Override<br>        public Observable<long> call(Observable&lt;? extends Throwable&gt; observable) {<br>            return Observable.timer(1, TimeUnit.SECONDS);<br>        }<br>    })<br>    .subscribe(integer -&gt; Log.d(“JG”,integer.toString()),throwable -&gt; Log.d(“JG”,”onError”));<br>    //1,1</long></long></observable<?></p>
<h2 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h2><p>ConnectableObservable与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect()被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。<br>ConnectableObservable.connect()指示一个可连接的Observable开始发射数据.<br>Observable.publish()将一个Observable转换为一个可连接的Observable<br>Observable.replay()确保所有的订阅者看到相同的数据序列的ConnectableObservable，即使它们在Observable开始发射数据之后才订阅。<br>ConnectableObservable.refCount()让一个可连接的Observable表现得像一个普通的Observable。</p>
<pre><code>ConnectableObservable&lt;Integer&gt; co= Observable.just(1,2,3)
         .publish();

 co .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()) );
 co.connect();//此时开始发射数据
</code></pre><h2 id="阻塞操作"><a href="#阻塞操作" class="headerlink" title="阻塞操作"></a>阻塞操作</h2><p>BlockingObservable是一个阻塞的Observable。普通的Observable 转换为 BlockingObservable，可以使用 Observable.toBlocking( )方法或者BlockingObservable.from( )方法。内部通过CountDownLatch实现了阻塞操作。</p>
<p>以下的操作符可以用于BlockingObservable，如果是普通的Observable，务必使用Observable.toBlocking()转为阻塞Observable后使用，否则达不到预期的效果。</p>
<p>forEach： 对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。</p>
<p>Observable.just(2,3).observeOn(Schedulers.newThread()).toBlocking()<br>          .forEach(integer -&gt; {<br>              Log.d(“JG”,integer.toString()+” “+Thread.currentThread().getName());<br>              Utils.sleep(500);<br>          });</p>
<p>Log.d(“JG”,Thread.currentThread().getName());<br>    // 2 RxNewThreadScheduler-1<br>    // 3 RxNewThreadScheduler-1<br>    // main</p>
<p>first/firstOrDefault/last/lastOrDefault：这几个操作符之前有介绍过。也可以用于阻塞操作。<br>single/singleOrDefault：如果Observable终止时只发射了一个值，返回那个值，否则抛出异常或者发射默认值。<br>mostRecent：返回一个总是返回Observable最近发射的数据的Iterable。<br>next： 返回一个Iterable，会阻塞直到Observable发射了第二个值，然后返回那个值。<br>latest： 返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值<br>toFuture： 将Observable转换为一个Future<br>toIterable：将一个发射数据序列的Observable转换为一个Iterable。<br>getIterator：将一个发射数据序列的Observable转换为一个Iterator<br>工具集</p>
<p>materialize： 将Observable转换成一个通知列表。</p>
<p> Observable.just(1,2,3)<br>           .materialize()<br>           .subscribe(new Action1<notification<integer>&gt;() {<br>               @Override<br>               public void call(Notification<integer> notification) {<br>                   Log.d(“JG”,notification.getKind()+” “+notification.getValue());<br>                   //OnNext 1<br>                   //OnNext 2<br>                   //OnNext 3<br>                   //OnCompleted null<br>               }<br>           });</integer></notification<integer></p>
<p>dematerialize： 与上面的作用相反，将通知逆转回一个Observable。<br>timestamp： 给Observable发射的每个数据项添加一个时间戳。</p>
<p>  Observable.just(1,2,3)<br>           .timestamp()<br>           .subscribe(new Action1<timestamped<integer>&gt;() {<br>               @Override<br>               public void call(Timestamped<integer> timestamped) {<br>                   Log.d(“JG”,timestamped.getTimestampMillis()+” “+timestamped.getValue());<br>                   //1472627510548 1<br>                   //1472627510549 2<br>                   //1472627510549 3<br>               }<br>           });</integer></timestamped<integer></p>
<p>timeInterval：给Observable发射的两个数据项间添加一个时间差，实现在OperatorTimeInterval中<br><img src="http://static.zybuluo.com/maplejaw/6dbl77xvh2z02hxil00juave/image_1argc8a1n17a61t441s5p1gln8231g.png" alt="Markdown preferences pane"></p>
<p>serialize： 强制Observable按次序发射数据并且要求功能是完好的<br>cache： 缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者<br>observeOn： 指定观察者观察Observable的调度器<br>subscribeOn： 指定Observable执行任务的调度器<br>doOnEach： 注册一个动作，对Observable发射的每个数据项使用</p>
<p>  Observable.just(2,3)<br>            .doOnEach(new Action1<notification<? super="" integer="">&gt;() {<br>                @Override<br>                public void call(Notification&lt;? super Integer&gt; notification) {<br>                    Log.d(“JG”,”–doOnEach–”+notification.toString());<br>                }<br>            })<br>            .subscribe(integer -&gt; Log.d(“JG”,integer.toString()));<br>//结果为：<br> // –doOnEach–[rx.Notification@133c40b0 OnNext 2]<br>// 2<br> // –doOnEach–[rx.Notification@133c40b0 OnNext 3]<br>// 3<br>// –doOnEach–[rx.Notification@df4db0e OnCompleted]</notification<?></p>
<p>doOnCompleted： 注册一个动作，对正常完成的Observable使用</p>
<p>doOnError： 注册一个动作，对发生错误的Observable使用<br>doOnTerminate：注册一个动作，对完成的Observable使用，无论是否发生错误</p>
<p>  Observable.just(2,3)<br>            .doOnTerminate(new Action0() {<br>                @Override<br>                public void call() {<br>                    Log.d(“JG”,”–doOnTerminate–”);<br>                }<br>            })<br>            .subscribe(integer -&gt; Log.d(“JG”,integer.toString()));<br>// 2 , 3 , –doOnTerminate–</p>
<p>doOnSubscribe： 注册一个动作，在观察者订阅时使用。内部由OperatorDoOnSubscribe实现，<img src="http://static.zybuluo.com/maplejaw/9w3o5vxc0lzznbrpn4vwa78w/image_1argbe0o1atfqtbrj51gu0jho9.png" alt="Markdown preferences pane"><br>doOnUnsubscribe： 注册一个动作，在观察者取消订阅时使用。内部由OperatorDoOnUnsubscribe实现，在call中加入一个解绑动作。<br><img src="http://static.zybuluo.com/maplejaw/791vkq1lxpl2etqaql85a6e8/image_1argbhutoi1a1b6a18s9il6npvm.png" alt="Markdown preferences pane"><br>finallyDo/doAfterTerminate： 注册一个动作，在Observable完成时使用</p>
<p>Observable.just(2,3)<br>            .doAfterTerminate(new Action0() {<br>                @Override<br>                public void call() {<br>                    Log.d(“JG”,”–doAfterTerminate–”);<br>                }<br>            })<br>            .subscribe(integer -&gt; Log.d(“JG”,integer.toString()));<br>//2,3,  –doAfterTerminate– </p>
<p>delay： 延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。</p>
<p>delaySubscription： 延时处理订阅请求。实现在OnSubscribeDelaySubscription中<br><img src="http://static.zybuluo.com/maplejaw/xqw7fto75revvct4zu3d56a5/image_1argc0tbetbj1rkj1etf4fcb1p13.png" alt="Markdown preferences pane"></p>
<p>using： 创建一个只在Observable生命周期存在的资源，当Observable终止时这个资源会被自动释放。</p>
<p>  Observable.using(new Func0<file>() {//资源工厂<br>        @Override<br>        public File call() {</file></p>
<pre><code>        File file = new File(getCacheDir(), &quot;a.txt&quot;);
        if(!file.exists()){
            try {
                Log.d(&quot;JG&quot;,&quot;--create--&quot;);
                file.createNewFile();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return file;
    }
}, new Func1&lt;File, Observable&lt;String&gt;&gt;() { //Observable
    @Override
    public Observable&lt;String&gt; call(File file) {
        return Observable.just(file.exists() ? &quot;exist&quot; : &quot;no exist&quot;);
    }
}, new Action1&lt;File&gt;() {//释放资源动作
    @Override
    public void call(File file) {
        if(file!=null&amp;&amp;file.exists()){
            Log.d(&quot;JG&quot;,&quot;--delete--&quot;);
            file.delete();
        }
    }
})
.subscribe(s -&gt; Log.d(&quot;JG&quot;,s))
;
</code></pre><p> //–create–<br> //exist<br> //–delete–</p>
<p>single/singleOrDefault： 强制返回单个数据，否则抛出异常或默认数据。<br>最后</p>
<p>关于RxJava标准库的操作符已经介绍完毕，纯粹当个备忘录。如有错误之处，欢迎指出。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/02/06/Rxjava操作符大全/" data-id="ciyu3ag9d00008igy20mkmvcs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2017/02/06/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/02/06/Rxjava操作符大全/">Rxjava操作符大全</a>
          </li>
        
          <li>
            <a href="/2017/02/06/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>
<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Efforts can only pass,hard to be excellent.">
<meta property="og:type" content="website">
<meta property="og:title" content="fastabler">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="fastabler">
<meta property="og:description" content="Efforts can only pass,hard to be excellent.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="fastabler">
<meta name="twitter:description" content="Efforts can only pass,hard to be excellent.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> fastabler </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ad1350e91810844821a7ad3e1f8ac561";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">fastabler</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">黄金龙</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/08/属性动画的使用原理/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2542991507,3032577261&fm=116&gp=0.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="fastabler">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="fastabler" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/08/属性动画的使用原理/" itemprop="url">
                  属性动画的使用原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-08T10:38:47+08:00">
                2017-02-08
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/08/属性动画的使用原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/08/属性动画的使用原理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>属性动画是API 11新加入的特性，和View动画不同，它对作用对象进行了扩展，属性动画可以对任何对象做动画，甚至还可以没有对象。除了作用对象进行了扩展以外，属性动画的效果也得到了加强，属性动画中有ValueAnimator（对值进行动画）、ObjectAnimator（对对象进行动画）、AnimatorSet（动画集合）等概念，通过他们可以实现绚丽的动画效果。</p>
<h2 id="使用属性动画"><a href="#使用属性动画" class="headerlink" title="使用属性动画"></a>使用属性动画</h2><p>属性动画可以对任意的对象属性进行动画而不仅仅是View，<strong>动画默认的时间为300ms</strong>，默认帧率为10ms／帧。其可以达到的效果是在一个时间间隔内完成对象从一个属性值到另一个属性值到改变。因此属性动画几乎无所不能。因为现在android版本都在4.0以上，所以我们不用考虑API 11以下手机。</p>
<ul>
<li>例如我们想改变一个对象的translationY的属性，让其沿着Y轴向上平移一段距离：它的高度。该动画在默认时间内完成，动画的完成时间是可以定义的。想要更灵活的效果我们还可以定义插值器和估值算法，但是一般我们不需要自定义，系统已经预置了一些，能够满足常用动画</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator.ofFloat(myObject, &quot;translationY&quot;, -myObject.getHeight()).start();</div></pre></td></tr></table></figure>
<ul>
<li>改变一个对象的背景色属性，典型的情形是改变View的背景色，下面的动画可以让View在3s内实现从0xFFFF8080到0xFF8080FF的渐变，动画会无限循环且会有反转的效果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ValueAnimator colorAnim = ObjectAnimator.ofInt(this, &quot;backgroundColor&quot;,0xFFFF8080, 0xFF8080FF);</div><div class="line">colorAnim.setDuration(3000);</div><div class="line">colorAnim.setEvaluator(new ArgbEvaluator());</div><div class="line">colorAnim.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">colorAnim.setRepeatMode(ValueAnimator.REVERSE);</div><div class="line">colorAnim.start();</div></pre></td></tr></table></figure>
<ul>
<li>动画集合，5s内对View的旋转、平移、缩放和透明度都进行了改变</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">AnimatorSet set = new AnimatorSet();</div><div class="line">set.playTogether(ObjectAnimator.ofFloat(myView, &quot;rotationX&quot;, 0, 360),</div><div class="line">	ObjectAnimator.ofFloat(myView, &quot;rotationY&quot;, 0, 180),</div><div class="line">	ObjectAnimator.ofFloat(myView, &quot;rotation&quot;, 0, -90),</div><div class="line">	ObjectAnimator.ofFloat(myView, &quot;translationX&quot;, 0, 90),</div><div class="line">	ObjectAnimator.ofFloat(myView, &quot;translationY&quot;, 0, 90),</div><div class="line">	ObjectAnimator.ofFloat(myView, &quot;scaleX&quot;, 1, 1.5f),</div><div class="line">	ObjectAnimator.ofFloat(myView, &quot;scaleX&quot;, 1, 0.5f),</div><div class="line">	ObjectAnimator.ofFloat(myView, &quot;alpha&quot;, 1, 0.25, 1),);</div><div class="line">set.setDuration(5 * 1000).start();</div></pre></td></tr></table></figure>
<p>属性动画在XML定义就不在多讲，因为它不如直接在代码中写起来方便，当然如果多个对象使用同一个动画，写在XML里面更好。</p>
<h2 id="插值器和估值器"><a href="#插值器和估值器" class="headerlink" title="插值器和估值器"></a>插值器和估值器</h2><h3 id="插值器"><a href="#插值器" class="headerlink" title="插值器"></a>插值器</h3><p>插值器只是一个概念，系统中与之相关的类叫做 TimeInterpolator ，其只是一个接口，准确来说叫做“时间插值器”。该接口的注释为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A time interpolator defines the rate of change of an animation. This allows animations to have non-linear motion, such as acceleration and deceleration.</div></pre></td></tr></table></figure>
<p>意思是：该时间插值器定义了动画的变化率，允许动画做非线性的运动，比如加速、减速。</p>
<p>这样，插值器的主要作用我们就明白了。接下来，看看这个接口的代码，该接口只有一个接口方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param input A value between 0 and 1.0 indicating our current point</div><div class="line"> *        in the animation where 0 represents the start and 1.0 represents</div><div class="line"> *        the end</div><div class="line"> * @return The interpolation value. This value can be more than 1.0 for</div><div class="line"> *         interpolators which overshoot their targets, or less than 0 for</div><div class="line"> *         interpolators that undershoot their targets.</div><div class="line"> */</div><div class="line">float getInterpolation(float input);</div></pre></td></tr></table></figure></p>
<p>不管是系统内置的插值器，还是我们自定义插值器，只需要实现接口并重写该方法，就可以起到插值器的作用。</p>
<p>该方法的作用是什么呢？上图保留了源码中对方法的注释，我就不直译了，说下大概的意思：</p>
<p>方法参数 input 接收 0 和 1.0 之间的值表示动画的当前进度，是线性变化的，其中0表示开始，1.0表示结束；<br>返回值表示对 input 进行插值之后的值，我们就是在这儿做“手脚”，让返回值不再是线性的，就完成自己定义动画的变化率了。<br>TimeInterpolator中文翻译为时间插值器，它的作用是根据时间流逝的百分比来计算出当前属性值改变的百分比，系统预置的有LinearInterpolator（线性插值器：匀速动画）、AccelerateDecelerateInterpolator（加速减速插值器：动画两头慢中间快）和DecelerateInterpolator（减速插值器：动画越来越慢）等。</p>
<h3 id="估值器"><a href="#估值器" class="headerlink" title="估值器"></a>估值器</h3><p>TypeEvalutor等中文翻译为类型估值算法，也叫作估值器。估值器的是用来决定属性的计算方式，最终使用反射机制来改变属性变化。它的作用是根据当前属性改变的百分比来计算改变后的属性值。系统预置的有IntEvalutor（针对整形属性）、FloatEvalutor（针对浮点型属性）和ArgbEvalutor（针对color属性）。</p>
<h2 id="属性动画的监听"><a href="#属性动画的监听" class="headerlink" title="属性动画的监听"></a>属性动画的监听</h2><p>属性动画提供了监听器用于监听动画的播放过程，主要有如下两个接口AnimatorUpdateListener和AnimatorListener。<br>AnimatorListener的定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/**	</div><div class="line">    * &lt;p&gt;An animation listener receives notifications from an animation.</div><div class="line">    * Notifications indicate animation related events, such as the end or the</div><div class="line">    * repetition of the animation.&lt;/p&gt;</div><div class="line">    */</div><div class="line">   public static interface AnimatorListener &#123;</div><div class="line">       /**</div><div class="line">        * &lt;p&gt;Notifies the start of the animation.&lt;/p&gt;</div><div class="line">        *</div><div class="line">        * @param animation The started animation.</div><div class="line">        */</div><div class="line">       void onAnimationStart(Animator animation);</div><div class="line"></div><div class="line">       /**</div><div class="line">        * &lt;p&gt;Notifies the end of the animation. This callback is not invoked</div><div class="line">        * for animations with repeat count set to INFINITE.&lt;/p&gt;</div><div class="line">        *</div><div class="line">        * @param animation The animation which reached its end.</div><div class="line">        */</div><div class="line">       void onAnimationEnd(Animator animation);</div><div class="line"></div><div class="line">       /**</div><div class="line">        * &lt;p&gt;Notifies the cancellation of the animation. This callback is not invoked</div><div class="line">        * for animations with repeat count set to INFINITE.&lt;/p&gt;</div><div class="line">        *</div><div class="line">        * @param animation The animation which was canceled.</div><div class="line">        */</div><div class="line">       void onAnimationCancel(Animator animation);</div><div class="line"></div><div class="line">       /**</div><div class="line">        * &lt;p&gt;Notifies the repetition of the animation.&lt;/p&gt;</div><div class="line">        *</div><div class="line">        * @param animation The animation which was repeated.</div><div class="line">        */</div><div class="line">       void onAnimationRepeat(Animator animation);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>AnimatorUpdateListener的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Implementors of this interface can add themselves as update listeners</div><div class="line">     * to an &lt;code&gt;ValueAnimator&lt;/code&gt; instance to receive callbacks on every animation</div><div class="line">     * frame, after the current frame&apos;s values have been calculated for that</div><div class="line">     * &lt;code&gt;ValueAnimator&lt;/code&gt;.</div><div class="line">     */</div><div class="line">    public static interface AnimatorUpdateListener &#123;</div><div class="line">        /**</div><div class="line">         * &lt;p&gt;Notifies the occurrence of another frame of the animation.&lt;/p&gt;</div><div class="line">         *</div><div class="line">         * @param animation The animation which was repeated.</div><div class="line">         */</div><div class="line">        void onAnimationUpdate(ValueAnimator animation);</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="对任意属性做动画"><a href="#对任意属性做动画" class="headerlink" title="对任意属性做动画"></a>对任意属性做动画</h2><p>比如我们用属性动画对Button做宽度的增加，会首先想到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator.ofInt(mButton, &quot;width&quot;, 500).setDuration(5000).start();</div></pre></td></tr></table></figure>
<p>上述代码运行后会发现没有效果，其实没有效果是正常现象，因为如果随便传一个属性（例如width）轻则没有动画效果，重则程序直接crash。<br>下面分析属性动画的原理：<strong>属性动画要求动画的作用对象提供该属性的get和set方法，属性动画根据该属性的初始值和最终值，以动画的效果多次去调用set方法，每次传递给set方法等值都不一样，确切的来说是随着时间的推移，所传递的值越来越接近最终值</strong></p>
<ol>
<li>作用对象必须提供该属性的get和set方法</li>
<li>作用对象的set方法必须要能使UI效果改变，否则动画无效果</li>
</ol>
<p>那么为什么我们对Button的width属性做动画会没有效果呢？这是因为虽然Button内部提供了getWidth和setWidth方法，但是这个setWidth方法并不是改变视图的大小，它是TextView新添加的方法，View是没有setWidth这个方法的。由于Button继承TextView，所以Button有setWidth方法，来看一下setWidth和getWidth方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Makes the TextView exactly this many pixels wide.</div><div class="line">     * You could do the same thing by specifying this number in the</div><div class="line">     * LayoutParams.</div><div class="line">     *</div><div class="line">     * @see #setMaxWidth(int)</div><div class="line">     * @see #setMinWidth(int)</div><div class="line">     * @see #getMinWidth()</div><div class="line">     * @see #getMaxWidth()</div><div class="line">     *</div><div class="line">     * @attr ref android.R.styleable#TextView_width</div><div class="line">     */</div><div class="line">    @android.view.RemotableViewMethod</div><div class="line">    public void setWidth(int pixels) &#123;</div><div class="line">        mMaxWidth = mMinWidth = pixels;</div><div class="line">        mMaxWidthMode = mMinWidthMode = PIXELS;</div><div class="line"></div><div class="line">        requestLayout();</div><div class="line">        invalidate();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * Return the width of the your view.</div><div class="line">     *</div><div class="line">     * @return The width of your view, in pixels.</div><div class="line">     */</div><div class="line">    @ViewDebug.ExportedProperty(category = &quot;layout&quot;)</div><div class="line">    public final int getWidth() &#123;</div><div class="line">        return mRight - mLeft;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从上述源码中可以看出，getWidth的确是获取View的宽度，而setWidth是TextView和其子类的专属方法，它的作用不是设置宽度，而是设置最大宽度和最小宽度的。具体来说在布局XML中android:layout_width对应宽度，android:width对应最大最小宽度。所以setWidth无法改变控件的宽度。<br>针对上述问题，官方告诉我们有三种解决方法</p>
<ul>
<li>给你的对象加上set和get方法，如果你有权限的话</li>
<li>用一个类来包装原始对象，间接为其提供set和get方法</li>
<li>采用ValueAnimator，监听动画的过程，自己实现属性的改变。</li>
</ul>
<p>针对以上解决方法，结合实际情况我们得出，Button设置宽度无法使用第一种方法，因为我们没有权限更改它的源码。所以我们可以采用第二种和第三种解决方法。</p>
<p>采用第二种解决方法，创建包裹类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * 改变宽度</div><div class="line">    */</div><div class="line">   private void changeWidth()&#123;</div><div class="line">       ViewWrapper wrapper = new ViewWrapper(mButton);</div><div class="line">       ObjectAnimator.ofInt(wrapper, &quot;width&quot;, 500).setDuration(5000).start();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   /**</div><div class="line">    * 用于包裹类</div><div class="line">    */</div><div class="line">   private static class ViewWrapper&#123;</div><div class="line">       private View mTarget;</div><div class="line"></div><div class="line">       public ViewWrapper(View target)&#123;</div><div class="line">           this.mTarget = target;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       public int getWidth()&#123;</div><div class="line">           return mTarget.getLayoutParams().width;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       public void setWidth(int width)&#123;</div><div class="line">           mTarget.getLayoutParams().width = width;</div><div class="line">           mTarget.requestLayout();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>采用第三种解决方法，利用ValueAnimator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    *</div><div class="line">    * @param target 要改变的目标View</div><div class="line">    * @param start 开始的宽度</div><div class="line">    * @param end   结束的宽度</div><div class="line">    */</div><div class="line">   private void performAnimte(final View target, final int start, final int end)&#123;</div><div class="line">       ValueAnimator valueAnimator = ValueAnimator.ofInt(1, 100);</div><div class="line">       valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">           private IntEvaluator mEvaluator = new IntEvaluator();</div><div class="line">           @Override</div><div class="line">           public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">               // 获取当前动画的进度</div><div class="line">               int currentValue = (int) animation.getAnimatedFraction();</div><div class="line">               // 获取当前进度占整个动画的比例</div><div class="line">               float fraction = animation.getAnimatedFraction();</div><div class="line">               // 直接调用整型估值器，通过比例计算出宽度，然后赋值</div><div class="line">               target.getLayoutParams().width = mEvaluator.evaluate(fraction, start, end);</div><div class="line">               target.requestLayout();</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       valueAnimator.setDuration(5000).start();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="属性动画的工作原理"><a href="#属性动画的工作原理" class="headerlink" title="属性动画的工作原理"></a>属性动画的工作原理</h2><p>属性动画要求动画作用的对象提供该属性的set方法，属性动画根据你传递的该属性的初始值和最终值，以动画的效果多次去调用set方法。每次传递给set方法的值都不一样，确切的来说是随着时间的推移，所传递的值越来越接近最终值。如果动画的时候没有传递初始值，那么还要提供get方法，因为系统要去获取属性的初始值。对于属性动画来说，其动画过程中所做的就是这么多。</p>
<h2 id="使用动画的注意事项"><a href="#使用动画的注意事项" class="headerlink" title="使用动画的注意事项"></a>使用动画的注意事项</h2><ol>
<li>内存泄漏：在属性动画中有一类无限循环的动画，这类动画需要在Activity退出时及时停止，否则将导致Activity无法释放从而造成内存泄漏，View动画并不存在这种现象。</li>
<li>兼容性问题：动画在3.0以下的系统上存在兼容性问题，现在android系统大部分都是4.0的</li>
<li>不要使用px：在进行动画的过程中，要尽量使用dp，使用px会导致在不同的设备上有不同的效果</li>
<li>硬件加速：使用动画的过程中建议开启硬件加速，这样会提高动画的流畅性。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/06/Rxjava操作符大全/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2542991507,3032577261&fm=116&gp=0.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="fastabler">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="fastabler" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/06/Rxjava操作符大全/" itemprop="url">
                  Rxjava操作符大全
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-06T18:19:52+08:00">
                2017-01-06
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/01/06/Rxjava操作符大全/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/06/Rxjava操作符大全/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="创建操作"><a href="#创建操作" class="headerlink" title="创建操作"></a>创建操作</h2><h3 id="以下操作符用于创建Observable。"><a href="#以下操作符用于创建Observable。" class="headerlink" title="以下操作符用于创建Observable。"></a>以下操作符用于创建Observable。</h3><h4 id="create：-使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe-call方法中检查订阅状态，以便及时停止发射数据或者运算。"><a href="#create：-使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe-call方法中检查订阅状态，以便及时停止发射数据或者运算。" class="headerlink" title="create： 使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe#call方法中检查订阅状态，以便及时停止发射数据或者运算。"></a>create： 使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe#call方法中检查订阅状态，以便及时停止发射数据或者运算。</h4><pre><code>Observable.create(new Observable.OnSubscribe&lt;String&gt;() {

    @Override
    public void call(Subscriber&lt;? super String&gt; subscriber) {

        subscriber.onNext(&quot;item1&quot;);
        subscriber.onNext(&quot;item2&quot;);
        subscriber.onCompleted();
    }
});
</code></pre><h4 id="from：-将一个Iterable-一个Future-或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。"><a href="#from：-将一个Iterable-一个Future-或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。" class="headerlink" title="from： 将一个Iterable, 一个Future, 或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。"></a>from： 将一个Iterable, 一个Future, 或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。</h4><p><img src="http://static.zybuluo.com/maplejaw/1a7gi8os6u4kgk7aahzmj1d0/image_1arcl6d0a1iej60e6ccp48qic9.png" alt="Markdown preferences pane"></p>
<pre><code>//Iterable
List&lt;String&gt; list=new ArrayList&lt;&gt;();
...
Observable.from(list)
        .subscribe(new Action1&lt;String&gt;() {
    @Override
    public void call(String s) {

    }
});

//Future
 Future&lt;String&gt; futrue= Executors.newSingleThreadExecutor().submit(new Callable&lt;String&gt;() {

    @Override
    public String call() throws Exception {
        Thread.sleep(1000);
        return &quot;maplejaw&quot;;
    }
});

Observable.from(futrue)
          .subscribe(new Action1&lt;String&gt;() {
    @Override
    public void call(String s) {

    }
});
</code></pre><h4 id="just：-将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。"><a href="#just：-将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。" class="headerlink" title="just： 将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。"></a>just： 将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。</h4><h4 id="empty：-创建一个什么都不做直接通知完成的Observable"><a href="#empty：-创建一个什么都不做直接通知完成的Observable" class="headerlink" title="empty： 创建一个什么都不做直接通知完成的Observable"></a>empty： 创建一个什么都不做直接通知完成的Observable</h4><h4 id="error：-创建一个什么都不做直接通知错误的Observable"><a href="#error：-创建一个什么都不做直接通知错误的Observable" class="headerlink" title="error： 创建一个什么都不做直接通知错误的Observable"></a>error： 创建一个什么都不做直接通知错误的Observable</h4><h4 id="never：-创建一个什么都不做的Observable"><a href="#never：-创建一个什么都不做的Observable" class="headerlink" title="never： 创建一个什么都不做的Observable"></a>never： 创建一个什么都不做的Observable</h4><pre><code>Observable observable1=Observable.empty();//直接调用onCompleted。
Observable observable2=Observable.error(new RuntimeException());//直接调用onError。这里可以自定义异常
Observable observable3=Observable.never();//啥都不做
</code></pre><h4 id="timer：-创建一个在给定的延时之后发射数据项为0的Observable-内部通过OnSubscribeTimerOnce工作"><a href="#timer：-创建一个在给定的延时之后发射数据项为0的Observable-内部通过OnSubscribeTimerOnce工作" class="headerlink" title="timer： 创建一个在给定的延时之后发射数据项为0的Observable,内部通过OnSubscribeTimerOnce工作"></a>timer： 创建一个在给定的延时之后发射数据项为0的Observable<long>,内部通过OnSubscribeTimerOnce工作</long></h4><pre><code>Observable.timer(1000,TimeUnit.MILLISECONDS)
        .subscribe(new Action1&lt;Long&gt;() {
            @Override
            public void call(Long aLong) {
                Log.d(&quot;JG&quot;,aLong.toString()); // 0
            }
        });
</code></pre><h4 id="interval：-创建一个按照给定的时间间隔发射从0开始的整数序列的Observable，内部通过OnSubscribeTimerPeriodically工作。"><a href="#interval：-创建一个按照给定的时间间隔发射从0开始的整数序列的Observable，内部通过OnSubscribeTimerPeriodically工作。" class="headerlink" title="interval： 创建一个按照给定的时间间隔发射从0开始的整数序列的Observable，内部通过OnSubscribeTimerPeriodically工作。"></a>interval： 创建一个按照给定的时间间隔发射从0开始的整数序列的Observable<long>，内部通过OnSubscribeTimerPeriodically工作。</long></h4><pre><code>Observable.interval(1, TimeUnit.SECONDS)
        .subscribe(new Action1&lt;Long&gt;() {
            @Override
            public void call(Long aLong) {
                 //每隔1秒发送数据项，从0开始计数
                 //0,1,2,3....
            }
        });
</code></pre><h4 id="range：-创建一个发射指定范围的整数序列的Observable"><a href="#range：-创建一个发射指定范围的整数序列的Observable" class="headerlink" title="range： 创建一个发射指定范围的整数序列的Observable"></a>range： 创建一个发射指定范围的整数序列的Observable<integer></integer></h4><pre><code>Observable.range(2,5).subscribe(new Action1&lt;Integer&gt;() {
    @Override
    public void call(Integer integer) {
        Log.d(&quot;JG&quot;,integer.toString());// 2,3,4,5,6 从2开始发射5个数据
    }
});
</code></pre><h5 id="defer：-只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。"><a href="#defer：-只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。" class="headerlink" title="defer： 只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。"></a>defer： 只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。</h5><pre><code>Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() {
    @Override
    public Observable&lt;String&gt; call() {
        return Observable.just(&quot;hello&quot;);
    }
}).subscribe(new Action1&lt;String&gt;() {
    @Override
    public void call(String s) {
        Log.d(&quot;JG&quot;,s);
    }
});
</code></pre><h2 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h2><p>以下操作符用于组合多个Observable。</p>
<p>注意，为了使结构更加清晰以及缩小代码量，之后的例子部分地方将会使用Lambda表达式书写，如果你对Lambda表达式不太熟悉的话，可以阅读JAVA8 Lambda表达式完全解析这篇文章。</p>
<h4 id="concat：-按顺序连接多个Observables。需要注意的是Observable-concat-a-b-等价于a-concatWith-b-。"><a href="#concat：-按顺序连接多个Observables。需要注意的是Observable-concat-a-b-等价于a-concatWith-b-。" class="headerlink" title="concat： 按顺序连接多个Observables。需要注意的是Observable.concat(a,b)等价于a.concatWith(b)。"></a>concat： 按顺序连接多个Observables。需要注意的是Observable.concat(a,b)等价于a.concatWith(b)。</h4><pre><code>Observable&lt;Integer&gt; observable1=Observable.just(1,2,3,4);
Observable&lt;Integer&gt;  observable2=Observable.just(4,5,6);

Observable.concat(observable1,observable2)
        .subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString()));//1,2,3,4,4,5,6
</code></pre><h4 id="startWith：-在数据序列的开头增加一项数据。startWith的内部也是调用了concat"><a href="#startWith：-在数据序列的开头增加一项数据。startWith的内部也是调用了concat" class="headerlink" title="startWith： 在数据序列的开头增加一项数据。startWith的内部也是调用了concat"></a>startWith： 在数据序列的开头增加一项数据。startWith的内部也是调用了concat</h4><pre><code>Observable.just(1,2,3,4,5)
        .startWith(6,7,8)
.subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString()));//6,7,8,1,2,3,4,5
</code></pre><h4 id="merge：-将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。"><a href="#merge：-将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。" class="headerlink" title="merge： 将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。"></a>merge： 将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。</h4><h4 id="zip：-使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过OperatorZip进行压合。"><a href="#zip：-使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过OperatorZip进行压合。" class="headerlink" title="zip： 使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过OperatorZip进行压合。"></a>zip： 使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过OperatorZip进行压合。</h4><p>Observable<integer>  observable1=Observable.just(1,2,3,4);<br>Observable<integer>  observable2=Observable.just(4,5,6);</integer></integer></p>
<pre><code>Observable.zip(observable1, observable2, new Func2&lt;Integer, Integer, String&gt;() {
    @Override
    public String call(Integer item1, Integer item2) {
        return item1+&quot;and&quot;+item2;
    }
})
.subscribe(item-&gt;Log.d(&quot;JG&quot;,item)); //1and4,2and5,3and6
</code></pre><h4 id="combineLatest：-当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable最近的数据压合。具体请看下面流程图。"><a href="#combineLatest：-当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable最近的数据压合。具体请看下面流程图。" class="headerlink" title="combineLatest： 当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable最近的数据压合。具体请看下面流程图。"></a>combineLatest： 当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable最近的数据压合。具体请看下面流程图。</h4><p>zip工作流程<br><img src="http://static.zybuluo.com/maplejaw/bu67z13p279yu074arzslsyd/image_1ard6160913ui3r6orodc41pntm.png" alt="Markdown preferences pane"></p>
<p>combineLatest工作流程<br><img src="http://static.zybuluo.com/maplejaw/tuo7jn6ijtzsa1c3ak77umtu/image_1ard609fsi3p9n7160iq0r1rqe9.png" alt="Markdown preferences pane"></p>
<h2 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h2><h4 id="filter：-过滤数据。内部通过OnSubscribeFilter过滤数据。"><a href="#filter：-过滤数据。内部通过OnSubscribeFilter过滤数据。" class="headerlink" title="filter： 过滤数据。内部通过OnSubscribeFilter过滤数据。"></a>filter： 过滤数据。内部通过OnSubscribeFilter过滤数据。</h4><pre><code>Observable.just(3,4,5,6)
        .filter(new Func1&lt;Integer, Boolean&gt;() {
            @Override
            public Boolean call(Integer integer) {
                return integer&gt;4;
            }
        })
.subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString())); //5,6 
</code></pre><h4 id="ofType：-过滤指定类型的数据，与filter类似，"><a href="#ofType：-过滤指定类型的数据，与filter类似，" class="headerlink" title="ofType： 过滤指定类型的数据，与filter类似，"></a>ofType： 过滤指定类型的数据，与filter类似，</h4><pre><code>Observable.just(1,2,&quot;3&quot;)
        .ofType(Integer.class)
        .subscribe(item -&gt; Log.d(&quot;JG&quot;,item.toString()));
</code></pre><h4 id="take：-只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。"><a href="#take：-只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。" class="headerlink" title="take： 只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。"></a>take： 只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。</h4><pre><code>Observable.just(3,4,5,6)
        .take(3)//发射前三个数据项
        .take(100, TimeUnit.MILLISECONDS)//发射100ms内的数据
</code></pre><h4 id="takeLast：-只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。"><a href="#takeLast：-只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。" class="headerlink" title="takeLast： 只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。"></a>takeLast： 只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。</h4><pre><code>Observable.just(3,4,5,6)
        .takeLast(3)
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));//4,5,6
</code></pre><h4 id="takeFirst：提取满足条件的第一项。内部实现源码如下："><a href="#takeFirst：提取满足条件的第一项。内部实现源码如下：" class="headerlink" title="takeFirst：提取满足条件的第一项。内部实现源码如下："></a>takeFirst：提取满足条件的第一项。内部实现源码如下：</h4><pre><code>public final Observable&lt;T&gt; takeFirst(Func1&lt;? super T, Boolean&gt; predicate) {
  return filter(predicate).take(1); //先过滤，后提取
}
</code></pre><h4 id="first-firstOrDefault：只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。"><a href="#first-firstOrDefault：只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。" class="headerlink" title="first/firstOrDefault：只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。"></a>first/firstOrDefault：只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。</h4><pre><code>Observable.just(3,4,5,6)
        .first()
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));//3

Observable.just(3,4,5,6)
           .first(new Func1&lt;Integer, Boolean&gt;() {
               @Override
               public Boolean call(Integer integer) {
                   return integer&gt;3;
               }
           }) .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));//4
</code></pre><h4 id="last-lastOrDefault：只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。"><a href="#last-lastOrDefault：只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。" class="headerlink" title="last/lastOrDefault：只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。"></a>last/lastOrDefault：只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。</h4><h4 id="skip：跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。"><a href="#skip：跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。" class="headerlink" title="skip：跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。"></a>skip：跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。</h4><pre><code>Observable.just(3,4,5,6)
           .skip(1)
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));//4,5,6
</code></pre><h4 id="skipLast：跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。"><a href="#skipLast：跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。" class="headerlink" title="skipLast：跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。"></a>skipLast：跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。</h4><h4 id="elementAt-elementAtOrDefault：发射某一项数据，如果超过了范围可以的指定默认值。内部通过OperatorElementAt过滤。"><a href="#elementAt-elementAtOrDefault：发射某一项数据，如果超过了范围可以的指定默认值。内部通过OperatorElementAt过滤。" class="headerlink" title="elementAt/elementAtOrDefault：发射某一项数据，如果超过了范围可以的指定默认值。内部通过OperatorElementAt过滤。"></a>elementAt/elementAtOrDefault：发射某一项数据，如果超过了范围可以的指定默认值。内部通过OperatorElementAt过滤。</h4><pre><code>Observable.just(3,4,5,6)
         .elementAt(2)
.subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString())); //5
</code></pre><h4 id="ignoreElements：丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。"><a href="#ignoreElements：丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。" class="headerlink" title="ignoreElements：丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。"></a>ignoreElements：丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。</h4><h4 id="distinct：过滤重复数据，内部通过OperatorDistinct实现。"><a href="#distinct：过滤重复数据，内部通过OperatorDistinct实现。" class="headerlink" title="distinct：过滤重复数据，内部通过OperatorDistinct实现。"></a>distinct：过滤重复数据，内部通过OperatorDistinct实现。</h4><pre><code>Observable.just(3,4,5,6,3,3,4,9)
   .distinct()
  .subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString())); //3,4,5,6,9
</code></pre><h4 id="distinctUntilChanged：过滤掉连续重复的数据。内部通过OperatorDistinctUntilChanged实现"><a href="#distinctUntilChanged：过滤掉连续重复的数据。内部通过OperatorDistinctUntilChanged实现" class="headerlink" title="distinctUntilChanged：过滤掉连续重复的数据。内部通过OperatorDistinctUntilChanged实现"></a>distinctUntilChanged：过滤掉连续重复的数据。内部通过OperatorDistinctUntilChanged实现</h4><pre><code>Observable.just(3,4,5,6,3,3,4,9)
   .distinctUntilChanged()
  .subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString())); //3,4,5,6,3,4,9
</code></pre><h4 id="throttleFirst：定期发射Observable发射的第一项数据。内部通过OperatorThrottleFirst实现。"><a href="#throttleFirst：定期发射Observable发射的第一项数据。内部通过OperatorThrottleFirst实现。" class="headerlink" title="throttleFirst：定期发射Observable发射的第一项数据。内部通过OperatorThrottleFirst实现。"></a>throttleFirst：定期发射Observable发射的第一项数据。内部通过OperatorThrottleFirst实现。</h4><pre><code>Observable.create(subscriber -&gt; {
    subscriber.onNext(1);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(2);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }

    subscriber.onNext(3);
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(4);
    subscriber.onNext(5);
    subscriber.onCompleted();

}).throttleFirst(999, TimeUnit.MILLISECONDS)
        .subscribe(item-&gt; Log.d(&quot;JG&quot;,item.toString())); //结果为1,3,4
</code></pre><h4 id="throttleWithTimeout-debounce：发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据-直到指定时间内都没有新数据发射时"><a href="#throttleWithTimeout-debounce：发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据-直到指定时间内都没有新数据发射时" class="headerlink" title="throttleWithTimeout/debounce：发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据,直到指定时间内都没有新数据发射时"></a>throttleWithTimeout/debounce：发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据,直到指定时间内都没有新数据发射时</h4><p>才进行发射</p>
<pre><code>Observable.create(subscriber -&gt; {
    subscriber.onNext(1);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(2);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }

    subscriber.onNext(3);
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(4);
    subscriber.onNext(5);
    subscriber.onCompleted();

}).debounce(999, TimeUnit.MILLISECONDS)//或者为throttleWithTimeout(1000, TimeUnit.MILLISECONDS)
        .subscribe(item-&gt; Log.d(&quot;JG&quot;,item.toString())); //结果为3,5
</code></pre><h4 id="sample-throttleLast：定期发射Observable最近的数据。内部通过OperatorSampleWithTime实现。"><a href="#sample-throttleLast：定期发射Observable最近的数据。内部通过OperatorSampleWithTime实现。" class="headerlink" title="sample/throttleLast：定期发射Observable最近的数据。内部通过OperatorSampleWithTime实现。"></a>sample/throttleLast：定期发射Observable最近的数据。内部通过OperatorSampleWithTime实现。</h4><pre><code>Observable.create(subscriber -&gt; {
    subscriber.onNext(1);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(2);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }

    subscriber.onNext(3);
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(4);
    subscriber.onNext(5);
    subscriber.onCompleted();

}).sample(999, TimeUnit.MILLISECONDS)//或者为throttleLast(1000, TimeUnit.MILLISECONDS)
        .subscribe(item-&gt; Log.d(&quot;JG&quot;,item.toString())); //结果为2,3,5
</code></pre><h4 id="timeout：-如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。"><a href="#timeout：-如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。" class="headerlink" title="timeout： 如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。"></a>timeout： 如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。</h4><pre><code>Observable.create(( subscriber) -&gt; {
    subscriber.onNext(1);
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(2);

    subscriber.onCompleted();

}).timeout(999, TimeUnit.MILLISECONDS,Observable.just(99,100))//如果不指定备用Observable将会抛出异常
        .subscribe(item-&gt; Log.d(&quot;JG&quot;,item.toString()),error-&gt;Log.d(&quot;JG&quot;,&quot;onError&quot;)); //结果为1,99,100  如果不指定备用Observable结果为1,onError
}
</code></pre><h3 id="条件-布尔操作"><a href="#条件-布尔操作" class="headerlink" title="条件/布尔操作"></a>条件/布尔操作</h3><h4 id="all：-判断所有的数据项是否满足某个条件，内部通过OperatorAll实现。"><a href="#all：-判断所有的数据项是否满足某个条件，内部通过OperatorAll实现。" class="headerlink" title="all： 判断所有的数据项是否满足某个条件，内部通过OperatorAll实现。"></a>all： 判断所有的数据项是否满足某个条件，内部通过OperatorAll实现。</h4><pre><code>Observable.just(2,3,4,5)
        .all(new Func1&lt;Integer, Boolean&gt;() {
            @Override
            public Boolean call(Integer integer) {
                return integer&gt;3;
            }
        })
.subscribe(new Action1&lt;Boolean&gt;() {
    @Override
    public void call(Boolean aBoolean) {
        Log.d(&quot;JG&quot;,aBoolean.toString()); //false
    }
})
;
</code></pre><h4 id="exists：-判断是否存在数据项满足某个条件。内部通过OperatorAny实现。"><a href="#exists：-判断是否存在数据项满足某个条件。内部通过OperatorAny实现。" class="headerlink" title="exists： 判断是否存在数据项满足某个条件。内部通过OperatorAny实现。"></a>exists： 判断是否存在数据项满足某个条件。内部通过OperatorAny实现。</h4><pre><code>Observable.just(2,3,4,5)
        .exists(integer -&gt; integer&gt;3)
        .subscribe(aBoolean -&gt; Log.d(&quot;JG&quot;,aBoolean.toString())); //true
</code></pre><h4 id="contains：-判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是exists"><a href="#contains：-判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是exists" class="headerlink" title="contains： 判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是exists"></a>contains： 判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是exists</h4><pre><code>Observable.just(2,3,4,5)
        .contains(3)
        .subscribe(aBoolean -&gt; Log.d(&quot;JG&quot;,aBoolean.toString())); //true
</code></pre><h4 id="sequenceEqual：-用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。"><a href="#sequenceEqual：-用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。" class="headerlink" title="sequenceEqual： 用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。"></a>sequenceEqual： 用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。</h4><pre><code>Observable.sequenceEqual(Observable.just(2,3,4,5),Observable.just(2,3,4,5))
        .subscribe(aBoolean -&gt; Log.d(&quot;JG&quot;,aBoolean.toString()));//true
</code></pre><h4 id="isEmpty：-用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。"><a href="#isEmpty：-用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。" class="headerlink" title="isEmpty： 用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。"></a>isEmpty： 用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。</h4><pre><code>Observable.just(3,4,5,6)
           .isEmpty()
          .subscribe(item -&gt; Log.d(&quot;JG&quot;,item.toString()));//false
</code></pre><p>amb： 给定多个Observable，只让第一个发射数据的Observable发射全部数据，其他Observable将会被忽略。</p>
<pre><code>Observable&lt;Integer&gt; observable1=Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() {
    @Override
    public void call(Subscriber&lt;? super Integer&gt; subscriber) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            subscriber.onError(e);
        }
        subscriber.onNext(1);
        subscriber.onNext(2);
        subscriber.onCompleted();
    }
}).subscribeOn(Schedulers.computation());

Observable&lt;Integer&gt; observable2=Observable.create(subscriber -&gt; {
    subscriber.onNext(3);
    subscriber.onNext(4);
    subscriber.onCompleted();
});

Observable.amb(observable1,observable2)
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString())); //3,4
</code></pre><h4 id="switchIfEmpty：-如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。"><a href="#switchIfEmpty：-如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。" class="headerlink" title="switchIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。"></a>switchIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。</h4><pre><code>Observable.empty()
        .switchIfEmpty(Observable.just(2,3,4))
.subscribe(o -&gt; Log.d(&quot;JG&quot;,o.toString())); //2,3,4
</code></pre><h4 id="defaultIfEmpty：-如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值-内部调用的switchIfEmpty。"><a href="#defaultIfEmpty：-如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值-内部调用的switchIfEmpty。" class="headerlink" title="defaultIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值,内部调用的switchIfEmpty。"></a>defaultIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值,内部调用的switchIfEmpty。</h4><h4 id="takeUntil：-当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据。"><a href="#takeUntil：-当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据。" class="headerlink" title="takeUntil： 当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据。"></a>takeUntil： 当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据。</h4><pre><code>Observable.just(2,3,4,5)
        .takeUntil(new Func1&lt;Integer, Boolean&gt;() {
            @Override
            public Boolean call(Integer integer) {
                return integer==4;
            }
        }).subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString())); //2,3,4
</code></pre><h4 id="takeWhile：-当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。"><a href="#takeWhile：-当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。" class="headerlink" title="takeWhile： 当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。"></a>takeWhile： 当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。</h4><pre><code>Observable.just(2,3,4,5)
        .takeWhile(new Func1&lt;Integer, Boolean&gt;() {
            @Override
            public Boolean call(Integer integer) {
                return integer==4;
            }
        })
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString())); //2,3
</code></pre><h4 id="skipUntil：-丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）"><a href="#skipUntil：-丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）" class="headerlink" title="skipUntil： 丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）"></a>skipUntil： 丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）</h4><h4 id="skipWhile：-丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）"><a href="#skipWhile：-丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）" class="headerlink" title="skipWhile： 丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）"></a>skipWhile： 丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）</h4><h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><h4 id="reduce：-对序列使用reduce-函数并发射最终的结果-内部使用OnSubscribeReduce实现。"><a href="#reduce：-对序列使用reduce-函数并发射最终的结果-内部使用OnSubscribeReduce实现。" class="headerlink" title="reduce： 对序列使用reduce()函数并发射最终的结果,内部使用OnSubscribeReduce实现。"></a>reduce： 对序列使用reduce()函数并发射最终的结果,内部使用OnSubscribeReduce实现。</h4><pre><code>Observable.just(2,3,4,5)
        .reduce(new Func2&lt;Integer, Integer, Integer&gt;() {
            @Override
            public Integer call(Integer sum, Integer item) {
                return sum+item;
            }
        })
</code></pre><h4 id="collect：-使用collect收集数据到一个可变的数据结构。"><a href="#collect：-使用collect收集数据到一个可变的数据结构。" class="headerlink" title="collect： 使用collect收集数据到一个可变的数据结构。"></a>collect： 使用collect收集数据到一个可变的数据结构。</h4><pre><code>Observable.just(3,4,5,6)
           .collect(new Func0&lt;List&lt;Integer&gt;&gt;() { //创建数据结构

               @Override
               public List&lt;Integer&gt; call() {
                   return new ArrayList&lt;Integer&gt;();
               }
           }, new Action2&lt;List&lt;Integer&gt;, Integer&gt;() { //收集器
               @Override
               public void call(List&lt;Integer&gt; integers, Integer integer) {
                   integers.add(integer);
               }
           })
          .subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {
              @Override
              public void call(List&lt;Integer&gt; integers) {

              }
          });
</code></pre><h4 id="count-countLong：-计算发射的数量，内部调用的是reduce"><a href="#count-countLong：-计算发射的数量，内部调用的是reduce" class="headerlink" title="count/countLong： 计算发射的数量，内部调用的是reduce."></a>count/countLong： 计算发射的数量，内部调用的是reduce.</h4><h2 id="转换操作"><a href="#转换操作" class="headerlink" title="转换操作"></a>转换操作</h2><h4 id="toList：-收集原始Observable发射的所有数据到一个列表，然后返回这个列表"><a href="#toList：-收集原始Observable发射的所有数据到一个列表，然后返回这个列表" class="headerlink" title="toList： 收集原始Observable发射的所有数据到一个列表，然后返回这个列表."></a>toList： 收集原始Observable发射的所有数据到一个列表，然后返回这个列表.</h4><pre><code>Observable.just(2,3,4,5)
        .toList()
        .subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {
            @Override
            public void call(List&lt;Integer&gt; integers) {

            }
        });
</code></pre><h4 id="toSortedList：-收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表。"><a href="#toSortedList：-收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表。" class="headerlink" title="toSortedList： 收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表。"></a>toSortedList： 收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表。</h4><pre><code>Observable.just(6,2,3,4,5)
        .toSortedList(new Func2&lt;Integer, Integer, Integer&gt;() {//自定义排序
            @Override
            public Integer call(Integer integer, Integer integer2) {
                return integer-integer2; //&gt;0 升序 ，&lt;0 降序
            }
        })
        .subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {
            @Override
            public void call(List&lt;Integer&gt; integers) {
                Log.d(&quot;JG&quot;,integers.toString()); // [2, 3, 4, 5, 6]
            }
        });
</code></pre><h4 id="toMap：-将序列数据转换为一个Map。我们可以根据数据项生成key和生成value。"><a href="#toMap：-将序列数据转换为一个Map。我们可以根据数据项生成key和生成value。" class="headerlink" title="toMap： 将序列数据转换为一个Map。我们可以根据数据项生成key和生成value。"></a>toMap： 将序列数据转换为一个Map。我们可以根据数据项生成key和生成value。</h4><pre><code>Observable.just(6,2,3,4,5)
        .toMap(new Func1&lt;Integer, String&gt;() {
            @Override
            public String call(Integer integer) {
                return &quot;key：&quot; + integer; //根据数据项生成map的key
            }
        }, new Func1&lt;Integer, String&gt;() {
            @Override
            public String call(Integer integer) {
                return &quot;value：&quot;+integer; //根据数据项生成map的kvalue
            }
        }).subscribe(new Action1&lt;Map&lt;String, String&gt;&gt;() {
    @Override
    public void call(Map&lt;String, String&gt; stringStringMap) {
        Log.d(&quot;JG&quot;,stringStringMap.toString()); // {key：6=value：6, key：5=value：5, key：4=value：4, key：2=value：2, key：3=value：3}
    }
});
</code></pre><h4 id="toMultiMap：-类似于toMap，不同的地方在于map的value是一个集合。"><a href="#toMultiMap：-类似于toMap，不同的地方在于map的value是一个集合。" class="headerlink" title="toMultiMap： 类似于toMap，不同的地方在于map的value是一个集合。"></a>toMultiMap： 类似于toMap，不同的地方在于map的value是一个集合。</h4><h2 id="变换操作"><a href="#变换操作" class="headerlink" title="变换操作"></a>变换操作</h2><h4 id="map：-对Observable发射的每一项数据都应用一个函数来变换。"><a href="#map：-对Observable发射的每一项数据都应用一个函数来变换。" class="headerlink" title="map： 对Observable发射的每一项数据都应用一个函数来变换。"></a>map： 对Observable发射的每一项数据都应用一个函数来变换。</h4><pre><code>Observable.just(6,2,3,4,5)
        .map(integer -&gt; &quot;item:&quot;+integer)
        .subscribe(s -&gt; Log.d(&quot;JG&quot;,s));//item:6,item:2....
</code></pre><h4 id="cast：-在发射之前强制将Observable发射的所有数据转换为指定类型"><a href="#cast：-在发射之前强制将Observable发射的所有数据转换为指定类型" class="headerlink" title="cast： 在发射之前强制将Observable发射的所有数据转换为指定类型"></a>cast： 在发射之前强制将Observable发射的所有数据转换为指定类型</h4><h4 id="flatMap：-将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。"><a href="#flatMap：-将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。" class="headerlink" title="flatMap： 将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。"></a>flatMap： 将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。</h4><pre><code>   Observable.just(2,3,5)
        .flatMap(new Func1&lt;Integer, Observable&lt;String&gt;&gt;() {
            @Override
            public Observable&lt;String&gt; call(Integer integer) {
                return Observable.create(subscriber -&gt; {
                    subscriber.onNext(integer*10+&quot;&quot;);
                    subscriber.onNext(integer*100+&quot;&quot;);
                    subscriber.onCompleted();
                });
            }
        })
.subscribe(o -&gt; Log.d(&quot;JG&quot;,o)) //20,200,30,300,50,500
</code></pre><h4 id="flatMapIterable：-和flatMap的作用一样，只不过生成的是Iterable而不是Observable。"><a href="#flatMapIterable：-和flatMap的作用一样，只不过生成的是Iterable而不是Observable。" class="headerlink" title="flatMapIterable： 和flatMap的作用一样，只不过生成的是Iterable而不是Observable。"></a>flatMapIterable： 和flatMap的作用一样，只不过生成的是Iterable而不是Observable。</h4><pre><code>    Observable.just(2,3,5)
        .flatMapIterable(new Func1&lt;Integer, Iterable&lt;String&gt;&gt;() {
            @Override
            public Iterable&lt;String&gt; call(Integer integer) {
                return Arrays.asList(integer*10+&quot;&quot;,integer*100+&quot;&quot;);
            }
        }).subscribe(new Action1&lt;String&gt;() {
          @Override
          public void call(String s) {

          }
});
</code></pre><h4 id="concatMap：-类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。"><a href="#concatMap：-类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。" class="headerlink" title="concatMap： 类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。"></a>concatMap： 类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。</h4><h4 id="switchMap：-和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。"><a href="#switchMap：-和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。" class="headerlink" title="switchMap： 和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。"></a>switchMap： 和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。</h4><pre><code>Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() {

    @Override
    public void call(Subscriber&lt;? super Integer&gt; subscriber) {
        for(int i=1;i&lt;4;i++){
            subscriber.onNext(i);
            Utils.sleep(500,subscriber);//线程休眠500ms
        }

        subscriber.onCompleted();
    }
}).subscribeOn(Schedulers.newThread())
  .switchMap(new Func1&lt;Integer, Observable&lt;Integer&gt;&gt;() {
         @Override
       public Observable&lt;Integer&gt; call(Integer integer) {
               //每当接收到新的数据，之前的Observable将会被取消订阅
                return Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() {
                    @Override
                    public void call(Subscriber&lt;? super Integer&gt; subscriber) {
                        subscriber.onNext(integer*10);
                        Utils.sleep(500,subscriber);
                        subscriber.onNext(integer*100);
                        subscriber.onCompleted();
                    }
                }).subscribeOn(Schedulers.newThread());
            }
        })
        .subscribe(s -&gt; Log.d(&quot;JG&quot;,s.toString()));//10,20,30,300
</code></pre><h4 id="scan：-与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值。"><a href="#scan：-与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值。" class="headerlink" title="scan： 与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值。"></a>scan： 与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值。</h4><pre><code>Observable.just(2,3,5)
        .scan(new Func2&lt;Integer, Integer, Integer&gt;() {
            @Override
            public Integer call(Integer sum, Integer item) {
                return sum+item;
            }
        })
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString())) //2,5,10
</code></pre><h4 id="groupBy：-将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据。"><a href="#groupBy：-将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据。" class="headerlink" title="groupBy： 将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据。"></a>groupBy： 将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据。</h4><pre><code>Observable.just(2,3,5,6)
        .groupBy(new Func1&lt;Integer, String&gt;() {
            @Override
            public String call(Integer integer) {//分组
                return integer%2==0?&quot;偶数&quot;:&quot;奇数&quot;;
            }
        })
.subscribe(new Action1&lt;GroupedObservable&lt;String, Integer&gt;&gt;() {
    @Override
    public void call(GroupedObservable&lt;String, Integer&gt; o) {

        o.subscribe(new Action1&lt;Integer&gt;() {
            @Override
            public void call(Integer integer) {
                Log.d(&quot;JG&quot;,o.getKey()+&quot;:&quot;+integer.toString()); //偶数：2，奇数：3，...
            }
        });
    }
})
</code></pre><h4 id="buffer：-它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个"><a href="#buffer：-它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个" class="headerlink" title="buffer： 它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个"></a>buffer： 它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个</h4><pre><code>Observable.just(2,3,5,6)
        .buffer(3)
        .subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {
            @Override
            public void call(List&lt;Integer&gt; integers) {

            }
        })
</code></pre><h4 id="window：-定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。"><a href="#window：-定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。" class="headerlink" title="window： 定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。"></a>window： 定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。</h4><pre><code>Observable.just(2,3,5,6)
        .window(3)
        .subscribe(new Action1&lt;Observable&lt;Integer&gt;&gt;() {
            @Override
            public void call(Observable&lt;Integer&gt; integerObservable) {
                integerObservable.subscribe(new Action1&lt;Integer&gt;() {
                    @Override
                    public void call(Integer integer) {

                    }
                });
            }
        })
</code></pre><p>##错误处理/重试机制</p>
<h4 id="onErrorResumeNext：-当原始Observable在遇到错误时，使用备用Observable。。"><a href="#onErrorResumeNext：-当原始Observable在遇到错误时，使用备用Observable。。" class="headerlink" title="onErrorResumeNext： 当原始Observable在遇到错误时，使用备用Observable。。"></a>onErrorResumeNext： 当原始Observable在遇到错误时，使用备用Observable。。</h4><pre><code>Observable.just(1,&quot;2&quot;,3)
.cast(Integer.class)
.onErrorResumeNext(Observable.just(1,2,3))
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString())) //1,2,3
;
</code></pre><h4 id="onExceptionResumeNext：-当原始Observable在遇到异常时，使用备用的Observable。与onErrorResumeNext类似，区别在于onErrorResumeNext可以处理所有的错误，onExceptionResumeNext只能处理异常。"><a href="#onExceptionResumeNext：-当原始Observable在遇到异常时，使用备用的Observable。与onErrorResumeNext类似，区别在于onErrorResumeNext可以处理所有的错误，onExceptionResumeNext只能处理异常。" class="headerlink" title="onExceptionResumeNext： 当原始Observable在遇到异常时，使用备用的Observable。与onErrorResumeNext类似，区别在于onErrorResumeNext可以处理所有的错误，onExceptionResumeNext只能处理异常。"></a>onExceptionResumeNext： 当原始Observable在遇到异常时，使用备用的Observable。与onErrorResumeNext类似，区别在于onErrorResumeNext可以处理所有的错误，onExceptionResumeNext只能处理异常。</h4><h4 id="onErrorReturn：-当原始Observable在遇到错误时发射一个特定的数据。"><a href="#onErrorReturn：-当原始Observable在遇到错误时发射一个特定的数据。" class="headerlink" title="onErrorReturn： 当原始Observable在遇到错误时发射一个特定的数据。"></a>onErrorReturn： 当原始Observable在遇到错误时发射一个特定的数据。</h4><pre><code>Observable.just(1,&quot;2&quot;,3)
        .cast(Integer.class)
        .onErrorReturn(new Func1&lt;Throwable, Integer&gt;() {
            @Override
            public Integer call(Throwable throwable) {
                return 4;
            }
        }).subscribe(new Action1&lt;Integer&gt;() {
    @Override
    public void call(Integer integer) {
        Log.d(&quot;JG&quot;,integer.toString());1,4
    }
});
</code></pre><h4 id="retry：-当原始Observable在遇到错误时进行重试。"><a href="#retry：-当原始Observable在遇到错误时进行重试。" class="headerlink" title="retry： 当原始Observable在遇到错误时进行重试。"></a>retry： 当原始Observable在遇到错误时进行重试。</h4><pre><code>Observable.just(1,&quot;2&quot;,3)
.cast(Integer.class)
.retry(3)
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()),throwable -&gt; Log.d(&quot;JG&quot;,&quot;onError&quot;))
;//1,1,1,1,onError
</code></pre><h4 id="retryWhen：-当原始Observable在遇到错误，将错误传递给另一个Observable来决定是否要重新订阅这个Observable-内部调用的是retry。"><a href="#retryWhen：-当原始Observable在遇到错误，将错误传递给另一个Observable来决定是否要重新订阅这个Observable-内部调用的是retry。" class="headerlink" title="retryWhen： 当原始Observable在遇到错误，将错误传递给另一个Observable来决定是否要重新订阅这个Observable,内部调用的是retry。"></a>retryWhen： 当原始Observable在遇到错误，将错误传递给另一个Observable来决定是否要重新订阅这个Observable,内部调用的是retry。</h4><pre><code>Observable.just(1,&quot;2&quot;,3)
.cast(Integer.class)
.retryWhen(new Func1&lt;Observable&lt;? extends Throwable&gt;, Observable&lt;Long&gt;&gt;() {
    @Override
    public Observable&lt;Long&gt; call(Observable&lt;? extends Throwable&gt; observable) {
        return Observable.timer(1, TimeUnit.SECONDS);
    }
})
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()),throwable -&gt; Log.d(&quot;JG&quot;,&quot;onError&quot;));
//1,1
</code></pre><h2 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h2><h4 id="ConnectableObservable与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect-被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。"><a href="#ConnectableObservable与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect-被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。" class="headerlink" title="ConnectableObservable与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect()被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。"></a>ConnectableObservable与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect()被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。</h4><h4 id="ConnectableObservable-connect-指示一个可连接的Observable开始发射数据"><a href="#ConnectableObservable-connect-指示一个可连接的Observable开始发射数据" class="headerlink" title="ConnectableObservable.connect()指示一个可连接的Observable开始发射数据."></a>ConnectableObservable.connect()指示一个可连接的Observable开始发射数据.</h4><h4 id="Observable-publish-将一个Observable转换为一个可连接的Observable"><a href="#Observable-publish-将一个Observable转换为一个可连接的Observable" class="headerlink" title="Observable.publish()将一个Observable转换为一个可连接的Observable"></a>Observable.publish()将一个Observable转换为一个可连接的Observable</h4><h4 id="Observable-replay-确保所有的订阅者看到相同的数据序列的ConnectableObservable，即使它们在Observable开始发射数据之后才订阅。"><a href="#Observable-replay-确保所有的订阅者看到相同的数据序列的ConnectableObservable，即使它们在Observable开始发射数据之后才订阅。" class="headerlink" title="Observable.replay()确保所有的订阅者看到相同的数据序列的ConnectableObservable，即使它们在Observable开始发射数据之后才订阅。"></a>Observable.replay()确保所有的订阅者看到相同的数据序列的ConnectableObservable，即使它们在Observable开始发射数据之后才订阅。</h4><h4 id="ConnectableObservable-refCount-让一个可连接的Observable表现得像一个普通的Observable。"><a href="#ConnectableObservable-refCount-让一个可连接的Observable表现得像一个普通的Observable。" class="headerlink" title="ConnectableObservable.refCount()让一个可连接的Observable表现得像一个普通的Observable。"></a>ConnectableObservable.refCount()让一个可连接的Observable表现得像一个普通的Observable。</h4><pre><code>ConnectableObservable&lt;Integer&gt; co= Observable.just(1,2,3)
         .publish();

 co .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()) );
 co.connect();//此时开始发射数据
</code></pre><h2 id="阻塞操作"><a href="#阻塞操作" class="headerlink" title="阻塞操作"></a>阻塞操作</h2><h4 id="BlockingObservable是一个阻塞的Observable。普通的Observable-转换为BlockingObservable，可以使用-Observable-toBlocking-方法或者BlockingObservable-from-方法。内部通过CountDownLatch实现了阻塞操作。"><a href="#BlockingObservable是一个阻塞的Observable。普通的Observable-转换为BlockingObservable，可以使用-Observable-toBlocking-方法或者BlockingObservable-from-方法。内部通过CountDownLatch实现了阻塞操作。" class="headerlink" title="BlockingObservable是一个阻塞的Observable。普通的Observable 转换为BlockingObservable，可以使用 Observable.toBlocking( )方法或者BlockingObservable.from( )方法。内部通过CountDownLatch实现了阻塞操作。"></a>BlockingObservable是一个阻塞的Observable。普通的Observable 转换为BlockingObservable，可以使用 Observable.toBlocking( )方法或者BlockingObservable.from( )方法。内部通过CountDownLatch实现了阻塞操作。</h4><p>以下的操作符可以用于BlockingObservable，如果是普通的Observable，务必使用Observable.toBlocking()转为阻塞Observable后使用，否则达不到预期的效果。</p>
<h4 id="forEach：-对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。"><a href="#forEach：-对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。" class="headerlink" title="forEach： 对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。"></a>forEach： 对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。</h4><pre><code>Observable.just(2,3).observeOn(Schedulers.newThread()).toBlocking()
      .forEach(integer -&gt; {
          Log.d(&quot;JG&quot;,integer.toString()+&quot; &quot;+Thread.currentThread().getName());
          Utils.sleep(500);
      });

Log.d(&quot;JG&quot;,Thread.currentThread().getName());
// 2 RxNewThreadScheduler-1
// 3 RxNewThreadScheduler-1
// main
</code></pre><h4 id="first-firstOrDefault-last-lastOrDefault：这几个操作符之前有介绍过。也可以用于阻塞操作。"><a href="#first-firstOrDefault-last-lastOrDefault：这几个操作符之前有介绍过。也可以用于阻塞操作。" class="headerlink" title="first/firstOrDefault/last/lastOrDefault：这几个操作符之前有介绍过。也可以用于阻塞操作。"></a>first/firstOrDefault/last/lastOrDefault：这几个操作符之前有介绍过。也可以用于阻塞操作。</h4><h4 id="single-singleOrDefault：如果Observable终止时只发射了一个值，返回那个值，否则抛出异常或者发射默认值。"><a href="#single-singleOrDefault：如果Observable终止时只发射了一个值，返回那个值，否则抛出异常或者发射默认值。" class="headerlink" title="single/singleOrDefault：如果Observable终止时只发射了一个值，返回那个值，否则抛出异常或者发射默认值。"></a>single/singleOrDefault：如果Observable终止时只发射了一个值，返回那个值，否则抛出异常或者发射默认值。</h4><h4 id="mostRecent：返回一个总是返回Observable最近发射的数据的Iterable。"><a href="#mostRecent：返回一个总是返回Observable最近发射的数据的Iterable。" class="headerlink" title="mostRecent：返回一个总是返回Observable最近发射的数据的Iterable。"></a>mostRecent：返回一个总是返回Observable最近发射的数据的Iterable。</h4><h4 id="next：-返回一个Iterable，会阻塞直到Observable发射了第二个值，然后返回那个值。"><a href="#next：-返回一个Iterable，会阻塞直到Observable发射了第二个值，然后返回那个值。" class="headerlink" title="next： 返回一个Iterable，会阻塞直到Observable发射了第二个值，然后返回那个值。"></a>next： 返回一个Iterable，会阻塞直到Observable发射了第二个值，然后返回那个值。</h4><h4 id="latest：-返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值"><a href="#latest：-返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值" class="headerlink" title="latest： 返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值"></a>latest： 返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值</h4><h4 id="toFuture：-将Observable转换为一个Future"><a href="#toFuture：-将Observable转换为一个Future" class="headerlink" title="toFuture： 将Observable转换为一个Future"></a>toFuture： 将Observable转换为一个Future</h4><h4 id="toIterable：将一个发射数据序列的Observable转换为一个Iterable。"><a href="#toIterable：将一个发射数据序列的Observable转换为一个Iterable。" class="headerlink" title="toIterable：将一个发射数据序列的Observable转换为一个Iterable。"></a>toIterable：将一个发射数据序列的Observable转换为一个Iterable。</h4><h4 id="getIterator：将一个发射数据序列的Observable转换为一个Iterator工具集"><a href="#getIterator：将一个发射数据序列的Observable转换为一个Iterator工具集" class="headerlink" title="getIterator：将一个发射数据序列的Observable转换为一个Iterator工具集"></a>getIterator：将一个发射数据序列的Observable转换为一个Iterator工具集</h4><h4 id="materialize：-将Observable转换成一个通知列表。"><a href="#materialize：-将Observable转换成一个通知列表。" class="headerlink" title="materialize： 将Observable转换成一个通知列表。"></a>materialize： 将Observable转换成一个通知列表。</h4><pre><code>Observable.just(1,2,3)
       .materialize()
       .subscribe(new Action1&lt;Notification&lt;Integer&gt;&gt;() {
           @Override
           public void call(Notification&lt;Integer&gt; notification) {
               Log.d(&quot;JG&quot;,notification.getKind()+&quot; &quot;+notification.getValue());
               //OnNext 1
               //OnNext 2
               //OnNext 3
               //OnCompleted null
           }
       });
</code></pre><h4 id="dematerialize：-与上面的作用相反，将通知逆转回一个Observable。"><a href="#dematerialize：-与上面的作用相反，将通知逆转回一个Observable。" class="headerlink" title="dematerialize： 与上面的作用相反，将通知逆转回一个Observable。"></a>dematerialize： 与上面的作用相反，将通知逆转回一个Observable。</h4><h4 id="timestamp：-给Observable发射的每个数据项添加一个时间戳。"><a href="#timestamp：-给Observable发射的每个数据项添加一个时间戳。" class="headerlink" title="timestamp： 给Observable发射的每个数据项添加一个时间戳。"></a>timestamp： 给Observable发射的每个数据项添加一个时间戳。</h4><pre><code>Observable.just(1,2,3)
       .timestamp()
       .subscribe(new Action1&lt;Timestamped&lt;Integer&gt;&gt;() {
           @Override
           public void call(Timestamped&lt;Integer&gt; timestamped) {
               Log.d(&quot;JG&quot;,timestamped.getTimestampMillis()+&quot; &quot;+timestamped.getValue());
               //1472627510548 1
               //1472627510549 2
               //1472627510549 3
           }
       });
</code></pre><h4 id="timeInterval：给Observable发射的两个数据项间添加一个时间差，实现在OperatorTimeInterval中"><a href="#timeInterval：给Observable发射的两个数据项间添加一个时间差，实现在OperatorTimeInterval中" class="headerlink" title="timeInterval：给Observable发射的两个数据项间添加一个时间差，实现在OperatorTimeInterval中"></a>timeInterval：给Observable发射的两个数据项间添加一个时间差，实现在OperatorTimeInterval中</h4><p><img src="http://static.zybuluo.com/maplejaw/6dbl77xvh2z02hxil00juave/image_1argc8a1n17a61t441s5p1gln8231g.png" alt="Markdown preferences pane"></p>
<h4 id="serialize：-强制Observable按次序发射数据并且要求功能是完好的"><a href="#serialize：-强制Observable按次序发射数据并且要求功能是完好的" class="headerlink" title="serialize： 强制Observable按次序发射数据并且要求功能是完好的"></a>serialize： 强制Observable按次序发射数据并且要求功能是完好的</h4><h4 id="cache：-缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者"><a href="#cache：-缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者" class="headerlink" title="cache： 缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者"></a>cache： 缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者</h4><h4 id="observeOn：-指定观察者观察Observable的调度器"><a href="#observeOn：-指定观察者观察Observable的调度器" class="headerlink" title="observeOn： 指定观察者观察Observable的调度器"></a>observeOn： 指定观察者观察Observable的调度器</h4><h4 id="subscribeOn：-指定Observable执行任务的调度器"><a href="#subscribeOn：-指定Observable执行任务的调度器" class="headerlink" title="subscribeOn： 指定Observable执行任务的调度器"></a>subscribeOn： 指定Observable执行任务的调度器</h4><h4 id="doOnEach：-注册一个动作，对Observable发射的每个数据项使用"><a href="#doOnEach：-注册一个动作，对Observable发射的每个数据项使用" class="headerlink" title="doOnEach： 注册一个动作，对Observable发射的每个数据项使用"></a>doOnEach： 注册一个动作，对Observable发射的每个数据项使用</h4><pre><code>Observable.just(2,3)
        .doOnEach(new Action1&lt;Notification&lt;? super Integer&gt;&gt;() {
            @Override
            public void call(Notification&lt;? super Integer&gt; notification) {
                Log.d(&quot;JG&quot;,&quot;--doOnEach--&quot;+notification.toString());
            }
        })
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));
</code></pre><p>//结果为：<br> // –doOnEach–[rx.Notification@133c40b0 OnNext 2]<br>// 2<br> // –doOnEach–[rx.Notification@133c40b0 OnNext 3]<br>// 3<br>// –doOnEach–[rx.Notification@df4db0e OnCompleted]</p>
<h4 id="doOnCompleted：-注册一个动作，对正常完成的Observable使用"><a href="#doOnCompleted：-注册一个动作，对正常完成的Observable使用" class="headerlink" title="doOnCompleted： 注册一个动作，对正常完成的Observable使用"></a>doOnCompleted： 注册一个动作，对正常完成的Observable使用</h4><h4 id="doOnError：-注册一个动作，对发生错误的Observable使用"><a href="#doOnError：-注册一个动作，对发生错误的Observable使用" class="headerlink" title="doOnError： 注册一个动作，对发生错误的Observable使用"></a>doOnError： 注册一个动作，对发生错误的Observable使用</h4><h4 id="doOnTerminate：注册一个动作，对完成的Observable使用，无论是否发生错误"><a href="#doOnTerminate：注册一个动作，对完成的Observable使用，无论是否发生错误" class="headerlink" title="doOnTerminate：注册一个动作，对完成的Observable使用，无论是否发生错误"></a>doOnTerminate：注册一个动作，对完成的Observable使用，无论是否发生错误</h4><pre><code>Observable.just(2,3)
        .doOnTerminate(new Action0() {
            @Override
            public void call() {
                Log.d(&quot;JG&quot;,&quot;--doOnTerminate--&quot;);
            }
        })
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));// 2 , 3 , --doOnTerminate--
</code></pre><h4 id="doOnSubscribe：-注册一个动作，在观察者订阅时使用。内部由OperatorDoOnSubscribe实现，"><a href="#doOnSubscribe：-注册一个动作，在观察者订阅时使用。内部由OperatorDoOnSubscribe实现，" class="headerlink" title="doOnSubscribe： 注册一个动作，在观察者订阅时使用。内部由OperatorDoOnSubscribe实现，"></a>doOnSubscribe： 注册一个动作，在观察者订阅时使用。内部由OperatorDoOnSubscribe实现，<img src="http://static.zybuluo.com/maplejaw/9w3o5vxc0lzznbrpn4vwa78w/image_1argbe0o1atfqtbrj51gu0jho9.png" alt="Markdown preferences pane"></h4><h4 id="doOnUnsubscribe：-注册一个动作，在观察者取消订阅时使用。内部由OperatorDoOnUnsubscribe实现，在call中加入一个解绑动作。"><a href="#doOnUnsubscribe：-注册一个动作，在观察者取消订阅时使用。内部由OperatorDoOnUnsubscribe实现，在call中加入一个解绑动作。" class="headerlink" title="doOnUnsubscribe： 注册一个动作，在观察者取消订阅时使用。内部由OperatorDoOnUnsubscribe实现，在call中加入一个解绑动作。"></a>doOnUnsubscribe： 注册一个动作，在观察者取消订阅时使用。内部由OperatorDoOnUnsubscribe实现，在call中加入一个解绑动作。</h4><p><img src="http://static.zybuluo.com/maplejaw/791vkq1lxpl2etqaql85a6e8/image_1argbhutoi1a1b6a18s9il6npvm.png" alt="Markdown preferences pane"></p>
<h4 id="finallyDo-doAfterTerminate：-注册一个动作，在Observable完成时使用"><a href="#finallyDo-doAfterTerminate：-注册一个动作，在Observable完成时使用" class="headerlink" title="finallyDo/doAfterTerminate： 注册一个动作，在Observable完成时使用"></a>finallyDo/doAfterTerminate： 注册一个动作，在Observable完成时使用</h4><pre><code>Observable.just(2,3)
        .doAfterTerminate(new Action0() {
            @Override
            public void call() {
                Log.d(&quot;JG&quot;,&quot;--doAfterTerminate--&quot;);
            }
        })
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));
    //2,3,  --doAfterTerminate-- 
</code></pre><h4 id="delay：-延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。"><a href="#delay：-延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。" class="headerlink" title="delay： 延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。"></a>delay： 延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。</h4><h4 id="delaySubscription：-延时处理订阅请求。实现在OnSubscribeDelaySubscription中"><a href="#delaySubscription：-延时处理订阅请求。实现在OnSubscribeDelaySubscription中" class="headerlink" title="delaySubscription： 延时处理订阅请求。实现在OnSubscribeDelaySubscription中"></a>delaySubscription： 延时处理订阅请求。实现在OnSubscribeDelaySubscription中</h4><p><img src="http://static.zybuluo.com/maplejaw/xqw7fto75revvct4zu3d56a5/image_1argc0tbetbj1rkj1etf4fcb1p13.png" alt="Markdown preferences pane"></p>
<h4 id="using：-创建一个只在Observable生命周期存在的资源，当Observable终止时这个资源会被自动释放。"><a href="#using：-创建一个只在Observable生命周期存在的资源，当Observable终止时这个资源会被自动释放。" class="headerlink" title="using： 创建一个只在Observable生命周期存在的资源，当Observable终止时这个资源会被自动释放。"></a>using： 创建一个只在Observable生命周期存在的资源，当Observable终止时这个资源会被自动释放。</h4><pre><code>Observable.using(new Func0&lt;File&gt;() {//资源工厂
    @Override
    public File call() {

        File file = new File(getCacheDir(), &quot;a.txt&quot;);
        if(!file.exists()){
            try {
                Log.d(&quot;JG&quot;,&quot;--create--&quot;);
                file.createNewFile();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return file;
    }
}, new Func1&lt;File, Observable&lt;String&gt;&gt;() { //Observable
    @Override
    public Observable&lt;String&gt; call(File file) {
        return Observable.just(file.exists() ? &quot;exist&quot; : &quot;no exist&quot;);
    }
}, new Action1&lt;File&gt;() {//释放资源动作
    @Override
    public void call(File file) {
        if(file!=null&amp;&amp;file.exists()){
            Log.d(&quot;JG&quot;,&quot;--delete--&quot;);
            file.delete();
        }
    }
})
.subscribe(s -&gt; Log.d(&quot;JG&quot;,s))
;
//--create--
//exist
//--delete--
</code></pre><h4 id="single-singleOrDefault：-强制返回单个数据，否则抛出异常或默认数据。"><a href="#single-singleOrDefault：-强制返回单个数据，否则抛出异常或默认数据。" class="headerlink" title="single/singleOrDefault： 强制返回单个数据，否则抛出异常或默认数据。"></a>single/singleOrDefault： 强制返回单个数据，否则抛出异常或默认数据。</h4><p>关于RxJava标准库的操作符已经介绍完毕，纯粹当个备忘录。如有错误之处，欢迎指出。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/07/Activity的生命周期和启动模式的总结/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2542991507,3032577261&fm=116&gp=0.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="fastabler">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="fastabler" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/07/Activity的生命周期和启动模式的总结/" itemprop="url">
                  Activity的生命周期和启动模式的总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-07T13:16:20+08:00">
                2016-12-07
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/07/Activity的生命周期和启动模式的总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/07/Activity的生命周期和启动模式的总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Activity毫无疑问是Android中最重要的组件之一了，做好一个android程序，首先就得要hold住他的生命周期。</p>
<h2 id="Activity的生命周期的总结，以及注意的细节"><a href="#Activity的生命周期的总结，以及注意的细节" class="headerlink" title="Activity的生命周期的总结，以及注意的细节"></a>Activity的生命周期的总结，以及注意的细节</h2><p>先来个图</p>
<p><img src="http://hi.csdn.net/attachment/201109/1/0_1314838777He6C.gif" alt="Activity生命周期图"></p>
<h3 id="典型情况下的生命周期的分析"><a href="#典型情况下的生命周期的分析" class="headerlink" title="典型情况下的生命周期的分析"></a>典型情况下的生命周期的分析</h3><p>Activity的常用生命周期我们不做讨论，一个Activity从创建到结束的基本回调为：onCreate-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onStop-&gt;onDestroy。<br>从整个生命周期来说，onCreate跟onDestroy是相对的，分别标识着Activity的创建和销毁。onStart跟onStop是相对的，分别标识着Activity是否完全可见。onResume跟onPause是相对的，分别标识着Activity是否在前台。</p>
<h4 id="生命周期细节分析"><a href="#生命周期细节分析" class="headerlink" title="生命周期细节分析"></a>生命周期细节分析</h4><ul>
<li><p>onStart跟onResume、onPause跟onStop从他们的描述上讲是差不多的，甚至在实际开发的过程中我们只保留其中的一对。onStart跟onStop是相对的，分别标识着Activity是否完全可见。onResume跟onPause是相对的，分别标识着Activity是否在前台。其他情况没有本质区别。</p>
</li>
<li><p>ActivityA中的onPause要比即将打开的ActivityB的onResume先执行，即前一个AcitivtyA要先执行完onPause之后后一个ActivityB就开始走自己的生命周期了，当ActivityB位于前台之后（即执行完onResume）ActivityA的onStop才执行，<strong>基于此我们可以知道必须在onPause处理耗时少的任务，要不然会影响下一个Activity的执行</strong></p>
</li>
</ul>
<h3 id="异常情况下的生命周期的分析"><a href="#异常情况下的生命周期的分析" class="headerlink" title="异常情况下的生命周期的分析"></a>异常情况下的生命周期的分析</h3><p>Activity除了受用户操作导致的正常生命周期方法的调度，还会存在一些异常的情况：比如当系统内存不足、资源相关的系统配置发生改变。</p>
<h4 id="当资源相关的系统配置发生改变导致Activity被杀死并重新创建"><a href="#当资源相关的系统配置发生改变导致Activity被杀死并重新创建" class="headerlink" title="当资源相关的系统配置发生改变导致Activity被杀死并重新创建"></a>当资源相关的系统配置发生改变导致Activity被杀死并重新创建</h4><p>典型的是当我们旋转手机的时候，由于横排导致需要重新加载各种横屏资源，所以会导致Activity的杀死重建，会依次执行onPause、onStop、onDestroy，同时由于Activity是在异常情况下终止的，所以系统会调用onSavaInstanceState来保存异常情况前的状态。onSavaInstanceState调用在onPause之后，跟onStope没有明确的次序关系，有可能在前也有可能在后。Activity重新加载会依次执行onCreate、onStart、onRestoreInstanceState来恢复状态。也可以直接在onCreate中判断bundle是否为空来恢复之前的状态。当Activity异常终止并重新创建时，系统会自动帮我们保存并恢复Activity的视图结构，以及数据，如文本框中用户输入的数据，ListView滑动的位置等。</p>
<h4 id="当内存不足导致的优先级低的Activity被杀死"><a href="#当内存不足导致的优先级低的Activity被杀死" class="headerlink" title="当内存不足导致的优先级低的Activity被杀死"></a>当内存不足导致的优先级低的Activity被杀死</h4><p>这种情况是比较常见的。在国内许多定制的系统中，为了保证手机的运行速度，会频繁的进行检查杀死优先级低的Activity，有时候即使内存足够也会面临被杀死的情况。Activity按照优先级从高到低分别为</p>
<ol>
<li>前台Activity，正在和用户交互的Activity，优先级最高</li>
<li>可见但非前台Activity，比如Activity弹出了一个对话框，此时的Activity是可见的，但是无法和用户交互，</li>
<li>后台Activity，已经被暂停的Activity，优先级最低，当内存不足时最容易被处理</li>
</ol>
<h2 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h2><h3 id="Activity的LaunchMode"><a href="#Activity的LaunchMode" class="headerlink" title="Activity的LaunchMode"></a>Activity的LaunchMode</h3><p>如果没有Activity的启动模式，我们在启动的时候只能为单一的跳转，非常不灵活。当我们多次启动同一个Activity，系统会创建多个Activity实例一一放在任务栈中，当我们单机back键后Activity会一一回退。任务栈是一种“后进先出”的栈结构。当栈中无任务Activity后系统会回收这个任务栈。4种启动模式介绍，</p>
<ol>
<li>standard：标准模式。这也是系统默认的模式，每次启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在，一个任务栈中可以有多个实例，一个实例也可以存在于多个栈中。启动的时候在哪一个栈中启动就会直接加到那个任务栈中。</li>
<li>singleTop：栈顶复用模式。在这种模式下，如果新的Activity处于栈顶，那么此Activity不会重新创建，同时他的onNewIntent方法会被调用，通过此方法我们可以得到当前请求的信息。而onCreate、onStart、onResume等方法没有被调用，因为他并没有发生改变。但是如果新的Activity不是处于栈顶，那么新的Activity会被重新创建并放入到栈顶。</li>
<li>singleTask：栈内复用模式。这是一种单实例模式，即当新的Activity存在于栈中，新的Activity会把其之上的Activity全部清除，让自己成为栈顶，并且栈中只会有一个相同的实例。</li>
<li>singleInstance：单实例模式。这其实是singleTask模式的加强版，即具有此模式的新的Activity会单独的位于一个任务栈中。</li>
</ol>
<p>上面介绍的几种启动模式，我们假设目前有两个任务栈，前台任务栈A、B，后台任务栈C、D。当我们从B启动D的时候，会拉起整个后台任务栈，即C、D，当点击back键会先返回到C，再点击返回到B。当从B启动C的时候，D不会跟着拉起来。用图解释可能会更加易懂：<br><img src="http://okzxn9yra.bkt.clouddn.com/taskstack1.png" alt="任务栈图"><br><img src="http://okzxn9yra.bkt.clouddn.com/taskstack2.png" alt="任务栈图"></p>
<h3 id="Activity的Flags"><a href="#Activity的Flags" class="headerlink" title="Activity的Flags"></a>Activity的Flags</h3><p>Activity的Flags有很多，这里主要介绍几个比较常见的标记位。标记位的作用很多，有的标记可以设置Activity的启动模式，有的标记位可以影响Activity的运行状态，还有的标记位可以设置视图的显示。大部分情况下我们不需要为Activity设置标记位。</p>
<ul>
<li>FLAG_ACTIVITY_NEW_TASK：这个标记为的作用是指定“singleTask”启动模式，其效果和在manifest设置效果相同</li>
<li>FLAG_ACTIVITY_SINGLE_TOP：这个标记位的作用是为Activity指定“singleTop”启动模式，其效果和在manifest设置效果相同。</li>
<li>FLAG_ACTIVITY_CLEAR_TOP：具有此标记位的Activity，当他启动时，在同一个任务栈中所有位于他顶部的Activity都要出栈，这个模式一般和FLAG_ACTIVITY_NEW_TASK配合使用。</li>
<li>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：具有此标记为都Activity不会出现在Activity历史列表中，等同于在minifest中设置属性android:excludeFromRecent=”true”.</li>
</ul>
<h3 id="IntentFilter的匹配规则"><a href="#IntentFilter的匹配规则" class="headerlink" title="IntentFilter的匹配规则"></a>IntentFilter的匹配规则</h3><p>启动Activity分为两种，显示调用和隐式调用。显示调用需要明确指明被调用对象的组件信息，包括包名和类名，而隐式调用则不需要明确指定组件信息，原则上一个Intent不能即为显式又为隐式，如果二者共存的话显示为主。隐式调用需要明确组件的IntentFilter，如果不匹配则无法启动目标Activity。IntentFilter的过滤信息为action、category、data。</p>
<ul>
<li>action的匹配规则要求action存在且必须和过滤规则中的其中一个action相同，只要有一个相同就可以，如果设置了多个action，只要有一个action匹配Intent就可以。</li>
<li>category的匹配规则要求如果Intent中存在category，那么所有的category必须和过滤规则中的其中一个category相同。换句话说，对于每一个category都必须必配已经定义了的。Intent中可以没有category，如果一旦有就必须完全匹配。</li>
<li>data的匹配规则跟action类似</li>
</ul>
<p>以上就是关于Activity的一些总结，其中的细节可以查看相关文档。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  

          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2542991507,3032577261&fm=116&gp=0.jpg"
               alt="fastabler" />
          <p class="site-author-name" itemprop="name">fastabler</p>
          <p class="site-description motion-element" itemprop="description">Efforts can only pass,hard to be excellent.</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fastabler</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"fastabler"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  

  

  

  

  


</body>
</html>

<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Efforts can only pass,hard to be excellent.">
<meta property="og:type" content="website">
<meta property="og:title" content="黄金龙的博客">
<meta property="og:url" content="http://hjlinfo.top/index.html">
<meta property="og:site_name" content="黄金龙的博客">
<meta property="og:description" content="Efforts can only pass,hard to be excellent.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="黄金龙的博客">
<meta name="twitter:description" content="Efforts can only pass,hard to be excellent.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hjlinfo.top/"/>





  <title> 黄金龙的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ad1350e91810844821a7ad3e1f8ac561";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">黄金龙的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">fastabler</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2017/02/09/nginx基本使用/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/09/nginx基本使用/" itemprop="url">
                  nginx基本使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-09T15:24:42+08:00">
                2017-02-09
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>主要介绍一下Nginx的最基本功能以及简单配置</p>
<h2 id="静态HTTP服务器"><a href="#静态HTTP服务器" class="headerlink" title="静态HTTP服务器"></a>静态HTTP服务器</h2><p>首先，Nginx是一个HTTP服务器，可以将服务器上的静态文件（如HTML、图片）通过HTTP协议展现给客户端。<br>配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">	listen 80;</div><div class="line">	lication / &#123;	</div><div class="line">		root /usr/share/nginx/html; #静态文件路径</div><div class="line">	&#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2017/02/09/搭建后台技术框架/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/09/搭建后台技术框架/" itemprop="url">
                  搭建后台技术框架
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-09T14:13:58+08:00">
                2017-02-09
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>针对中小型互联网公司，特别适用于手机App的后台架构，支撑5万日活，满足中小型公司需求</p>
<blockquote>
<p>QPS， 如果是5万日活，使用集中在每天的4小时，每个用户大概产生100的请求，那么平均下来，我们系统大概应该支撑的请求为：50000 <em> 100 / (4 </em> 60 * 60) = 350 qps/s</p>
<p>业务数据 业务量，我们自己是新闻业务，可能会有其他的业务，比如游戏，商城等等，基本每天新增的业务数据都会在同一个量级， 每日10000， 另外跟用户相关的信息也是比较大的一块，比如用户的订阅等行为，一共5万的用户，保存相关信息可能大概需要100条的数据。</p>
<p>缓存大小 主要业务数据和用户相关的热点数据限时保存在缓存中， 大概需要5个G左右。</p>
<p>日志大小 用户日志和请求日志。 大概每天3个G左右</p>
</blockquote>
<h2 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h2><p>基于阿里云服务搭建</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>前期可以单机运行，业务量上来之后集群，使用nginx进行负载均衡，也可以选择阿里云的收费SLB</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>用于保存静态文件，阿里云跟七牛云都可以。一些图片数据如用户头像等由前端直接上传到七牛云，将返回的地址再返回给数据库，图片等大型文件不再经过服务器处理。app的新版本也直接保存在七牛云，更新的时候直接从七牛云下载，减少客户端请求服务器的带宽，可以明显提高访问速度</p>
<h2 id="分布式调用框架"><a href="#分布式调用框架" class="headerlink" title="分布式调用框架"></a>分布式调用框架</h2><p>可以直接选用dubbo，这个是使用最多应用范围最广的，遇到问题也能快速解决。springcloud目前国内用的较少，而且eureka2.0之后不再开源。也可以选择当当的dubboX</p>
<h2 id="消息队列MQ"><a href="#消息队列MQ" class="headerlink" title="消息队列MQ"></a>消息队列MQ</h2><p>可选的有： ActiveMQ, 阿里云消息， robbitMQ, 各有好处， 但是考虑到运维的难度，推荐阿里云消息。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>使用Redis</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>主要基于读写分离和主从复制考虑</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>建议ELK， 可以自动同步数据库，除了搜索引擎的功能外，还可以做日志搜索，监控系统</p>
<h2 id="一些典型的业务场景说明"><a href="#一些典型的业务场景说明" class="headerlink" title="一些典型的业务场景说明"></a>一些典型的业务场景说明</h2><ul>
<li>把业务底层做成SOA模块，通过分布式调用框架对外提供服务。</li>
<li>单独做一个小的系统来运行定时任务</li>
<li>热点数据放缓存，然后通过MQ来更新缓存</li>
<li>日志等数据有必要可以考虑上个Mongo</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2017/01/28/android右滑手势返回问题的解决思路/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/28/android右滑手势返回问题的解决思路/" itemprop="url">
                  android右滑手势返回问题的解决思路
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-28T17:42:21+08:00">
                2017-01-28
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于android右滑返回的几种解决办法"><a href="#关于android右滑返回的几种解决办法" class="headerlink" title="关于android右滑返回的几种解决办法"></a>关于android右滑返回的几种解决办法</h2><p>最近简单看了一下ios开发，界面开发方法感觉不如android来的痛快。可能接触的比较少，大概在做界面开发的时候各种要切图，还是android来的实在。而且关于屏幕适配在android上没法解决，在ios上也是一大痛点啊，这些在web上解决起来游刃有余，这也是web以后一统天下的一大原因吧。<br>看了几天ios开发之后，感觉android上的东西基本都是按照ios的标准来的。个人感觉谷歌的Material design非常棒，不知道在国内为啥流行不起来。但是ios设计有官方支持，开发起来更酸爽，android按照苹果的规范来开发就显得不这么自然，当然，ios用户体验确实无懈可击，大部分都是手势操作，例如滑动删除，滑动返回等等。今天就来分析一下滑动返回在android上实现的方法思路。</p>
<h3 id="滑动返回的核心就是View的滑动"><a href="#滑动返回的核心就是View的滑动" class="headerlink" title="滑动返回的核心就是View的滑动"></a>滑动返回的核心就是View的滑动</h3><p>滑动返回的核心不过就是根据手势来进行滑动，听起来确实像一句废话。关于View滑动大概就是三种方法，而滑动返回就是根据这三种方法进行拓展的。</p>
<ol>
<li>通过View自带的scrollTo和scrollBy</li>
<li>通过动画，包括属性动画和视图动画</li>
<li>通过动态的布局</li>
<li>还有一种在v4包里面的ViewDragHelper，关于用法不是本文的重点，但是绝对是开发的神器类，市面上的手势操作应用，基本都能用它来实现</li>
</ol>
<h3 id="滑动返回的几种解决方案"><a href="#滑动返回的几种解决方案" class="headerlink" title="滑动返回的几种解决方案"></a>滑动返回的几种解决方案</h3><p>以上View滑动方法结合滑动返回需求的实际使用场景</p>
<h4 id="第一种通过scrollTo和scrollBy实现滑动"><a href="#第一种通过scrollTo和scrollBy实现滑动" class="headerlink" title="第一种通过scrollTo和scrollBy实现滑动"></a>第一种通过scrollTo和scrollBy实现滑动</h4><p>结合固定的弹性滑动方法。scrollTo/scrollBy只能滑动View内的内容，所以适合二级页面少的情况，我们可以在同一个Activity中添加两个视图，通过scrollTo/scrollBy进行动态的添加删除View。<br>最好的应用场景就是最多二级页面，而且页面结构不复杂的情况。这样我们就不用多创建额外的Activity，在进行页面切换的时候异常的流畅。缺点也是显而易见的，就是要在逻辑性以及界面结构及其简单的情况下使用，最重要的是页面的跳转不能过多。因为太多原因的限制，所以这种方法适用的场景很少，但也有些情况使用它却会让页面流畅度增加N+1倍。<br>例如像nice应用中拍照和摄影就放在了同一个Activity中，然后结合ViewPage+Fragment使用。很明显的问题就是在切换的时候会明显的卡顿一段时间，我用价位在2500左右的手机进行测试的时候都能感到非常明显的卡顿。造成卡顿的原因是什么呢？因为在调用系统摄像头，在两个Fragment中分别调用了打开和关闭方法，这样就会有卡顿的情况。在这种场景下就可以使用scrollTo/scrollBy，在同一个页面中添加两个视图，但是两个视图共用同一个Camera，这样在切换的时候速度就会很快了。</p>
<h4 id="第二种我们可以使用动画或者动态布局或者ViewDragHelper，当滑动到一定距离的时候进行弹性滑动，然后结束掉此Activity，就实现了"><a href="#第二种我们可以使用动画或者动态布局或者ViewDragHelper，当滑动到一定距离的时候进行弹性滑动，然后结束掉此Activity，就实现了" class="headerlink" title="第二种我们可以使用动画或者动态布局或者ViewDragHelper，当滑动到一定距离的时候进行弹性滑动，然后结束掉此Activity，就实现了"></a>第二种我们可以使用动画或者动态布局或者ViewDragHelper，当滑动到一定距离的时候进行弹性滑动，然后结束掉此Activity，就实现了</h4><p>主要是首先要实现View跟随着手势滑动。主要的问题是需要设置一个透明背景。关于git上很多第三方都是基于此方法，而核心问题需要设置窗口半透明windowIsTranslucent为true，设置之后当滑动返回的时候，就能看到上一个窗口的view了。当然设置了这个属性之后会出现各种各样的问题，需要根据具体需求来修改。</p>
<h4 id="第三种方法也是首先实现滑动，在滑动的时候把上一个Activity的页面加到滑动的左边，也就是说我们在滑动时候看到的上一个视图是个假视图，并不是上一个Activity，只是Activity绘制的一个图。"><a href="#第三种方法也是首先实现滑动，在滑动的时候把上一个Activity的页面加到滑动的左边，也就是说我们在滑动时候看到的上一个视图是个假视图，并不是上一个Activity，只是Activity绘制的一个图。" class="headerlink" title="第三种方法也是首先实现滑动，在滑动的时候把上一个Activity的页面加到滑动的左边，也就是说我们在滑动时候看到的上一个视图是个假视图，并不是上一个Activity，只是Activity绘制的一个图。"></a>第三种方法也是首先实现滑动，在滑动的时候把上一个Activity的页面加到滑动的左边，也就是说我们在滑动时候看到的上一个视图是个假视图，并不是上一个Activity，只是Activity绘制的一个图。</h4><p>这种方法对程序的影响最小，但是也存在问题。首先我们需要在视图结束的时候执行finish方法真正结束掉这个Activity，在一些定制的系统上，每次finishActivity都会闪屏一下，这样我们可以清楚的看到这种不好的体验。还有就是因为我们看到的上一个Activity是个假的视图，所以当滑动完成之后立即点击会没有反应。</p>
<p>以上就是解决右滑返回的三种方案，关于代码，<a href="https://github.com/search?l=Java&amp;o=desc&amp;q=swipeback&amp;s=stars&amp;type=Repositories&amp;utf8=✓" target="_blank" rel="external">请移步github选择合适的解决方法</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2017/01/08/属性动画的使用原理/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/08/属性动画的使用原理/" itemprop="url">
                  属性动画的使用原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-08T10:38:47+08:00">
                2017-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>属性动画是API 11新加入的特性，和View动画不同，它对作用对象进行了扩展，属性动画可以对任何对象做动画，甚至还可以没有对象。除了作用对象进行了扩展以外，属性动画的效果也得到了加强，属性动画中有ValueAnimator（对值进行动画）、ObjectAnimator（对对象进行动画）、AnimatorSet（动画集合）等概念，通过他们可以实现绚丽的动画效果。</p>
<h2 id="使用属性动画"><a href="#使用属性动画" class="headerlink" title="使用属性动画"></a>使用属性动画</h2><p>属性动画可以对任意的对象属性进行动画而不仅仅是View，<strong>动画默认的时间为300ms</strong>，默认帧率为10ms／帧。其可以达到的效果是在一个时间间隔内完成对象从一个属性值到另一个属性值到改变。因此属性动画几乎无所不能。因为现在android版本都在4.0以上，所以我们不用考虑API 11以下手机。</p>
<ul>
<li>例如我们想改变一个对象的translationY的属性，让其沿着Y轴向上平移一段距离：它的高度。该动画在默认时间内完成，动画的完成时间是可以定义的。想要更灵活的效果我们还可以定义插值器和估值算法，但是一般我们不需要自定义，系统已经预置了一些，能够满足常用动画</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator.ofFloat(myObject, &quot;translationY&quot;, -myObject.getHeight()).start();</div></pre></td></tr></table></figure>
<ul>
<li>改变一个对象的背景色属性，典型的情形是改变View的背景色，下面的动画可以让View在3s内实现从0xFFFF8080到0xFF8080FF的渐变，动画会无限循环且会有反转的效果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ValueAnimator colorAnim = ObjectAnimator.ofInt(this, &quot;backgroundColor&quot;,0xFFFF8080, 0xFF8080FF);</div><div class="line">colorAnim.setDuration(3000);</div><div class="line">colorAnim.setEvaluator(new ArgbEvaluator());</div><div class="line">colorAnim.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">colorAnim.setRepeatMode(ValueAnimator.REVERSE);</div><div class="line">colorAnim.start();</div></pre></td></tr></table></figure>
<ul>
<li>动画集合，5s内对View的旋转、平移、缩放和透明度都进行了改变</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">AnimatorSet set = new AnimatorSet();</div><div class="line">set.playTogether(ObjectAnimator.ofFloat(myView, &quot;rotationX&quot;, 0, 360),</div><div class="line">	ObjectAnimator.ofFloat(myView, &quot;rotationY&quot;, 0, 180),</div><div class="line">	ObjectAnimator.ofFloat(myView, &quot;rotation&quot;, 0, -90),</div><div class="line">	ObjectAnimator.ofFloat(myView, &quot;translationX&quot;, 0, 90),</div><div class="line">	ObjectAnimator.ofFloat(myView, &quot;translationY&quot;, 0, 90),</div><div class="line">	ObjectAnimator.ofFloat(myView, &quot;scaleX&quot;, 1, 1.5f),</div><div class="line">	ObjectAnimator.ofFloat(myView, &quot;scaleX&quot;, 1, 0.5f),</div><div class="line">	ObjectAnimator.ofFloat(myView, &quot;alpha&quot;, 1, 0.25, 1),);</div><div class="line">set.setDuration(5 * 1000).start();</div></pre></td></tr></table></figure>
<p>属性动画在XML定义就不在多讲，因为它不如直接在代码中写起来方便，当然如果多个对象使用同一个动画，写在XML里面更好。</p>
<h2 id="插值器和估值器"><a href="#插值器和估值器" class="headerlink" title="插值器和估值器"></a>插值器和估值器</h2><h3 id="插值器"><a href="#插值器" class="headerlink" title="插值器"></a>插值器</h3><p>插值器只是一个概念，系统中与之相关的类叫做 TimeInterpolator ，其只是一个接口，准确来说叫做“时间插值器”。该接口的注释为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A time interpolator defines the rate of change of an animation. This allows animations to have non-linear motion, such as acceleration and deceleration.</div></pre></td></tr></table></figure>
<p>意思是：该时间插值器定义了动画的变化率，允许动画做非线性的运动，比如加速、减速。</p>
<p>这样，插值器的主要作用我们就明白了。接下来，看看这个接口的代码，该接口只有一个接口方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param input A value between 0 and 1.0 indicating our current point</div><div class="line"> *        in the animation where 0 represents the start and 1.0 represents</div><div class="line"> *        the end</div><div class="line"> * @return The interpolation value. This value can be more than 1.0 for</div><div class="line"> *         interpolators which overshoot their targets, or less than 0 for</div><div class="line"> *         interpolators that undershoot their targets.</div><div class="line"> */</div><div class="line">float getInterpolation(float input);</div></pre></td></tr></table></figure></p>
<p>不管是系统内置的插值器，还是我们自定义插值器，只需要实现接口并重写该方法，就可以起到插值器的作用。</p>
<p>该方法的作用是什么呢？上图保留了源码中对方法的注释，我就不直译了，说下大概的意思：</p>
<p>方法参数 input 接收 0 和 1.0 之间的值表示动画的当前进度，是线性变化的，其中0表示开始，1.0表示结束；<br>返回值表示对 input 进行插值之后的值，我们就是在这儿做“手脚”，让返回值不再是线性的，就完成自己定义动画的变化率了。<br>TimeInterpolator中文翻译为时间插值器，它的作用是根据时间流逝的百分比来计算出当前属性值改变的百分比，系统预置的有LinearInterpolator（线性插值器：匀速动画）、AccelerateDecelerateInterpolator（加速减速插值器：动画两头慢中间快）和DecelerateInterpolator（减速插值器：动画越来越慢）等。</p>
<h3 id="估值器"><a href="#估值器" class="headerlink" title="估值器"></a>估值器</h3><p>TypeEvalutor等中文翻译为类型估值算法，也叫作估值器。估值器的是用来决定属性的计算方式，最终使用反射机制来改变属性变化。它的作用是根据当前属性改变的百分比来计算改变后的属性值。系统预置的有IntEvalutor（针对整形属性）、FloatEvalutor（针对浮点型属性）和ArgbEvalutor（针对color属性）。</p>
<h2 id="属性动画的监听"><a href="#属性动画的监听" class="headerlink" title="属性动画的监听"></a>属性动画的监听</h2><p>属性动画提供了监听器用于监听动画的播放过程，主要有如下两个接口AnimatorUpdateListener和AnimatorListener。<br>AnimatorListener的定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/**	</div><div class="line">    * &lt;p&gt;An animation listener receives notifications from an animation.</div><div class="line">    * Notifications indicate animation related events, such as the end or the</div><div class="line">    * repetition of the animation.&lt;/p&gt;</div><div class="line">    */</div><div class="line">   public static interface AnimatorListener &#123;</div><div class="line">       /**</div><div class="line">        * &lt;p&gt;Notifies the start of the animation.&lt;/p&gt;</div><div class="line">        *</div><div class="line">        * @param animation The started animation.</div><div class="line">        */</div><div class="line">       void onAnimationStart(Animator animation);</div><div class="line"></div><div class="line">       /**</div><div class="line">        * &lt;p&gt;Notifies the end of the animation. This callback is not invoked</div><div class="line">        * for animations with repeat count set to INFINITE.&lt;/p&gt;</div><div class="line">        *</div><div class="line">        * @param animation The animation which reached its end.</div><div class="line">        */</div><div class="line">       void onAnimationEnd(Animator animation);</div><div class="line"></div><div class="line">       /**</div><div class="line">        * &lt;p&gt;Notifies the cancellation of the animation. This callback is not invoked</div><div class="line">        * for animations with repeat count set to INFINITE.&lt;/p&gt;</div><div class="line">        *</div><div class="line">        * @param animation The animation which was canceled.</div><div class="line">        */</div><div class="line">       void onAnimationCancel(Animator animation);</div><div class="line"></div><div class="line">       /**</div><div class="line">        * &lt;p&gt;Notifies the repetition of the animation.&lt;/p&gt;</div><div class="line">        *</div><div class="line">        * @param animation The animation which was repeated.</div><div class="line">        */</div><div class="line">       void onAnimationRepeat(Animator animation);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>AnimatorUpdateListener的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Implementors of this interface can add themselves as update listeners</div><div class="line">     * to an &lt;code&gt;ValueAnimator&lt;/code&gt; instance to receive callbacks on every animation</div><div class="line">     * frame, after the current frame&apos;s values have been calculated for that</div><div class="line">     * &lt;code&gt;ValueAnimator&lt;/code&gt;.</div><div class="line">     */</div><div class="line">    public static interface AnimatorUpdateListener &#123;</div><div class="line">        /**</div><div class="line">         * &lt;p&gt;Notifies the occurrence of another frame of the animation.&lt;/p&gt;</div><div class="line">         *</div><div class="line">         * @param animation The animation which was repeated.</div><div class="line">         */</div><div class="line">        void onAnimationUpdate(ValueAnimator animation);</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="对任意属性做动画"><a href="#对任意属性做动画" class="headerlink" title="对任意属性做动画"></a>对任意属性做动画</h2><p>比如我们用属性动画对Button做宽度的增加，会首先想到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator.ofInt(mButton, &quot;width&quot;, 500).setDuration(5000).start();</div></pre></td></tr></table></figure>
<p>上述代码运行后会发现没有效果，其实没有效果是正常现象，因为如果随便传一个属性（例如width）轻则没有动画效果，重则程序直接crash。<br>下面分析属性动画的原理：<strong>属性动画要求动画的作用对象提供该属性的get和set方法，属性动画根据该属性的初始值和最终值，以动画的效果多次去调用set方法，每次传递给set方法等值都不一样，确切的来说是随着时间的推移，所传递的值越来越接近最终值</strong></p>
<ol>
<li>作用对象必须提供该属性的get和set方法</li>
<li>作用对象的set方法必须要能使UI效果改变，否则动画无效果</li>
</ol>
<p>那么为什么我们对Button的width属性做动画会没有效果呢？这是因为虽然Button内部提供了getWidth和setWidth方法，但是这个setWidth方法并不是改变视图的大小，它是TextView新添加的方法，View是没有setWidth这个方法的。由于Button继承TextView，所以Button有setWidth方法，来看一下setWidth和getWidth方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Makes the TextView exactly this many pixels wide.</div><div class="line">     * You could do the same thing by specifying this number in the</div><div class="line">     * LayoutParams.</div><div class="line">     *</div><div class="line">     * @see #setMaxWidth(int)</div><div class="line">     * @see #setMinWidth(int)</div><div class="line">     * @see #getMinWidth()</div><div class="line">     * @see #getMaxWidth()</div><div class="line">     *</div><div class="line">     * @attr ref android.R.styleable#TextView_width</div><div class="line">     */</div><div class="line">    @android.view.RemotableViewMethod</div><div class="line">    public void setWidth(int pixels) &#123;</div><div class="line">        mMaxWidth = mMinWidth = pixels;</div><div class="line">        mMaxWidthMode = mMinWidthMode = PIXELS;</div><div class="line"></div><div class="line">        requestLayout();</div><div class="line">        invalidate();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * Return the width of the your view.</div><div class="line">     *</div><div class="line">     * @return The width of your view, in pixels.</div><div class="line">     */</div><div class="line">    @ViewDebug.ExportedProperty(category = &quot;layout&quot;)</div><div class="line">    public final int getWidth() &#123;</div><div class="line">        return mRight - mLeft;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从上述源码中可以看出，getWidth的确是获取View的宽度，而setWidth是TextView和其子类的专属方法，它的作用不是设置宽度，而是设置最大宽度和最小宽度的。具体来说在布局XML中android:layout_width对应宽度，android:width对应最大最小宽度。所以setWidth无法改变控件的宽度。<br>针对上述问题，官方告诉我们有三种解决方法</p>
<ul>
<li>给你的对象加上set和get方法，如果你有权限的话</li>
<li>用一个类来包装原始对象，间接为其提供set和get方法</li>
<li>采用ValueAnimator，监听动画的过程，自己实现属性的改变。</li>
</ul>
<p>针对以上解决方法，结合实际情况我们得出，Button设置宽度无法使用第一种方法，因为我们没有权限更改它的源码。所以我们可以采用第二种和第三种解决方法。</p>
<p>采用第二种解决方法，创建包裹类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * 改变宽度</div><div class="line">    */</div><div class="line">   private void changeWidth()&#123;</div><div class="line">       ViewWrapper wrapper = new ViewWrapper(mButton);</div><div class="line">       ObjectAnimator.ofInt(wrapper, &quot;width&quot;, 500).setDuration(5000).start();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   /**</div><div class="line">    * 用于包裹类</div><div class="line">    */</div><div class="line">   private static class ViewWrapper&#123;</div><div class="line">       private View mTarget;</div><div class="line"></div><div class="line">       public ViewWrapper(View target)&#123;</div><div class="line">           this.mTarget = target;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       public int getWidth()&#123;</div><div class="line">           return mTarget.getLayoutParams().width;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       public void setWidth(int width)&#123;</div><div class="line">           mTarget.getLayoutParams().width = width;</div><div class="line">           mTarget.requestLayout();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>采用第三种解决方法，利用ValueAnimator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    *</div><div class="line">    * @param target 要改变的目标View</div><div class="line">    * @param start 开始的宽度</div><div class="line">    * @param end   结束的宽度</div><div class="line">    */</div><div class="line">   private void performAnimte(final View target, final int start, final int end)&#123;</div><div class="line">       ValueAnimator valueAnimator = ValueAnimator.ofInt(1, 100);</div><div class="line">       valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">           private IntEvaluator mEvaluator = new IntEvaluator();</div><div class="line">           @Override</div><div class="line">           public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">               // 获取当前动画的进度</div><div class="line">               int currentValue = (int) animation.getAnimatedFraction();</div><div class="line">               // 获取当前进度占整个动画的比例</div><div class="line">               float fraction = animation.getAnimatedFraction();</div><div class="line">               // 直接调用整型估值器，通过比例计算出宽度，然后赋值</div><div class="line">               target.getLayoutParams().width = mEvaluator.evaluate(fraction, start, end);</div><div class="line">               target.requestLayout();</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       valueAnimator.setDuration(5000).start();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="属性动画的工作原理"><a href="#属性动画的工作原理" class="headerlink" title="属性动画的工作原理"></a>属性动画的工作原理</h2><p>属性动画要求动画作用的对象提供该属性的set方法，属性动画根据你传递的该属性的初始值和最终值，以动画的效果多次去调用set方法。每次传递给set方法的值都不一样，确切的来说是随着时间的推移，所传递的值越来越接近最终值。如果动画的时候没有传递初始值，那么还要提供get方法，因为系统要去获取属性的初始值。对于属性动画来说，其动画过程中所做的就是这么多。</p>
<h2 id="使用动画的注意事项"><a href="#使用动画的注意事项" class="headerlink" title="使用动画的注意事项"></a>使用动画的注意事项</h2><ol>
<li>内存泄漏：在属性动画中有一类无限循环的动画，这类动画需要在Activity退出时及时停止，否则将导致Activity无法释放从而造成内存泄漏，View动画并不存在这种现象。</li>
<li>兼容性问题：动画在3.0以下的系统上存在兼容性问题，现在android系统大部分都是4.0的</li>
<li>不要使用px：在进行动画的过程中，要尽量使用dp，使用px会导致在不同的设备上有不同的效果</li>
<li>硬件加速：使用动画的过程中建议开启硬件加速，这样会提高动画的流畅性。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2017/01/06/Rxjava操作符大全/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/06/Rxjava操作符大全/" itemprop="url">
                  Rxjava操作符大全
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-06T18:19:52+08:00">
                2017-01-06
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="创建操作"><a href="#创建操作" class="headerlink" title="创建操作"></a>创建操作</h2><h3 id="以下操作符用于创建Observable。"><a href="#以下操作符用于创建Observable。" class="headerlink" title="以下操作符用于创建Observable。"></a>以下操作符用于创建Observable。</h3><h4 id="create：-使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe-call方法中检查订阅状态，以便及时停止发射数据或者运算。"><a href="#create：-使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe-call方法中检查订阅状态，以便及时停止发射数据或者运算。" class="headerlink" title="create： 使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe#call方法中检查订阅状态，以便及时停止发射数据或者运算。"></a>create： 使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe#call方法中检查订阅状态，以便及时停止发射数据或者运算。</h4><pre><code>Observable.create(new Observable.OnSubscribe&lt;String&gt;() {

    @Override
    public void call(Subscriber&lt;? super String&gt; subscriber) {

        subscriber.onNext(&quot;item1&quot;);
        subscriber.onNext(&quot;item2&quot;);
        subscriber.onCompleted();
    }
});
</code></pre><h4 id="from：-将一个Iterable-一个Future-或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。"><a href="#from：-将一个Iterable-一个Future-或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。" class="headerlink" title="from： 将一个Iterable, 一个Future, 或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。"></a>from： 将一个Iterable, 一个Future, 或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。</h4><p><img src="http://static.zybuluo.com/maplejaw/1a7gi8os6u4kgk7aahzmj1d0/image_1arcl6d0a1iej60e6ccp48qic9.png" alt="Markdown preferences pane"></p>
<pre><code>//Iterable
List&lt;String&gt; list=new ArrayList&lt;&gt;();
...
Observable.from(list)
        .subscribe(new Action1&lt;String&gt;() {
    @Override
    public void call(String s) {

    }
});

//Future
 Future&lt;String&gt; futrue= Executors.newSingleThreadExecutor().submit(new Callable&lt;String&gt;() {

    @Override
    public String call() throws Exception {
        Thread.sleep(1000);
        return &quot;maplejaw&quot;;
    }
});

Observable.from(futrue)
          .subscribe(new Action1&lt;String&gt;() {
    @Override
    public void call(String s) {

    }
});
</code></pre><h4 id="just：-将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。"><a href="#just：-将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。" class="headerlink" title="just： 将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。"></a>just： 将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。</h4><h4 id="empty：-创建一个什么都不做直接通知完成的Observable"><a href="#empty：-创建一个什么都不做直接通知完成的Observable" class="headerlink" title="empty： 创建一个什么都不做直接通知完成的Observable"></a>empty： 创建一个什么都不做直接通知完成的Observable</h4><h4 id="error：-创建一个什么都不做直接通知错误的Observable"><a href="#error：-创建一个什么都不做直接通知错误的Observable" class="headerlink" title="error： 创建一个什么都不做直接通知错误的Observable"></a>error： 创建一个什么都不做直接通知错误的Observable</h4><h4 id="never：-创建一个什么都不做的Observable"><a href="#never：-创建一个什么都不做的Observable" class="headerlink" title="never： 创建一个什么都不做的Observable"></a>never： 创建一个什么都不做的Observable</h4><pre><code>Observable observable1=Observable.empty();//直接调用onCompleted。
Observable observable2=Observable.error(new RuntimeException());//直接调用onError。这里可以自定义异常
Observable observable3=Observable.never();//啥都不做
</code></pre><h4 id="timer：-创建一个在给定的延时之后发射数据项为0的Observable-内部通过OnSubscribeTimerOnce工作"><a href="#timer：-创建一个在给定的延时之后发射数据项为0的Observable-内部通过OnSubscribeTimerOnce工作" class="headerlink" title="timer： 创建一个在给定的延时之后发射数据项为0的Observable,内部通过OnSubscribeTimerOnce工作"></a>timer： 创建一个在给定的延时之后发射数据项为0的Observable<long>,内部通过OnSubscribeTimerOnce工作</long></h4><pre><code>Observable.timer(1000,TimeUnit.MILLISECONDS)
        .subscribe(new Action1&lt;Long&gt;() {
            @Override
            public void call(Long aLong) {
                Log.d(&quot;JG&quot;,aLong.toString()); // 0
            }
        });
</code></pre><h4 id="interval：-创建一个按照给定的时间间隔发射从0开始的整数序列的Observable，内部通过OnSubscribeTimerPeriodically工作。"><a href="#interval：-创建一个按照给定的时间间隔发射从0开始的整数序列的Observable，内部通过OnSubscribeTimerPeriodically工作。" class="headerlink" title="interval： 创建一个按照给定的时间间隔发射从0开始的整数序列的Observable，内部通过OnSubscribeTimerPeriodically工作。"></a>interval： 创建一个按照给定的时间间隔发射从0开始的整数序列的Observable<long>，内部通过OnSubscribeTimerPeriodically工作。</long></h4><pre><code>Observable.interval(1, TimeUnit.SECONDS)
        .subscribe(new Action1&lt;Long&gt;() {
            @Override
            public void call(Long aLong) {
                 //每隔1秒发送数据项，从0开始计数
                 //0,1,2,3....
            }
        });
</code></pre><h4 id="range：-创建一个发射指定范围的整数序列的Observable"><a href="#range：-创建一个发射指定范围的整数序列的Observable" class="headerlink" title="range： 创建一个发射指定范围的整数序列的Observable"></a>range： 创建一个发射指定范围的整数序列的Observable<integer></integer></h4><pre><code>Observable.range(2,5).subscribe(new Action1&lt;Integer&gt;() {
    @Override
    public void call(Integer integer) {
        Log.d(&quot;JG&quot;,integer.toString());// 2,3,4,5,6 从2开始发射5个数据
    }
});
</code></pre><h5 id="defer：-只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。"><a href="#defer：-只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。" class="headerlink" title="defer： 只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。"></a>defer： 只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。</h5><pre><code>Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() {
    @Override
    public Observable&lt;String&gt; call() {
        return Observable.just(&quot;hello&quot;);
    }
}).subscribe(new Action1&lt;String&gt;() {
    @Override
    public void call(String s) {
        Log.d(&quot;JG&quot;,s);
    }
});
</code></pre><h2 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h2><p>以下操作符用于组合多个Observable。</p>
<p>注意，为了使结构更加清晰以及缩小代码量，之后的例子部分地方将会使用Lambda表达式书写，如果你对Lambda表达式不太熟悉的话，可以阅读JAVA8 Lambda表达式完全解析这篇文章。</p>
<h4 id="concat：-按顺序连接多个Observables。需要注意的是Observable-concat-a-b-等价于a-concatWith-b-。"><a href="#concat：-按顺序连接多个Observables。需要注意的是Observable-concat-a-b-等价于a-concatWith-b-。" class="headerlink" title="concat： 按顺序连接多个Observables。需要注意的是Observable.concat(a,b)等价于a.concatWith(b)。"></a>concat： 按顺序连接多个Observables。需要注意的是Observable.concat(a,b)等价于a.concatWith(b)。</h4><pre><code>Observable&lt;Integer&gt; observable1=Observable.just(1,2,3,4);
Observable&lt;Integer&gt;  observable2=Observable.just(4,5,6);

Observable.concat(observable1,observable2)
        .subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString()));//1,2,3,4,4,5,6
</code></pre><h4 id="startWith：-在数据序列的开头增加一项数据。startWith的内部也是调用了concat"><a href="#startWith：-在数据序列的开头增加一项数据。startWith的内部也是调用了concat" class="headerlink" title="startWith： 在数据序列的开头增加一项数据。startWith的内部也是调用了concat"></a>startWith： 在数据序列的开头增加一项数据。startWith的内部也是调用了concat</h4><pre><code>Observable.just(1,2,3,4,5)
        .startWith(6,7,8)
.subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString()));//6,7,8,1,2,3,4,5
</code></pre><h4 id="merge：-将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。"><a href="#merge：-将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。" class="headerlink" title="merge： 将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。"></a>merge： 将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。</h4><h4 id="zip：-使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过OperatorZip进行压合。"><a href="#zip：-使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过OperatorZip进行压合。" class="headerlink" title="zip： 使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过OperatorZip进行压合。"></a>zip： 使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过OperatorZip进行压合。</h4><p>Observable<integer>  observable1=Observable.just(1,2,3,4);<br>Observable<integer>  observable2=Observable.just(4,5,6);</integer></integer></p>
<pre><code>Observable.zip(observable1, observable2, new Func2&lt;Integer, Integer, String&gt;() {
    @Override
    public String call(Integer item1, Integer item2) {
        return item1+&quot;and&quot;+item2;
    }
})
.subscribe(item-&gt;Log.d(&quot;JG&quot;,item)); //1and4,2and5,3and6
</code></pre><h4 id="combineLatest：-当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable最近的数据压合。具体请看下面流程图。"><a href="#combineLatest：-当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable最近的数据压合。具体请看下面流程图。" class="headerlink" title="combineLatest： 当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable最近的数据压合。具体请看下面流程图。"></a>combineLatest： 当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable最近的数据压合。具体请看下面流程图。</h4><p>zip工作流程<br><img src="http://static.zybuluo.com/maplejaw/bu67z13p279yu074arzslsyd/image_1ard6160913ui3r6orodc41pntm.png" alt="Markdown preferences pane"></p>
<p>combineLatest工作流程<br><img src="http://static.zybuluo.com/maplejaw/tuo7jn6ijtzsa1c3ak77umtu/image_1ard609fsi3p9n7160iq0r1rqe9.png" alt="Markdown preferences pane"></p>
<h2 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h2><h4 id="filter：-过滤数据。内部通过OnSubscribeFilter过滤数据。"><a href="#filter：-过滤数据。内部通过OnSubscribeFilter过滤数据。" class="headerlink" title="filter： 过滤数据。内部通过OnSubscribeFilter过滤数据。"></a>filter： 过滤数据。内部通过OnSubscribeFilter过滤数据。</h4><pre><code>Observable.just(3,4,5,6)
        .filter(new Func1&lt;Integer, Boolean&gt;() {
            @Override
            public Boolean call(Integer integer) {
                return integer&gt;4;
            }
        })
.subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString())); //5,6 
</code></pre><h4 id="ofType：-过滤指定类型的数据，与filter类似，"><a href="#ofType：-过滤指定类型的数据，与filter类似，" class="headerlink" title="ofType： 过滤指定类型的数据，与filter类似，"></a>ofType： 过滤指定类型的数据，与filter类似，</h4><pre><code>Observable.just(1,2,&quot;3&quot;)
        .ofType(Integer.class)
        .subscribe(item -&gt; Log.d(&quot;JG&quot;,item.toString()));
</code></pre><h4 id="take：-只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。"><a href="#take：-只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。" class="headerlink" title="take： 只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。"></a>take： 只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。</h4><pre><code>Observable.just(3,4,5,6)
        .take(3)//发射前三个数据项
        .take(100, TimeUnit.MILLISECONDS)//发射100ms内的数据
</code></pre><h4 id="takeLast：-只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。"><a href="#takeLast：-只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。" class="headerlink" title="takeLast： 只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。"></a>takeLast： 只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。</h4><pre><code>Observable.just(3,4,5,6)
        .takeLast(3)
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));//4,5,6
</code></pre><h4 id="takeFirst：提取满足条件的第一项。内部实现源码如下："><a href="#takeFirst：提取满足条件的第一项。内部实现源码如下：" class="headerlink" title="takeFirst：提取满足条件的第一项。内部实现源码如下："></a>takeFirst：提取满足条件的第一项。内部实现源码如下：</h4><pre><code>public final Observable&lt;T&gt; takeFirst(Func1&lt;? super T, Boolean&gt; predicate) {
  return filter(predicate).take(1); //先过滤，后提取
}
</code></pre><h4 id="first-firstOrDefault：只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。"><a href="#first-firstOrDefault：只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。" class="headerlink" title="first/firstOrDefault：只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。"></a>first/firstOrDefault：只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。</h4><pre><code>Observable.just(3,4,5,6)
        .first()
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));//3

Observable.just(3,4,5,6)
           .first(new Func1&lt;Integer, Boolean&gt;() {
               @Override
               public Boolean call(Integer integer) {
                   return integer&gt;3;
               }
           }) .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));//4
</code></pre><h4 id="last-lastOrDefault：只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。"><a href="#last-lastOrDefault：只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。" class="headerlink" title="last/lastOrDefault：只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。"></a>last/lastOrDefault：只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。</h4><h4 id="skip：跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。"><a href="#skip：跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。" class="headerlink" title="skip：跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。"></a>skip：跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。</h4><pre><code>Observable.just(3,4,5,6)
           .skip(1)
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));//4,5,6
</code></pre><h4 id="skipLast：跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。"><a href="#skipLast：跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。" class="headerlink" title="skipLast：跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。"></a>skipLast：跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。</h4><h4 id="elementAt-elementAtOrDefault：发射某一项数据，如果超过了范围可以的指定默认值。内部通过OperatorElementAt过滤。"><a href="#elementAt-elementAtOrDefault：发射某一项数据，如果超过了范围可以的指定默认值。内部通过OperatorElementAt过滤。" class="headerlink" title="elementAt/elementAtOrDefault：发射某一项数据，如果超过了范围可以的指定默认值。内部通过OperatorElementAt过滤。"></a>elementAt/elementAtOrDefault：发射某一项数据，如果超过了范围可以的指定默认值。内部通过OperatorElementAt过滤。</h4><pre><code>Observable.just(3,4,5,6)
         .elementAt(2)
.subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString())); //5
</code></pre><h4 id="ignoreElements：丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。"><a href="#ignoreElements：丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。" class="headerlink" title="ignoreElements：丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。"></a>ignoreElements：丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。</h4><h4 id="distinct：过滤重复数据，内部通过OperatorDistinct实现。"><a href="#distinct：过滤重复数据，内部通过OperatorDistinct实现。" class="headerlink" title="distinct：过滤重复数据，内部通过OperatorDistinct实现。"></a>distinct：过滤重复数据，内部通过OperatorDistinct实现。</h4><pre><code>Observable.just(3,4,5,6,3,3,4,9)
   .distinct()
  .subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString())); //3,4,5,6,9
</code></pre><h4 id="distinctUntilChanged：过滤掉连续重复的数据。内部通过OperatorDistinctUntilChanged实现"><a href="#distinctUntilChanged：过滤掉连续重复的数据。内部通过OperatorDistinctUntilChanged实现" class="headerlink" title="distinctUntilChanged：过滤掉连续重复的数据。内部通过OperatorDistinctUntilChanged实现"></a>distinctUntilChanged：过滤掉连续重复的数据。内部通过OperatorDistinctUntilChanged实现</h4><pre><code>Observable.just(3,4,5,6,3,3,4,9)
   .distinctUntilChanged()
  .subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString())); //3,4,5,6,3,4,9
</code></pre><h4 id="throttleFirst：定期发射Observable发射的第一项数据。内部通过OperatorThrottleFirst实现。"><a href="#throttleFirst：定期发射Observable发射的第一项数据。内部通过OperatorThrottleFirst实现。" class="headerlink" title="throttleFirst：定期发射Observable发射的第一项数据。内部通过OperatorThrottleFirst实现。"></a>throttleFirst：定期发射Observable发射的第一项数据。内部通过OperatorThrottleFirst实现。</h4><pre><code>Observable.create(subscriber -&gt; {
    subscriber.onNext(1);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(2);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }

    subscriber.onNext(3);
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(4);
    subscriber.onNext(5);
    subscriber.onCompleted();

}).throttleFirst(999, TimeUnit.MILLISECONDS)
        .subscribe(item-&gt; Log.d(&quot;JG&quot;,item.toString())); //结果为1,3,4
</code></pre><h4 id="throttleWithTimeout-debounce：发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据-直到指定时间内都没有新数据发射时"><a href="#throttleWithTimeout-debounce：发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据-直到指定时间内都没有新数据发射时" class="headerlink" title="throttleWithTimeout/debounce：发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据,直到指定时间内都没有新数据发射时"></a>throttleWithTimeout/debounce：发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据,直到指定时间内都没有新数据发射时</h4><p>才进行发射</p>
<pre><code>Observable.create(subscriber -&gt; {
    subscriber.onNext(1);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(2);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }

    subscriber.onNext(3);
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(4);
    subscriber.onNext(5);
    subscriber.onCompleted();

}).debounce(999, TimeUnit.MILLISECONDS)//或者为throttleWithTimeout(1000, TimeUnit.MILLISECONDS)
        .subscribe(item-&gt; Log.d(&quot;JG&quot;,item.toString())); //结果为3,5
</code></pre><h4 id="sample-throttleLast：定期发射Observable最近的数据。内部通过OperatorSampleWithTime实现。"><a href="#sample-throttleLast：定期发射Observable最近的数据。内部通过OperatorSampleWithTime实现。" class="headerlink" title="sample/throttleLast：定期发射Observable最近的数据。内部通过OperatorSampleWithTime实现。"></a>sample/throttleLast：定期发射Observable最近的数据。内部通过OperatorSampleWithTime实现。</h4><pre><code>Observable.create(subscriber -&gt; {
    subscriber.onNext(1);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(2);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }

    subscriber.onNext(3);
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(4);
    subscriber.onNext(5);
    subscriber.onCompleted();

}).sample(999, TimeUnit.MILLISECONDS)//或者为throttleLast(1000, TimeUnit.MILLISECONDS)
        .subscribe(item-&gt; Log.d(&quot;JG&quot;,item.toString())); //结果为2,3,5
</code></pre><h4 id="timeout：-如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。"><a href="#timeout：-如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。" class="headerlink" title="timeout： 如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。"></a>timeout： 如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。</h4><pre><code>Observable.create(( subscriber) -&gt; {
    subscriber.onNext(1);
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(2);

    subscriber.onCompleted();

}).timeout(999, TimeUnit.MILLISECONDS,Observable.just(99,100))//如果不指定备用Observable将会抛出异常
        .subscribe(item-&gt; Log.d(&quot;JG&quot;,item.toString()),error-&gt;Log.d(&quot;JG&quot;,&quot;onError&quot;)); //结果为1,99,100  如果不指定备用Observable结果为1,onError
}
</code></pre><h3 id="条件-布尔操作"><a href="#条件-布尔操作" class="headerlink" title="条件/布尔操作"></a>条件/布尔操作</h3><h4 id="all：-判断所有的数据项是否满足某个条件，内部通过OperatorAll实现。"><a href="#all：-判断所有的数据项是否满足某个条件，内部通过OperatorAll实现。" class="headerlink" title="all： 判断所有的数据项是否满足某个条件，内部通过OperatorAll实现。"></a>all： 判断所有的数据项是否满足某个条件，内部通过OperatorAll实现。</h4><pre><code>Observable.just(2,3,4,5)
        .all(new Func1&lt;Integer, Boolean&gt;() {
            @Override
            public Boolean call(Integer integer) {
                return integer&gt;3;
            }
        })
.subscribe(new Action1&lt;Boolean&gt;() {
    @Override
    public void call(Boolean aBoolean) {
        Log.d(&quot;JG&quot;,aBoolean.toString()); //false
    }
})
;
</code></pre><h4 id="exists：-判断是否存在数据项满足某个条件。内部通过OperatorAny实现。"><a href="#exists：-判断是否存在数据项满足某个条件。内部通过OperatorAny实现。" class="headerlink" title="exists： 判断是否存在数据项满足某个条件。内部通过OperatorAny实现。"></a>exists： 判断是否存在数据项满足某个条件。内部通过OperatorAny实现。</h4><pre><code>Observable.just(2,3,4,5)
        .exists(integer -&gt; integer&gt;3)
        .subscribe(aBoolean -&gt; Log.d(&quot;JG&quot;,aBoolean.toString())); //true
</code></pre><h4 id="contains：-判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是exists"><a href="#contains：-判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是exists" class="headerlink" title="contains： 判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是exists"></a>contains： 判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是exists</h4><pre><code>Observable.just(2,3,4,5)
        .contains(3)
        .subscribe(aBoolean -&gt; Log.d(&quot;JG&quot;,aBoolean.toString())); //true
</code></pre><h4 id="sequenceEqual：-用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。"><a href="#sequenceEqual：-用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。" class="headerlink" title="sequenceEqual： 用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。"></a>sequenceEqual： 用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。</h4><pre><code>Observable.sequenceEqual(Observable.just(2,3,4,5),Observable.just(2,3,4,5))
        .subscribe(aBoolean -&gt; Log.d(&quot;JG&quot;,aBoolean.toString()));//true
</code></pre><h4 id="isEmpty：-用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。"><a href="#isEmpty：-用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。" class="headerlink" title="isEmpty： 用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。"></a>isEmpty： 用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。</h4><pre><code>Observable.just(3,4,5,6)
           .isEmpty()
          .subscribe(item -&gt; Log.d(&quot;JG&quot;,item.toString()));//false
</code></pre><p>amb： 给定多个Observable，只让第一个发射数据的Observable发射全部数据，其他Observable将会被忽略。</p>
<pre><code>Observable&lt;Integer&gt; observable1=Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() {
    @Override
    public void call(Subscriber&lt;? super Integer&gt; subscriber) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            subscriber.onError(e);
        }
        subscriber.onNext(1);
        subscriber.onNext(2);
        subscriber.onCompleted();
    }
}).subscribeOn(Schedulers.computation());

Observable&lt;Integer&gt; observable2=Observable.create(subscriber -&gt; {
    subscriber.onNext(3);
    subscriber.onNext(4);
    subscriber.onCompleted();
});

Observable.amb(observable1,observable2)
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString())); //3,4
</code></pre><h4 id="switchIfEmpty：-如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。"><a href="#switchIfEmpty：-如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。" class="headerlink" title="switchIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。"></a>switchIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。</h4><pre><code>Observable.empty()
        .switchIfEmpty(Observable.just(2,3,4))
.subscribe(o -&gt; Log.d(&quot;JG&quot;,o.toString())); //2,3,4
</code></pre><h4 id="defaultIfEmpty：-如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值-内部调用的switchIfEmpty。"><a href="#defaultIfEmpty：-如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值-内部调用的switchIfEmpty。" class="headerlink" title="defaultIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值,内部调用的switchIfEmpty。"></a>defaultIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值,内部调用的switchIfEmpty。</h4><h4 id="takeUntil：-当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据。"><a href="#takeUntil：-当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据。" class="headerlink" title="takeUntil： 当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据。"></a>takeUntil： 当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据。</h4><pre><code>Observable.just(2,3,4,5)
        .takeUntil(new Func1&lt;Integer, Boolean&gt;() {
            @Override
            public Boolean call(Integer integer) {
                return integer==4;
            }
        }).subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString())); //2,3,4
</code></pre><h4 id="takeWhile：-当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。"><a href="#takeWhile：-当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。" class="headerlink" title="takeWhile： 当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。"></a>takeWhile： 当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。</h4><pre><code>Observable.just(2,3,4,5)
        .takeWhile(new Func1&lt;Integer, Boolean&gt;() {
            @Override
            public Boolean call(Integer integer) {
                return integer==4;
            }
        })
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString())); //2,3
</code></pre><h4 id="skipUntil：-丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）"><a href="#skipUntil：-丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）" class="headerlink" title="skipUntil： 丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）"></a>skipUntil： 丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）</h4><h4 id="skipWhile：-丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）"><a href="#skipWhile：-丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）" class="headerlink" title="skipWhile： 丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）"></a>skipWhile： 丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）</h4><h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><h4 id="reduce：-对序列使用reduce-函数并发射最终的结果-内部使用OnSubscribeReduce实现。"><a href="#reduce：-对序列使用reduce-函数并发射最终的结果-内部使用OnSubscribeReduce实现。" class="headerlink" title="reduce： 对序列使用reduce()函数并发射最终的结果,内部使用OnSubscribeReduce实现。"></a>reduce： 对序列使用reduce()函数并发射最终的结果,内部使用OnSubscribeReduce实现。</h4><pre><code>Observable.just(2,3,4,5)
        .reduce(new Func2&lt;Integer, Integer, Integer&gt;() {
            @Override
            public Integer call(Integer sum, Integer item) {
                return sum+item;
            }
        })
</code></pre><h4 id="collect：-使用collect收集数据到一个可变的数据结构。"><a href="#collect：-使用collect收集数据到一个可变的数据结构。" class="headerlink" title="collect： 使用collect收集数据到一个可变的数据结构。"></a>collect： 使用collect收集数据到一个可变的数据结构。</h4><pre><code>Observable.just(3,4,5,6)
           .collect(new Func0&lt;List&lt;Integer&gt;&gt;() { //创建数据结构

               @Override
               public List&lt;Integer&gt; call() {
                   return new ArrayList&lt;Integer&gt;();
               }
           }, new Action2&lt;List&lt;Integer&gt;, Integer&gt;() { //收集器
               @Override
               public void call(List&lt;Integer&gt; integers, Integer integer) {
                   integers.add(integer);
               }
           })
          .subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {
              @Override
              public void call(List&lt;Integer&gt; integers) {

              }
          });
</code></pre><h4 id="count-countLong：-计算发射的数量，内部调用的是reduce"><a href="#count-countLong：-计算发射的数量，内部调用的是reduce" class="headerlink" title="count/countLong： 计算发射的数量，内部调用的是reduce."></a>count/countLong： 计算发射的数量，内部调用的是reduce.</h4><h2 id="转换操作"><a href="#转换操作" class="headerlink" title="转换操作"></a>转换操作</h2><h4 id="toList：-收集原始Observable发射的所有数据到一个列表，然后返回这个列表"><a href="#toList：-收集原始Observable发射的所有数据到一个列表，然后返回这个列表" class="headerlink" title="toList： 收集原始Observable发射的所有数据到一个列表，然后返回这个列表."></a>toList： 收集原始Observable发射的所有数据到一个列表，然后返回这个列表.</h4><pre><code>Observable.just(2,3,4,5)
        .toList()
        .subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {
            @Override
            public void call(List&lt;Integer&gt; integers) {

            }
        });
</code></pre><h4 id="toSortedList：-收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表。"><a href="#toSortedList：-收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表。" class="headerlink" title="toSortedList： 收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表。"></a>toSortedList： 收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表。</h4><pre><code>Observable.just(6,2,3,4,5)
        .toSortedList(new Func2&lt;Integer, Integer, Integer&gt;() {//自定义排序
            @Override
            public Integer call(Integer integer, Integer integer2) {
                return integer-integer2; //&gt;0 升序 ，&lt;0 降序
            }
        })
        .subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {
            @Override
            public void call(List&lt;Integer&gt; integers) {
                Log.d(&quot;JG&quot;,integers.toString()); // [2, 3, 4, 5, 6]
            }
        });
</code></pre><h4 id="toMap：-将序列数据转换为一个Map。我们可以根据数据项生成key和生成value。"><a href="#toMap：-将序列数据转换为一个Map。我们可以根据数据项生成key和生成value。" class="headerlink" title="toMap： 将序列数据转换为一个Map。我们可以根据数据项生成key和生成value。"></a>toMap： 将序列数据转换为一个Map。我们可以根据数据项生成key和生成value。</h4><pre><code>Observable.just(6,2,3,4,5)
        .toMap(new Func1&lt;Integer, String&gt;() {
            @Override
            public String call(Integer integer) {
                return &quot;key：&quot; + integer; //根据数据项生成map的key
            }
        }, new Func1&lt;Integer, String&gt;() {
            @Override
            public String call(Integer integer) {
                return &quot;value：&quot;+integer; //根据数据项生成map的kvalue
            }
        }).subscribe(new Action1&lt;Map&lt;String, String&gt;&gt;() {
    @Override
    public void call(Map&lt;String, String&gt; stringStringMap) {
        Log.d(&quot;JG&quot;,stringStringMap.toString()); // {key：6=value：6, key：5=value：5, key：4=value：4, key：2=value：2, key：3=value：3}
    }
});
</code></pre><h4 id="toMultiMap：-类似于toMap，不同的地方在于map的value是一个集合。"><a href="#toMultiMap：-类似于toMap，不同的地方在于map的value是一个集合。" class="headerlink" title="toMultiMap： 类似于toMap，不同的地方在于map的value是一个集合。"></a>toMultiMap： 类似于toMap，不同的地方在于map的value是一个集合。</h4><h2 id="变换操作"><a href="#变换操作" class="headerlink" title="变换操作"></a>变换操作</h2><h4 id="map：-对Observable发射的每一项数据都应用一个函数来变换。"><a href="#map：-对Observable发射的每一项数据都应用一个函数来变换。" class="headerlink" title="map： 对Observable发射的每一项数据都应用一个函数来变换。"></a>map： 对Observable发射的每一项数据都应用一个函数来变换。</h4><pre><code>Observable.just(6,2,3,4,5)
        .map(integer -&gt; &quot;item:&quot;+integer)
        .subscribe(s -&gt; Log.d(&quot;JG&quot;,s));//item:6,item:2....
</code></pre><h4 id="cast：-在发射之前强制将Observable发射的所有数据转换为指定类型"><a href="#cast：-在发射之前强制将Observable发射的所有数据转换为指定类型" class="headerlink" title="cast： 在发射之前强制将Observable发射的所有数据转换为指定类型"></a>cast： 在发射之前强制将Observable发射的所有数据转换为指定类型</h4><h4 id="flatMap：-将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。"><a href="#flatMap：-将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。" class="headerlink" title="flatMap： 将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。"></a>flatMap： 将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。</h4><pre><code>   Observable.just(2,3,5)
        .flatMap(new Func1&lt;Integer, Observable&lt;String&gt;&gt;() {
            @Override
            public Observable&lt;String&gt; call(Integer integer) {
                return Observable.create(subscriber -&gt; {
                    subscriber.onNext(integer*10+&quot;&quot;);
                    subscriber.onNext(integer*100+&quot;&quot;);
                    subscriber.onCompleted();
                });
            }
        })
.subscribe(o -&gt; Log.d(&quot;JG&quot;,o)) //20,200,30,300,50,500
</code></pre><h4 id="flatMapIterable：-和flatMap的作用一样，只不过生成的是Iterable而不是Observable。"><a href="#flatMapIterable：-和flatMap的作用一样，只不过生成的是Iterable而不是Observable。" class="headerlink" title="flatMapIterable： 和flatMap的作用一样，只不过生成的是Iterable而不是Observable。"></a>flatMapIterable： 和flatMap的作用一样，只不过生成的是Iterable而不是Observable。</h4><pre><code>    Observable.just(2,3,5)
        .flatMapIterable(new Func1&lt;Integer, Iterable&lt;String&gt;&gt;() {
            @Override
            public Iterable&lt;String&gt; call(Integer integer) {
                return Arrays.asList(integer*10+&quot;&quot;,integer*100+&quot;&quot;);
            }
        }).subscribe(new Action1&lt;String&gt;() {
          @Override
          public void call(String s) {

          }
});
</code></pre><h4 id="concatMap：-类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。"><a href="#concatMap：-类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。" class="headerlink" title="concatMap： 类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。"></a>concatMap： 类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。</h4><h4 id="switchMap：-和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。"><a href="#switchMap：-和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。" class="headerlink" title="switchMap： 和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。"></a>switchMap： 和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。</h4><pre><code>Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() {

    @Override
    public void call(Subscriber&lt;? super Integer&gt; subscriber) {
        for(int i=1;i&lt;4;i++){
            subscriber.onNext(i);
            Utils.sleep(500,subscriber);//线程休眠500ms
        }

        subscriber.onCompleted();
    }
}).subscribeOn(Schedulers.newThread())
  .switchMap(new Func1&lt;Integer, Observable&lt;Integer&gt;&gt;() {
         @Override
       public Observable&lt;Integer&gt; call(Integer integer) {
               //每当接收到新的数据，之前的Observable将会被取消订阅
                return Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() {
                    @Override
                    public void call(Subscriber&lt;? super Integer&gt; subscriber) {
                        subscriber.onNext(integer*10);
                        Utils.sleep(500,subscriber);
                        subscriber.onNext(integer*100);
                        subscriber.onCompleted();
                    }
                }).subscribeOn(Schedulers.newThread());
            }
        })
        .subscribe(s -&gt; Log.d(&quot;JG&quot;,s.toString()));//10,20,30,300
</code></pre><h4 id="scan：-与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值。"><a href="#scan：-与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值。" class="headerlink" title="scan： 与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值。"></a>scan： 与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值。</h4><pre><code>Observable.just(2,3,5)
        .scan(new Func2&lt;Integer, Integer, Integer&gt;() {
            @Override
            public Integer call(Integer sum, Integer item) {
                return sum+item;
            }
        })
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString())) //2,5,10
</code></pre><h4 id="groupBy：-将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据。"><a href="#groupBy：-将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据。" class="headerlink" title="groupBy： 将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据。"></a>groupBy： 将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据。</h4><pre><code>Observable.just(2,3,5,6)
        .groupBy(new Func1&lt;Integer, String&gt;() {
            @Override
            public String call(Integer integer) {//分组
                return integer%2==0?&quot;偶数&quot;:&quot;奇数&quot;;
            }
        })
.subscribe(new Action1&lt;GroupedObservable&lt;String, Integer&gt;&gt;() {
    @Override
    public void call(GroupedObservable&lt;String, Integer&gt; o) {

        o.subscribe(new Action1&lt;Integer&gt;() {
            @Override
            public void call(Integer integer) {
                Log.d(&quot;JG&quot;,o.getKey()+&quot;:&quot;+integer.toString()); //偶数：2，奇数：3，...
            }
        });
    }
})
</code></pre><h4 id="buffer：-它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个"><a href="#buffer：-它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个" class="headerlink" title="buffer： 它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个"></a>buffer： 它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个</h4><pre><code>Observable.just(2,3,5,6)
        .buffer(3)
        .subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {
            @Override
            public void call(List&lt;Integer&gt; integers) {

            }
        })
</code></pre><h4 id="window：-定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。"><a href="#window：-定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。" class="headerlink" title="window： 定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。"></a>window： 定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。</h4><pre><code>Observable.just(2,3,5,6)
        .window(3)
        .subscribe(new Action1&lt;Observable&lt;Integer&gt;&gt;() {
            @Override
            public void call(Observable&lt;Integer&gt; integerObservable) {
                integerObservable.subscribe(new Action1&lt;Integer&gt;() {
                    @Override
                    public void call(Integer integer) {

                    }
                });
            }
        })
</code></pre><p>##错误处理/重试机制</p>
<h4 id="onErrorResumeNext：-当原始Observable在遇到错误时，使用备用Observable。。"><a href="#onErrorResumeNext：-当原始Observable在遇到错误时，使用备用Observable。。" class="headerlink" title="onErrorResumeNext： 当原始Observable在遇到错误时，使用备用Observable。。"></a>onErrorResumeNext： 当原始Observable在遇到错误时，使用备用Observable。。</h4><pre><code>Observable.just(1,&quot;2&quot;,3)
.cast(Integer.class)
.onErrorResumeNext(Observable.just(1,2,3))
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString())) //1,2,3
;
</code></pre><h4 id="onExceptionResumeNext：-当原始Observable在遇到异常时，使用备用的Observable。与onErrorResumeNext类似，区别在于onErrorResumeNext可以处理所有的错误，onExceptionResumeNext只能处理异常。"><a href="#onExceptionResumeNext：-当原始Observable在遇到异常时，使用备用的Observable。与onErrorResumeNext类似，区别在于onErrorResumeNext可以处理所有的错误，onExceptionResumeNext只能处理异常。" class="headerlink" title="onExceptionResumeNext： 当原始Observable在遇到异常时，使用备用的Observable。与onErrorResumeNext类似，区别在于onErrorResumeNext可以处理所有的错误，onExceptionResumeNext只能处理异常。"></a>onExceptionResumeNext： 当原始Observable在遇到异常时，使用备用的Observable。与onErrorResumeNext类似，区别在于onErrorResumeNext可以处理所有的错误，onExceptionResumeNext只能处理异常。</h4><h4 id="onErrorReturn：-当原始Observable在遇到错误时发射一个特定的数据。"><a href="#onErrorReturn：-当原始Observable在遇到错误时发射一个特定的数据。" class="headerlink" title="onErrorReturn： 当原始Observable在遇到错误时发射一个特定的数据。"></a>onErrorReturn： 当原始Observable在遇到错误时发射一个特定的数据。</h4><pre><code>Observable.just(1,&quot;2&quot;,3)
        .cast(Integer.class)
        .onErrorReturn(new Func1&lt;Throwable, Integer&gt;() {
            @Override
            public Integer call(Throwable throwable) {
                return 4;
            }
        }).subscribe(new Action1&lt;Integer&gt;() {
    @Override
    public void call(Integer integer) {
        Log.d(&quot;JG&quot;,integer.toString());1,4
    }
});
</code></pre><h4 id="retry：-当原始Observable在遇到错误时进行重试。"><a href="#retry：-当原始Observable在遇到错误时进行重试。" class="headerlink" title="retry： 当原始Observable在遇到错误时进行重试。"></a>retry： 当原始Observable在遇到错误时进行重试。</h4><pre><code>Observable.just(1,&quot;2&quot;,3)
.cast(Integer.class)
.retry(3)
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()),throwable -&gt; Log.d(&quot;JG&quot;,&quot;onError&quot;))
;//1,1,1,1,onError
</code></pre><h4 id="retryWhen：-当原始Observable在遇到错误，将错误传递给另一个Observable来决定是否要重新订阅这个Observable-内部调用的是retry。"><a href="#retryWhen：-当原始Observable在遇到错误，将错误传递给另一个Observable来决定是否要重新订阅这个Observable-内部调用的是retry。" class="headerlink" title="retryWhen： 当原始Observable在遇到错误，将错误传递给另一个Observable来决定是否要重新订阅这个Observable,内部调用的是retry。"></a>retryWhen： 当原始Observable在遇到错误，将错误传递给另一个Observable来决定是否要重新订阅这个Observable,内部调用的是retry。</h4><pre><code>Observable.just(1,&quot;2&quot;,3)
.cast(Integer.class)
.retryWhen(new Func1&lt;Observable&lt;? extends Throwable&gt;, Observable&lt;Long&gt;&gt;() {
    @Override
    public Observable&lt;Long&gt; call(Observable&lt;? extends Throwable&gt; observable) {
        return Observable.timer(1, TimeUnit.SECONDS);
    }
})
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()),throwable -&gt; Log.d(&quot;JG&quot;,&quot;onError&quot;));
//1,1
</code></pre><h2 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h2><h4 id="ConnectableObservable与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect-被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。"><a href="#ConnectableObservable与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect-被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。" class="headerlink" title="ConnectableObservable与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect()被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。"></a>ConnectableObservable与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect()被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。</h4><h4 id="ConnectableObservable-connect-指示一个可连接的Observable开始发射数据"><a href="#ConnectableObservable-connect-指示一个可连接的Observable开始发射数据" class="headerlink" title="ConnectableObservable.connect()指示一个可连接的Observable开始发射数据."></a>ConnectableObservable.connect()指示一个可连接的Observable开始发射数据.</h4><h4 id="Observable-publish-将一个Observable转换为一个可连接的Observable"><a href="#Observable-publish-将一个Observable转换为一个可连接的Observable" class="headerlink" title="Observable.publish()将一个Observable转换为一个可连接的Observable"></a>Observable.publish()将一个Observable转换为一个可连接的Observable</h4><h4 id="Observable-replay-确保所有的订阅者看到相同的数据序列的ConnectableObservable，即使它们在Observable开始发射数据之后才订阅。"><a href="#Observable-replay-确保所有的订阅者看到相同的数据序列的ConnectableObservable，即使它们在Observable开始发射数据之后才订阅。" class="headerlink" title="Observable.replay()确保所有的订阅者看到相同的数据序列的ConnectableObservable，即使它们在Observable开始发射数据之后才订阅。"></a>Observable.replay()确保所有的订阅者看到相同的数据序列的ConnectableObservable，即使它们在Observable开始发射数据之后才订阅。</h4><h4 id="ConnectableObservable-refCount-让一个可连接的Observable表现得像一个普通的Observable。"><a href="#ConnectableObservable-refCount-让一个可连接的Observable表现得像一个普通的Observable。" class="headerlink" title="ConnectableObservable.refCount()让一个可连接的Observable表现得像一个普通的Observable。"></a>ConnectableObservable.refCount()让一个可连接的Observable表现得像一个普通的Observable。</h4><pre><code>ConnectableObservable&lt;Integer&gt; co= Observable.just(1,2,3)
         .publish();

 co .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()) );
 co.connect();//此时开始发射数据
</code></pre><h2 id="阻塞操作"><a href="#阻塞操作" class="headerlink" title="阻塞操作"></a>阻塞操作</h2><h4 id="BlockingObservable是一个阻塞的Observable。普通的Observable-转换为BlockingObservable，可以使用-Observable-toBlocking-方法或者BlockingObservable-from-方法。内部通过CountDownLatch实现了阻塞操作。"><a href="#BlockingObservable是一个阻塞的Observable。普通的Observable-转换为BlockingObservable，可以使用-Observable-toBlocking-方法或者BlockingObservable-from-方法。内部通过CountDownLatch实现了阻塞操作。" class="headerlink" title="BlockingObservable是一个阻塞的Observable。普通的Observable 转换为BlockingObservable，可以使用 Observable.toBlocking( )方法或者BlockingObservable.from( )方法。内部通过CountDownLatch实现了阻塞操作。"></a>BlockingObservable是一个阻塞的Observable。普通的Observable 转换为BlockingObservable，可以使用 Observable.toBlocking( )方法或者BlockingObservable.from( )方法。内部通过CountDownLatch实现了阻塞操作。</h4><p>以下的操作符可以用于BlockingObservable，如果是普通的Observable，务必使用Observable.toBlocking()转为阻塞Observable后使用，否则达不到预期的效果。</p>
<h4 id="forEach：-对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。"><a href="#forEach：-对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。" class="headerlink" title="forEach： 对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。"></a>forEach： 对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。</h4><pre><code>Observable.just(2,3).observeOn(Schedulers.newThread()).toBlocking()
      .forEach(integer -&gt; {
          Log.d(&quot;JG&quot;,integer.toString()+&quot; &quot;+Thread.currentThread().getName());
          Utils.sleep(500);
      });

Log.d(&quot;JG&quot;,Thread.currentThread().getName());
// 2 RxNewThreadScheduler-1
// 3 RxNewThreadScheduler-1
// main
</code></pre><h4 id="first-firstOrDefault-last-lastOrDefault：这几个操作符之前有介绍过。也可以用于阻塞操作。"><a href="#first-firstOrDefault-last-lastOrDefault：这几个操作符之前有介绍过。也可以用于阻塞操作。" class="headerlink" title="first/firstOrDefault/last/lastOrDefault：这几个操作符之前有介绍过。也可以用于阻塞操作。"></a>first/firstOrDefault/last/lastOrDefault：这几个操作符之前有介绍过。也可以用于阻塞操作。</h4><h4 id="single-singleOrDefault：如果Observable终止时只发射了一个值，返回那个值，否则抛出异常或者发射默认值。"><a href="#single-singleOrDefault：如果Observable终止时只发射了一个值，返回那个值，否则抛出异常或者发射默认值。" class="headerlink" title="single/singleOrDefault：如果Observable终止时只发射了一个值，返回那个值，否则抛出异常或者发射默认值。"></a>single/singleOrDefault：如果Observable终止时只发射了一个值，返回那个值，否则抛出异常或者发射默认值。</h4><h4 id="mostRecent：返回一个总是返回Observable最近发射的数据的Iterable。"><a href="#mostRecent：返回一个总是返回Observable最近发射的数据的Iterable。" class="headerlink" title="mostRecent：返回一个总是返回Observable最近发射的数据的Iterable。"></a>mostRecent：返回一个总是返回Observable最近发射的数据的Iterable。</h4><h4 id="next：-返回一个Iterable，会阻塞直到Observable发射了第二个值，然后返回那个值。"><a href="#next：-返回一个Iterable，会阻塞直到Observable发射了第二个值，然后返回那个值。" class="headerlink" title="next： 返回一个Iterable，会阻塞直到Observable发射了第二个值，然后返回那个值。"></a>next： 返回一个Iterable，会阻塞直到Observable发射了第二个值，然后返回那个值。</h4><h4 id="latest：-返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值"><a href="#latest：-返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值" class="headerlink" title="latest： 返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值"></a>latest： 返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值</h4><h4 id="toFuture：-将Observable转换为一个Future"><a href="#toFuture：-将Observable转换为一个Future" class="headerlink" title="toFuture： 将Observable转换为一个Future"></a>toFuture： 将Observable转换为一个Future</h4><h4 id="toIterable：将一个发射数据序列的Observable转换为一个Iterable。"><a href="#toIterable：将一个发射数据序列的Observable转换为一个Iterable。" class="headerlink" title="toIterable：将一个发射数据序列的Observable转换为一个Iterable。"></a>toIterable：将一个发射数据序列的Observable转换为一个Iterable。</h4><h4 id="getIterator：将一个发射数据序列的Observable转换为一个Iterator工具集"><a href="#getIterator：将一个发射数据序列的Observable转换为一个Iterator工具集" class="headerlink" title="getIterator：将一个发射数据序列的Observable转换为一个Iterator工具集"></a>getIterator：将一个发射数据序列的Observable转换为一个Iterator工具集</h4><h4 id="materialize：-将Observable转换成一个通知列表。"><a href="#materialize：-将Observable转换成一个通知列表。" class="headerlink" title="materialize： 将Observable转换成一个通知列表。"></a>materialize： 将Observable转换成一个通知列表。</h4><pre><code>Observable.just(1,2,3)
       .materialize()
       .subscribe(new Action1&lt;Notification&lt;Integer&gt;&gt;() {
           @Override
           public void call(Notification&lt;Integer&gt; notification) {
               Log.d(&quot;JG&quot;,notification.getKind()+&quot; &quot;+notification.getValue());
               //OnNext 1
               //OnNext 2
               //OnNext 3
               //OnCompleted null
           }
       });
</code></pre><h4 id="dematerialize：-与上面的作用相反，将通知逆转回一个Observable。"><a href="#dematerialize：-与上面的作用相反，将通知逆转回一个Observable。" class="headerlink" title="dematerialize： 与上面的作用相反，将通知逆转回一个Observable。"></a>dematerialize： 与上面的作用相反，将通知逆转回一个Observable。</h4><h4 id="timestamp：-给Observable发射的每个数据项添加一个时间戳。"><a href="#timestamp：-给Observable发射的每个数据项添加一个时间戳。" class="headerlink" title="timestamp： 给Observable发射的每个数据项添加一个时间戳。"></a>timestamp： 给Observable发射的每个数据项添加一个时间戳。</h4><pre><code>Observable.just(1,2,3)
       .timestamp()
       .subscribe(new Action1&lt;Timestamped&lt;Integer&gt;&gt;() {
           @Override
           public void call(Timestamped&lt;Integer&gt; timestamped) {
               Log.d(&quot;JG&quot;,timestamped.getTimestampMillis()+&quot; &quot;+timestamped.getValue());
               //1472627510548 1
               //1472627510549 2
               //1472627510549 3
           }
       });
</code></pre><h4 id="timeInterval：给Observable发射的两个数据项间添加一个时间差，实现在OperatorTimeInterval中"><a href="#timeInterval：给Observable发射的两个数据项间添加一个时间差，实现在OperatorTimeInterval中" class="headerlink" title="timeInterval：给Observable发射的两个数据项间添加一个时间差，实现在OperatorTimeInterval中"></a>timeInterval：给Observable发射的两个数据项间添加一个时间差，实现在OperatorTimeInterval中</h4><p><img src="http://static.zybuluo.com/maplejaw/6dbl77xvh2z02hxil00juave/image_1argc8a1n17a61t441s5p1gln8231g.png" alt="Markdown preferences pane"></p>
<h4 id="serialize：-强制Observable按次序发射数据并且要求功能是完好的"><a href="#serialize：-强制Observable按次序发射数据并且要求功能是完好的" class="headerlink" title="serialize： 强制Observable按次序发射数据并且要求功能是完好的"></a>serialize： 强制Observable按次序发射数据并且要求功能是完好的</h4><h4 id="cache：-缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者"><a href="#cache：-缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者" class="headerlink" title="cache： 缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者"></a>cache： 缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者</h4><h4 id="observeOn：-指定观察者观察Observable的调度器"><a href="#observeOn：-指定观察者观察Observable的调度器" class="headerlink" title="observeOn： 指定观察者观察Observable的调度器"></a>observeOn： 指定观察者观察Observable的调度器</h4><h4 id="subscribeOn：-指定Observable执行任务的调度器"><a href="#subscribeOn：-指定Observable执行任务的调度器" class="headerlink" title="subscribeOn： 指定Observable执行任务的调度器"></a>subscribeOn： 指定Observable执行任务的调度器</h4><h4 id="doOnEach：-注册一个动作，对Observable发射的每个数据项使用"><a href="#doOnEach：-注册一个动作，对Observable发射的每个数据项使用" class="headerlink" title="doOnEach： 注册一个动作，对Observable发射的每个数据项使用"></a>doOnEach： 注册一个动作，对Observable发射的每个数据项使用</h4><pre><code>Observable.just(2,3)
        .doOnEach(new Action1&lt;Notification&lt;? super Integer&gt;&gt;() {
            @Override
            public void call(Notification&lt;? super Integer&gt; notification) {
                Log.d(&quot;JG&quot;,&quot;--doOnEach--&quot;+notification.toString());
            }
        })
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));
</code></pre><p>//结果为：<br> // –doOnEach–[rx.Notification@133c40b0 OnNext 2]<br>// 2<br> // –doOnEach–[rx.Notification@133c40b0 OnNext 3]<br>// 3<br>// –doOnEach–[rx.Notification@df4db0e OnCompleted]</p>
<h4 id="doOnCompleted：-注册一个动作，对正常完成的Observable使用"><a href="#doOnCompleted：-注册一个动作，对正常完成的Observable使用" class="headerlink" title="doOnCompleted： 注册一个动作，对正常完成的Observable使用"></a>doOnCompleted： 注册一个动作，对正常完成的Observable使用</h4><h4 id="doOnError：-注册一个动作，对发生错误的Observable使用"><a href="#doOnError：-注册一个动作，对发生错误的Observable使用" class="headerlink" title="doOnError： 注册一个动作，对发生错误的Observable使用"></a>doOnError： 注册一个动作，对发生错误的Observable使用</h4><h4 id="doOnTerminate：注册一个动作，对完成的Observable使用，无论是否发生错误"><a href="#doOnTerminate：注册一个动作，对完成的Observable使用，无论是否发生错误" class="headerlink" title="doOnTerminate：注册一个动作，对完成的Observable使用，无论是否发生错误"></a>doOnTerminate：注册一个动作，对完成的Observable使用，无论是否发生错误</h4><pre><code>Observable.just(2,3)
        .doOnTerminate(new Action0() {
            @Override
            public void call() {
                Log.d(&quot;JG&quot;,&quot;--doOnTerminate--&quot;);
            }
        })
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));// 2 , 3 , --doOnTerminate--
</code></pre><h4 id="doOnSubscribe：-注册一个动作，在观察者订阅时使用。内部由OperatorDoOnSubscribe实现，"><a href="#doOnSubscribe：-注册一个动作，在观察者订阅时使用。内部由OperatorDoOnSubscribe实现，" class="headerlink" title="doOnSubscribe： 注册一个动作，在观察者订阅时使用。内部由OperatorDoOnSubscribe实现，"></a>doOnSubscribe： 注册一个动作，在观察者订阅时使用。内部由OperatorDoOnSubscribe实现，<img src="http://static.zybuluo.com/maplejaw/9w3o5vxc0lzznbrpn4vwa78w/image_1argbe0o1atfqtbrj51gu0jho9.png" alt="Markdown preferences pane"></h4><h4 id="doOnUnsubscribe：-注册一个动作，在观察者取消订阅时使用。内部由OperatorDoOnUnsubscribe实现，在call中加入一个解绑动作。"><a href="#doOnUnsubscribe：-注册一个动作，在观察者取消订阅时使用。内部由OperatorDoOnUnsubscribe实现，在call中加入一个解绑动作。" class="headerlink" title="doOnUnsubscribe： 注册一个动作，在观察者取消订阅时使用。内部由OperatorDoOnUnsubscribe实现，在call中加入一个解绑动作。"></a>doOnUnsubscribe： 注册一个动作，在观察者取消订阅时使用。内部由OperatorDoOnUnsubscribe实现，在call中加入一个解绑动作。</h4><p><img src="http://static.zybuluo.com/maplejaw/791vkq1lxpl2etqaql85a6e8/image_1argbhutoi1a1b6a18s9il6npvm.png" alt="Markdown preferences pane"></p>
<h4 id="finallyDo-doAfterTerminate：-注册一个动作，在Observable完成时使用"><a href="#finallyDo-doAfterTerminate：-注册一个动作，在Observable完成时使用" class="headerlink" title="finallyDo/doAfterTerminate： 注册一个动作，在Observable完成时使用"></a>finallyDo/doAfterTerminate： 注册一个动作，在Observable完成时使用</h4><pre><code>Observable.just(2,3)
        .doAfterTerminate(new Action0() {
            @Override
            public void call() {
                Log.d(&quot;JG&quot;,&quot;--doAfterTerminate--&quot;);
            }
        })
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));
    //2,3,  --doAfterTerminate-- 
</code></pre><h4 id="delay：-延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。"><a href="#delay：-延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。" class="headerlink" title="delay： 延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。"></a>delay： 延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。</h4><h4 id="delaySubscription：-延时处理订阅请求。实现在OnSubscribeDelaySubscription中"><a href="#delaySubscription：-延时处理订阅请求。实现在OnSubscribeDelaySubscription中" class="headerlink" title="delaySubscription： 延时处理订阅请求。实现在OnSubscribeDelaySubscription中"></a>delaySubscription： 延时处理订阅请求。实现在OnSubscribeDelaySubscription中</h4><p><img src="http://static.zybuluo.com/maplejaw/xqw7fto75revvct4zu3d56a5/image_1argc0tbetbj1rkj1etf4fcb1p13.png" alt="Markdown preferences pane"></p>
<h4 id="using：-创建一个只在Observable生命周期存在的资源，当Observable终止时这个资源会被自动释放。"><a href="#using：-创建一个只在Observable生命周期存在的资源，当Observable终止时这个资源会被自动释放。" class="headerlink" title="using： 创建一个只在Observable生命周期存在的资源，当Observable终止时这个资源会被自动释放。"></a>using： 创建一个只在Observable生命周期存在的资源，当Observable终止时这个资源会被自动释放。</h4><pre><code>Observable.using(new Func0&lt;File&gt;() {//资源工厂
    @Override
    public File call() {

        File file = new File(getCacheDir(), &quot;a.txt&quot;);
        if(!file.exists()){
            try {
                Log.d(&quot;JG&quot;,&quot;--create--&quot;);
                file.createNewFile();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return file;
    }
}, new Func1&lt;File, Observable&lt;String&gt;&gt;() { //Observable
    @Override
    public Observable&lt;String&gt; call(File file) {
        return Observable.just(file.exists() ? &quot;exist&quot; : &quot;no exist&quot;);
    }
}, new Action1&lt;File&gt;() {//释放资源动作
    @Override
    public void call(File file) {
        if(file!=null&amp;&amp;file.exists()){
            Log.d(&quot;JG&quot;,&quot;--delete--&quot;);
            file.delete();
        }
    }
})
.subscribe(s -&gt; Log.d(&quot;JG&quot;,s))
;
//--create--
//exist
//--delete--
</code></pre><h4 id="single-singleOrDefault：-强制返回单个数据，否则抛出异常或默认数据。"><a href="#single-singleOrDefault：-强制返回单个数据，否则抛出异常或默认数据。" class="headerlink" title="single/singleOrDefault： 强制返回单个数据，否则抛出异常或默认数据。"></a>single/singleOrDefault： 强制返回单个数据，否则抛出异常或默认数据。</h4><p>关于RxJava标准库的操作符已经介绍完毕，纯粹当个备忘录。如有错误之处，欢迎指出。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2016/12/26/Android中的TouchEvent触摸事件机制/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/26/Android中的TouchEvent触摸事件机制/" itemprop="url">
                  Android中的TouchEvent触摸事件机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-26T19:22:32+08:00">
                2016-12-26
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当我们的手指在Android屏幕上点击或滑动时，就会触发触摸事件TouchEvent。在App中ViewGroup和View存在多级嵌套，在最外层的是Activity，最内层的View，介于Activity与View之间的是一些ViewGroup。本文为了简化讨论，我们假设一个Activity中只有一个ViewGroup，这个ViewGroup中只有一个View。当我们用手指触摸到View的UI时，就会产生触摸事件TouchEvent，总的过程如下图所示：</p>
<p><img src="http://fastabler.online/images/20151219223049372.png" alt=""></p>
<p>首先是最外层的Activity接收到该事件，触发Activity的dispatchTouchEvent的执行，在该方法中Activity又会调用内部ViewGroup的dispatchTouchEvent方法的执行，在ViewGroup的dispatchTouchEvent方法中又会调用最内层的View的dispatchTouchEvent方法的执行，在View的dispatchTouchEvent方法中可能会执行View的onTouchEvent方法，然后ViewGroup也有可能执行ViewGroup的onTouchEvent方法，然后Activity也有可能执行Activity的onTouchEvent方法的执行。</p>
<p>上图是精简过的主要流程图，总共是两条主线：</p>
<p>第一条主线是，从Activity -&gt; ViewGroup -&gt; View，从外向内依次调用dispatchTouchEvent方法，Android会依次把MotionEvent参数传递给该方法。dispatchTouchEvent的作用是传递触摸事件，该主线体现了将触摸事件从外向内逐级传递派发的过程，dispatchTouchEvent是每次传递触摸事件的入口。</p>
<p>第二条主线是，从View -&gt; ViewGroup -&gt; Activity，从内向外依次调用onTouchEvent方法，Android会依次把MotionEvent参数传递给该方法。onTouchEvent的作用是处理触摸事件，该主线体现了将触摸事件从内向外逐级处理的过程。</p>
<p>dispatchTouchEvent和onTouchEvent都接收一个MotionEvent类型的参数，MotionEvent封装了触摸事件的数据信息，包括触摸事件的类型以及坐标位置等，详见博文《Android中的MotionEvent》。dispatchTouchEvent和onTouchEvent都有一个boolean类型的返回值，如果返回true，表示当前对象已经对触摸事件进行了处理；如果返回false，表示当前对象没有对触摸事件进行处理。</p>
<p>下面分别对Activity、ViewGroup、View的事件派发、处理的过程详细说明。</p>
<h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><h3 id="dispatchTouchEvent"><a href="#dispatchTouchEvent" class="headerlink" title="dispatchTouchEvent"></a>dispatchTouchEvent</h3><p>所有在UI上的触摸操作生成的触摸事件都首先会触发Activity中dispatchTouchEvent方法的执行，其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class="line">    if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">        onUserInteraction();</div><div class="line">    &#125;</div><div class="line">    if (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    return onTouchEvent(ev);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述方法的关键是，Activity会首先通过getWindow()方法获取当前的window对象，然后调用window的superDispatchTouchEvent方法，实际上，getWindow()返回的是一个PhoneWindow类型的实例，这样就会调用PhoneWindow的superDispatchTouchEvent方法，其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</div><div class="line">    return mDecor.superDispatchTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>mDecor是PhoneWindow中一个DecorView类型的变量，DecorView代表了当前Window最顶级的View，可以看做是根View。由上代码看出，后面会执行DecorView的superDispatchTouchEvent方法，其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</div><div class="line">    return super.dispatchTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实际上DectorView继承自FrameLayout，所以DectorView间接继承自ViewGroup，所以会DectorView执行其父类ViewGroup对应的dispatchTouchEvent方法。在该方法中，DectorView会找到其触摸的子节点，实际上其子节点也是一个ViewGroup，然后再执行该ViewGroup的dispatchTouchEvent方法，这样就实现了将触摸事件参数MotionEvent从Activity中传入到DecorView的子ViewGroup中了。我们会在后面探讨ViewGroup中的dispatchTouchEvent方法中的执行逻辑，此处就不再过多介绍了。</p>
<p>以上介绍了借助superDispatchTouchEvent和dispatchTouchEvent方法将触摸事件从Activity到ViewGroup中的传递过程，这两个方法均返回一个boolean类型的参数，如果返回true，表示触摸事件被处理了，反之表示触摸事件没有被处理。我们再看一下上面Activity中dispatchTouchEvent的源码，就会发现如果PhoneWindow的superDispatchTouchEvent返回了true，那么Activity的dispatchTouchEvent方法也就直接返回了true，表明触摸事件被Window给处理了，所以就不会执行后面Activity的 onTouchEvent方法。只有Window没处理触摸事件的情况下，Activity才会调用onTouchEvent方法去处理事件。</p>
<h3 id="onTouchEvent"><a href="#onTouchEvent" class="headerlink" title="onTouchEvent"></a>onTouchEvent</h3><p>onTouchEvent的源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">    if (mWindow.shouldCloseOnTouch(this, event)) &#123;</div><div class="line">        finish();</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>只有当触摸事件没有被任何的View或ViewGroup处理过的时候，Activity才会执行自己的onTouchEvent去处理触摸事件。一种典型的情形就是，当前触摸点在Window范围之外，这样Window里面所有的View都不会接收更不会处理该触摸事件，这时候我们可以重写该方法实现一些自己的逻辑处理这种情形。如果我们处理了，就返回true，否则返回false。其默认实现基本一直返回false。</p>
<h2 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><h3 id="dispatchTouchEvent-1"><a href="#dispatchTouchEvent-1" class="headerlink" title="dispatchTouchEvent"></a>dispatchTouchEvent</h3><p>当Activity接收到触摸事件之后，会通过DectorView调用ViewGroup的dispatchTouchEvent方法，由于该方法的源码太长，此处就不贴源码了，点此查看其源码。此处主要说一下该方法中的主要逻辑。dispatchTouchEvent方法是ViewGroup对触摸事件进行处理的入口。</p>
<p>ViewGroup中定义了一个TouchTarget类型的成员变量mFirstTouchTarget，用于保存当前ViewGroup中处理了触摸事件的子View。</p>
<p>首先，dispatchTouchEvent方法会调用其自身的onInterceptTouchEvent方法，onInterceptTouchEvent是用来拦截ViewGroup将触摸事件传递给其子View的，如果该方法返回true，就表示ViewGroup应该拦截触摸事件；如果返回false，表示ViewGroup不应该拦截触摸事件，应该将触摸事件传递给子View。在dispathTouchEvent方法中还定义了一个boolean类型的handled变量，用于保存dispathTouchEvent方法的返回值，如果是true就表示触摸事件被当前的ViewGroup处理了，反之则表示没被处理。</p>
<p>然后，只有当onInterceptTouchEvent返回了false，ViewGroup才会依次遍历其子View，其会通过调用isTransformedTouchPointInView方法判断MotionEvent所携带的触摸事件的坐标是否落在子View的范围内，如果触摸事件的坐标恰好落在了该子View范围内，说明我们触摸了当前ViewGroup内的该子View，这样ViewGroup就会把触摸事件的坐标以及该子View传递给dispatchTransformedTouchEvent方法，在该方法内会调用子View的dispatchTouchEvent方法，其返回值表示自View是否处理了触摸事件，如果dispatchTransformedTouchEvent返回true，表示子View处理了触摸事件，这样ViewGroup会通过调用addTouchTarget方法将mFirstTouchTarget绑定该子View，并且变量alreadyDispatchedToNewTouchTarget也会设置为true，表示已经有子View处理了触摸事件。一旦有子View处理了触摸事件，ViewGroup就会通过break跳出for循环，不再对其他子View进行遍历。</p>
<p>在经过了对子View的for循环之后，如果没有任何的子View处理了触摸事件，那么mFirstTouchTarget就还是null，此时ViewGroup就会将null作为child参数传入dispatchTransformedTouchEvent方法中，该方法会调用super.dispatchTouchEvent方法，由于ViewGroup继承自View，以此处就相当于执行了View类中的dispatchTouchEvent方法，这样就很有可能执行ViewGroup从View中继承来的onTouchEvent方法。dispatchTransformedTouchEvent的返回值会作为局部变量handled的值。关于View类中的dispatchTouchEvent方法会在下面详细说明。</p>
<p>在经过了对子View的for循环之后，如果发现某个子View对触摸事件进行了处理，那么alreadyDispatchedToNewTouchTarget就是true，从而会将局部变量handled设置为true，即表示只要有子View处理了触摸事件，就表示当前的ViewGroup也处理了触摸事件，并且这种情况下ViewGroup不会调用从View中继承来的dispatchTouchEvent方法，从而不会触发ViewGroup的onTouchEvent方法的执行。</p>
<h3 id="onInterceptTouchEvent"><a href="#onInterceptTouchEvent" class="headerlink" title="onInterceptTouchEvent"></a>onInterceptTouchEvent</h3><p>之前提到过onInterceptTouchEvent用于拦截ViewGroup向子View传递触摸事件，ViewGroup中的默认实现一直返回false，即表示不拦截。我们可以重写该方法以实现我们自己的触摸事件拦截逻辑。</p>
<p>dispatchTransformedTouchEvent<br>点此查看源码，其主要的逻辑代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,</div><div class="line">        View child, int desiredPointerIdBits) &#123;</div><div class="line"></div><div class="line">  final boolean handled;</div><div class="line"></div><div class="line">  final MotionEvent transformedEvent;</div><div class="line"></div><div class="line">  ......        </div><div class="line"></div><div class="line">    // Perform any necessary transformations and dispatch.</div><div class="line">    if (child == null) &#123;</div><div class="line">        handled = super.dispatchTouchEvent(transformedEvent);</div><div class="line">    &#125; else &#123;</div><div class="line">        final float offsetX = mScrollX - child.mLeft;</div><div class="line">        final float offsetY = mScrollY - child.mTop;</div><div class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</div><div class="line">        if (! child.hasIdentityMatrix()) &#123;</div><div class="line">            transformedEvent.transform(child.getInverseMatrix());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        handled = child.dispatchTouchEvent(transformedEvent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Done.</div><div class="line">    transformedEvent.recycle();</div><div class="line">    return handled;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法的主要目的是将MotionEvent中的x、y的坐标转换成所传入的child变量所指定的的View的坐标系中的坐标，transformedEvent表示了已经完成了指定坐标系转换的MotionEvent。如果传入的child参数是null，表示传入的是当前的ViewGroup，此时就将直接调用super.dispatchTouchEvent(transformedEvent)，这样就让ViewGroup调用了父类View中的dispatchTouchEvent方法；如果传入的child参数不是null，表示传入的当前ViewGroup的一个子View，那么就会调用child.dispatchTouchEvent(transformedEvent)，从而将触摸事件从ViewGroup传递到子View中去。我们会在下面介绍View的dispatchTouchEvent的实现逻辑。</p>
<h3 id="onTouchEvent-1"><a href="#onTouchEvent-1" class="headerlink" title="onTouchEvent"></a>onTouchEvent</h3><p>ViewGroup的onTouchEvent继承自View的onTouchEvent方法，ViewGroup并没有重写，我们在下面会介绍View的onTouchEvent方法的实现逻辑。</p>
<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><h2 id="dispatchTouchEvent-2"><a href="#dispatchTouchEvent-2" class="headerlink" title="dispatchTouchEvent"></a>dispatchTouchEvent</h2><p>点此查看源码，其源码的主要逻辑如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public boolean dispatchTouchEvent(MotionEvent event) &#123;</div><div class="line">    ......</div><div class="line"></div><div class="line">    boolean result = false;</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    if (onFilterTouchEventForSecurity(event)) &#123;</div><div class="line">        //noinspection SimplifiableIfStatement</div><div class="line">        ListenerInfo li = mListenerInfo;</div><div class="line">        //如果设置了OnTouchListener，那么会在此处执行OnTouchListener的onTouch方法</div><div class="line">        if (li != null &amp;&amp; li.mOnTouchListener != null</div><div class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class="line">                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</div><div class="line">            //如果OnTouchListener的onTouch方法返回true，就表示触摸事件被处理了，result就会设置为true</div><div class="line">            result = true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //如果触摸事件没有被OnTouchListener处理，那么就会执行View的onTouchEvent方法</div><div class="line">        if (!result &amp;&amp; onTouchEvent(event)) &#123;</div><div class="line">            //如果onTouchEvent返回了true，就表示触摸事件被View处理了，result就被设置为了true</div><div class="line">            result = true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>dispatchTouchEvent是View处理触摸事件的入口。在该方法中，View首先会查看其有没有设置过OnTouchListener，如果设置过就调用OnTouchListener的onTouch方法，如果其返回了true，就表明触摸事件被处理了，result就会设置为true。如果触摸事件没有被OnTouchListener处理，那么就会执行View的onTouchEvent方法，如果onTouchEvent返回了true，就表示触摸事件被View处理了，result就被设置为了true。</p>
<p>由上可以看出，在dispatchTouchEvent方法中是先执行OnTouchListener的onTouch方法，一旦其返回true，就不会调用View自身的onTouchEvent方法了，只有OnTouchListener没有处理触摸事件才会在后面执行View的onTouchEvent方法。</p>
<h3 id="onTouchEvent-2"><a href="#onTouchEvent-2" class="headerlink" title="onTouchEvent"></a>onTouchEvent</h3><p>点此查看源码，View.onTouchEvent()方法中，如果View注册了CLICK或LONG_CLICK等事件监听器，那么就会让注册的事件监听器处理触摸事件，这样onTouchEvent就返回true。会根据ACTION的不同，执行不同的处理，比如如果是ACTION_UP，会执行performClick()方法，该方法会触发OnClickListener.onClick()的执行。<br>如果View没有注册任何的CLICK或LONG_CLICK等的事件监听器，那么onTouchEvent就返回false，表示onTouchEvent没有对传入的触摸事件MotionEvent做任何处理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们通过对上面Activity、ViewGroup、View各个层级对触摸事件的处理过程可以发现，Android中每个层级对触摸事件的处理都是从dispatchTouchEvent方法开始的，首先先调用下一层级的dispatchTouchEvent方法，将触摸事件传递给下一层级，如果下一层级对触摸事件进行了处理，就可认为本层级也对触摸事件进行了处理，那么本层级就不会对触摸事件仅需做其他特殊处理了；如果下一层级没有对触摸事件进行处理，即下一层级的dispatchTouchEvent方法返回false，那么才会调用本层级的onTouchEvent方法对触摸事件进行处理。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2016/12/25/Android中的MotionEvent/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/25/Android中的MotionEvent/" itemprop="url">
                  Android中的MotionEvent
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-25T17:22:03+08:00">
                2016-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>运动事件描述了动作的动作代码和一些列的坐标值。动作代码表明了当触点按下或者弹起等引起的状态变化。坐标值描述了位置信息以及以他的运动属性。</strong></p>
<p><strong>例如，当用户第一次触摸屏幕的时候，系统给窗体发出一个触摸事件，动作代码为ACTION_DOWN，并提供了一些列的坐标值，比如触摸的X、Y坐标，接触区域的压力、尺寸、方向等信息。<br>一些设备能够在同一时间报告多条运动轨迹。多点触控屏幕为每个手指都发出一条运动轨迹。手指或者其他能够产生运动轨迹的物体都可以叫做触点。运动事件包含所有触点的信息，即使有些触点自从上次事件之后就没有再移动，这些触点必须是当前处于活动状态的。</strong></p>
<p><strong>只有触点按下或者抬起的时候才会影响触点的数量，只有动作取消的时候除外。</strong></p>
<p><strong>每个触点都有一个唯一的id，这个id是在触点第一次按下的时候(动作代码为ACTION_DOWN或者ACTION_POINTER_DOWN)由系统自动分配的。触点的id会一直保持有效，当触点抬起的时候(动作代码为ACTION_UP或者ACTION_POINTER_UP)或者动作取消(动作代码为ACTION_CANCEL)的时候会导致触点的id失效。</strong></p>
<p><strong>MotionEvent类提供了许多可以查看触点的位置或者其他信息的方式，比如getX(int)、getY(int)、getAxisValue(int)、getPointerId(int)、getToolType(int)。这其中的大部分方法都将触点的索引值作为参数而不是触点的id。在事件中，每个触点的索引号的取值范围是从0到getPointerCount()-1。<br>在一次运动中触点出现的顺序是不确定的。因此，触点的索引值会由于事件的变化而变化，但是只要触点处于活动状态，该触点的id就不会改变。用getPointerId(int)方法可以得到触点的id值，从而根据得到的id值在一连串的动作中来追踪其运动轨迹。然而在连续的运动事件中，应该用findPointerIndex(int)方法通过触点的id值得到触点的索引值。</strong></p>
<p><strong>为了提高效率，代码为ACTION_MOVE的运动事件可能会将多个运动路径处理成一个。最常用的当前触点的坐标可以通过getX(int)和getY(int)获得。之前的坐标可以通过getHistoricalX(int,int)和getHistoricalY(int,int)获得。这些坐标之所以被成为”历史坐标”是因为这些坐标比当前坐标更早的出现了。要想按照时间顺序处理所有坐标，首先要处理历史坐标，然后再是当前坐标。</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2016/12/18/源码解析Android中View的layout布局过程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/18/源码解析Android中View的layout布局过程/" itemprop="url">
                  源码解析Android中View的layout布局过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-18T18:20:20+08:00">
                2016-12-18
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android中的Veiw从内存中到呈现在UI界面上需要依次经历三个阶段：量算 -&gt; 布局 -&gt; 绘图，关于View的量算、布局、绘图的总体机制可参见博文 <a href="http://fastabler.online/2016/12/11/Android中View的量算、布局以及绘图机制/" target="_blank" rel="external">《 Android中View的布局及绘图机制》</a>。量算是布局的基础，如果想了解量算的细节，可参见博文<a href="http://fastabler.online/2016/12/17/源码解析Android中View的Measure量算过程/" target="_blank" rel="external">《源码解析Android中View的measure量算过程》</a>。本文将从源码角度解析View的布局layout过程，本文会详细介绍View布局过程中的关键方法，并对源码加上了注释以进行说明。</p>
<p>对View进行布局的目的是计算出View的尺寸以及在其父控件中的位置，具体来说就是计算出View的四条边界分别到其父控件左边界、上边界的距离，即计算View的left、top、right、bottom的值。</p>
<p>##layout</p>
<p>layout()方法是View布局的入口，其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">public void layout(int l, int t, int r, int b) &#123;</div><div class="line">        //成员变量mPrivateFlags3中的一些比特位存储着和layout相关的信息</div><div class="line">        if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123;</div><div class="line">            //如果在mPrivateFlags3的低位字节的第4位（从最右向左数第4位）的值为1，</div><div class="line">            //那么就表示在layout布局前需要先对View进行量算，</div><div class="line">            //这种情况下就会执行View的onMeasure方法对View进行量算</div><div class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class="line">            //量算完成后就会将mPrivateFlags3低位字节的第4位重置为0，</div><div class="line">            //移除掉标签PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT</div><div class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int oldL = mLeft;</div><div class="line">        int oldT = mTop;</div><div class="line">        int oldB = mBottom;</div><div class="line">        int oldR = mRight;</div><div class="line"></div><div class="line">        //如果isLayoutModeOptical()返回true，那么就会执行setOpticalFrame()方法，</div><div class="line">        //否则会执行setFrame()方法。并且setOpticalFrame()内部会调用setFrame()，</div><div class="line">        //所以无论如何都会执行setFrame()方法。</div><div class="line">        //setFrame()方法会将View新的left、top、right、bottom存储到View的成员变量中</div><div class="line">        //并且返回一个boolean值，如果返回true表示View的位置或尺寸发生了变化，</div><div class="line">        //否则表示未发生变化</div><div class="line">        boolean changed = isLayoutModeOptical(mParent) ?</div><div class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line"></div><div class="line"></div><div class="line">        if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">            //如果View的布局发生了变化，或者mPrivateFlags有需要LAYOUT的标签PFLAG_LAYOUT_REQUIRED，</div><div class="line">            //那么就会执行以下代码</div><div class="line">            //首先会触发onLayout方法的执行，View中默认的onLayout方法是个空方法</div><div class="line">            //不过继承自ViewGroup的类都需要实现onLayout方法，从而在onLayout方法中依次循环子View，</div><div class="line">            //并调用子View的layout方法</div><div class="line">            onLayout(changed, l, t, r, b);</div><div class="line">            //在执行完onLayout方法之后，从mPrivateFlags中移除标签PFLAG_LAYOUT_REQUIRED</div><div class="line">            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">            //我们可以通过View的addOnLayoutChangeListener(View.OnLayoutChangeListener listener)方法</div><div class="line">            //向View中添加多个Layout发生变化的事件监听器</div><div class="line">            //这些事件监听器都存储在mListenerInfo.mOnLayoutChangeListeners这个ArrayList中</div><div class="line">            ListenerInfo li = mListenerInfo;</div><div class="line">            if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123;</div><div class="line">                //首先对mOnLayoutChangeListeners中的事件监听器进行拷贝</div><div class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">                int numListeners = listenersCopy.size();</div><div class="line">                for (int i = 0; i &lt; numListeners; ++i) &#123;</div><div class="line">                    //遍历注册的事件监听器，依次调用其onLayoutChange方法，这样Layout事件监听器就得到了响应</div><div class="line">                    listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //从mPrivateFlags中移除强制Layout的标签PFLAG_FORCE_LAYOUT</div><div class="line">        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class="line">        //向mPrivateFlags3中加入Layout完成的标签PFLAG3_IS_LAID_OUT</div><div class="line">        mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在layout()方法内部刚开始执行的时候，首先会根据mPrivateFlags3变量是否具有标志位PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT判断是否需要执行View的onMeasure()方法。如果具有标志位PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT，则执行onMeasure()方法，从而对View进行量算，量算的结果会保存到View的成员变量中。量算完成后就会将mPrivateFlags3低位字节的第4位重置为0，移除掉标签PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT。</p>
<p>如果isLayoutModeOptical()返回true，那么就会执行setOpticalFrame()方法，否则会执行setFrame()方法。并且setOpticalFrame()内部会调用setFrame()，所以无论如何都会执行setFrame()方法。setFrame()方法会将View新的left、top、right、bottom存储到View的成员变量中，并且返回一个boolean值，如果返回true表示View的位置或尺寸发生了变化，否则表示未发生变化。后面会对setFrame()方法详细介绍。</p>
<p>如果View的布局发生了变化，或者mPrivateFlags有需要LAYOUT的标签PFLAG_LAYOUT_REQUIRED，就会触发onLayout方法的执行，View中默认的onLayout方法是个空方法。不过继承自ViewGroup的类都需要实现onLayout方法，从而在onLayout方法中依次循环子View，并调用子View的layout方法。在执行完onLayout方法之后，从mPrivateFlags中移除标签PFLAG_LAYOUT_REQUIRED。然后会遍历注册的Layout Change事件监听器，依次调用其onLayoutChange方法，这样Layout事件监听器就得到了响应。</p>
<p>最后，从mPrivateFlags中移除强制Layout的标签PFLAG_FORCE_LAYOUT，向mPrivateFlags3中加入Layout完成的标签PFLAG3_IS_LAID_OUT。</p>
<p>##setFrame</p>
<p>setFrame()方法是具体用来完成给View分配尺寸以及位置工作的，在layout()方法中会调用setFrame()方法。其源码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">protected boolean setFrame(int left, int top, int right, int bottom) &#123;</div><div class="line">    boolean changed = false;</div><div class="line"></div><div class="line">    if (DBG) &#123;</div><div class="line">        Log.d(&quot;View&quot;, this + &quot; View.setFrame(&quot; + left + &quot;,&quot; + top + &quot;,&quot;</div><div class="line">                + right + &quot;,&quot; + bottom + &quot;)&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</div><div class="line">        //将新旧left、right、top、bottom进行对比，只要不完全相对就说明View的布局发生了变化，</div><div class="line">        //则将changed变量设置为true</div><div class="line">        changed = true;</div><div class="line"></div><div class="line">        //先保存一下mPrivateFlags中的PFLAG_DRAWN标签信息</div><div class="line">        int drawn = mPrivateFlags &amp; PFLAG_DRAWN;</div><div class="line"></div><div class="line">        //分别计算View的新旧尺寸</div><div class="line">        int oldWidth = mRight - mLeft;</div><div class="line">        int oldHeight = mBottom - mTop;</div><div class="line">        int newWidth = right - left;</div><div class="line">        int newHeight = bottom - top;</div><div class="line">        //比较View的新旧尺寸是否相同，如果尺寸发生了变化，那么sizeChanged的值为true</div><div class="line">        boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);</div><div class="line"></div><div class="line">        // Invalidate our old position</div><div class="line">        invalidate(sizeChanged);</div><div class="line"></div><div class="line">        //将新的left、top、right、bottom存储到View的成员变量中</div><div class="line">        mLeft = left;</div><div class="line">        mTop = top;</div><div class="line">        mRight = right;</div><div class="line">        mBottom = bottom;</div><div class="line">        //mRenderNode.setLeftTopRightBottom()方法会调用RenderNode中原生方法的nSetLeftTopRightBottom()方法，</div><div class="line">        //该方法会根据left、top、right、bottom更新用于渲染的显示列表</div><div class="line">        mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);</div><div class="line"></div><div class="line">        //向mPrivateFlags中增加标签PFLAG_HAS_BOUNDS，表示当前View具有了明确的边界范围</div><div class="line">        mPrivateFlags |= PFLAG_HAS_BOUNDS;</div><div class="line"></div><div class="line"></div><div class="line">        if (sizeChanged) &#123;</div><div class="line">            //如果View的尺寸和之前相比发生了变化，那么就执行sizeChange()方法，</div><div class="line">            //该方法中又会调用onSizeChanged()方法，并将View的新旧尺寸传递进去</div><div class="line">            sizeChange(newWidth, newHeight, oldWidth, oldHeight);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || mGhostView != null) &#123;</div><div class="line">            //有可能在调用setFrame方法之前，invalidate方法就被调用了，</div><div class="line">            //这会导致mPrivateFlags移除了PFLAG_DRAWN标签。</div><div class="line">            //如果当前View处于可见状态就将mPrivateFlags强制添加PFLAG_DRAWN状态位，</div><div class="line">            //这样会确保下面的invalidate()方法会执行到其父控件级别。</div><div class="line">            mPrivateFlags |= PFLAG_DRAWN;</div><div class="line">            invalidate(sizeChanged);</div><div class="line">            //invalidateParentCaches()方法会移除其父控件的PFLAG_INVALIDATED标签，</div><div class="line">            //这样其父控件就会重建用于渲染的显示列表</div><div class="line">            invalidateParentCaches();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 重新恢复mPrivateFlags中原有的PFLAG_DRAWN标签信息</div><div class="line">        mPrivateFlags |= drawn;</div><div class="line"></div><div class="line">        mBackgroundSizeChanged = true;</div><div class="line">        if (mForegroundInfo != null) &#123;</div><div class="line">            mForegroundInfo.mBoundsChanged = true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        notifySubtreeAccessibilityStateChangedIfNeeded();</div><div class="line">    &#125;</div><div class="line">    return changed;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在该方法中，会将新旧left、right、top、bottom进行对比，只要不完全相同就说明View的布局发生了变化，则将changed变量设置为true。然后比较View的新旧尺寸是否相同，如果尺寸发生了变化，并将其保存到变量sizeChanged中。如果尺寸发生了变化，那么sizeChanged的值为true。</p>
<p>然后将新的left、top、right、bottom存储到View的成员变量中保存下来。并执行mRenderNode.setLeftTopRightBottom()方法会，其会调用RenderNode中原生方法的nSetLeftTopRightBottom()方法，该方法会根据left、top、right、bottom更新用于渲染的显示列表。</p>
<p>如果View的尺寸和之前相比发生了变化，那么就执行sizeChange()方法，该方法中又会调用onSizeChanged()方法，并将View的新旧尺寸传递进去。</p>
<p>如果View处于可见状态，那么会调用invalidate和invalidateParentCaches方法。invalidateParentCaches()方法会移除其父控件的PFLAG_INVALIDATED标签，这样其父控件就会重建用于渲染的显示列表。</p>
<p>##sizeChange</p>
<p>sizeChange方法会在View的尺寸发生变化时调用，在setFrame()方法中就可能会调用sizeChange()方法。当然，在View的setLeft()、setTop()、setRight()、setBottom()等其他改变View尺寸的方法中也会调用sizeChange()方法，其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private void sizeChange(int newWidth, int newHeight, int oldWidth, int oldHeight) &#123;</div><div class="line">    //将View的新旧尺寸传递给onSizeChanged()方法</div><div class="line">    onSizeChanged(newWidth, newHeight, oldWidth, oldHeight);</div><div class="line">    if (mOverlay != null) &#123;</div><div class="line">        mOverlay.getOverlayView().setRight(newWidth);</div><div class="line">        mOverlay.getOverlayView().setBottom(newHeight);</div><div class="line">    &#125;</div><div class="line">    rebuildOutline();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在该方法中其主要将View的新旧尺寸传递给onSizeChanged()方法使其执行。</p>
<p>##onSizeChanged</p>
<p>onSizeChanged()方法是个空方法，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法会在View的尺寸发生变化时，通过sizeChange()方法的执行而被调用。当View第一次加入到View树中时，该方法也会被调用，只不过传入的旧尺寸oldWidth和oldHeight都是0。</p>
<p>##总结</p>
<p>layout方法总的调用过程主线如下所示：</p>
<p>layout() -&gt; onMeasure() -&gt; setFrame() -&gt; sizeChange() -&gt; onSizeChanged() -&gt; onLayout() -&gt;遍历执行OnLayoutChangeListener.onLayoutChange()</p>
<p>希望本文对大家理解View的layout布局过程有所帮助！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2016/12/17/源码解析Android中View的Measure量算过程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/17/源码解析Android中View的Measure量算过程/" itemprop="url">
                  源码解析Android中View的Measure量算过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-17T17:04:06+08:00">
                2016-12-17
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android中的Veiw从内存中到呈现在UI界面上需要依次经历三个阶段：量算 -&gt; 布局 -&gt; 绘图，关于View的量算、布局、绘图的总体机制可参见博文<a href="http://fastabler.online/2016/12/11/Android中View的量算、布局以及绘图机制/" target="_blank" rel="external">《 Android中View的布局及绘图机制》</a>。如果想了解layout布局的细节，可参见博文<a href="http://fastabler.online/2016/12/18/源码解析Android中View的layout布局过程/" target="_blank" rel="external">《源码解析Android中View的layout布局过程》</a>。量算是布局和绘图的基础，所以量算是很重要的一个环节。本文将从源码角度解析View的量算过程，这其中会涉及某些关键类以及关键方法。</p>
<p>对View进行量算的目的是让View的父控件知道View想要多大的尺寸。</p>
<p>##量算过程概述</p>
<p>如果要进行量算的View是ViewGroup类型，那么ViewGroup会在onMeasure方法内会遍历子View依次进行量算，本文重点说明非ViewGroup的View的量算过程，因为我们一旦了解了非ViewGroup的View的量算过程，ViewGroup的量算理解起来就要简单许多，主要是ViewGroup在其内部对子View再依次执行量算。</p>
<p>整个应用量算的起点是ViewRootImpl类，从它开始依次对子View进行量算，如果子View是一个ViewGroup，那么又会遍历该ViewGroup的子View依次进行量算。也就是说，量算会从View树的根结点，纵向递归进行，从而实现自上而下对View树进行量算，直至完成对叶子节点View的量算。</p>
<p>那么到底如何对一个View进行量算呢？Android通过调用View的measure()方法对View进行量算，让该View的父控件知道该View想要多大的尺寸空间。</p>
<p>具体来说，View的父控件ViewGroup会调用View的measure方法，ViewGroup会将一些宽度和高度的限制条件传递给View的measure方法。</p>
<p>在View的measure方法会首先从成员变量中读取以前缓存过的量算结果，如果能找到该缓存值，那么就基本完事了，如果没有找到缓存值，那么measure方法会执行onMeasure回调方法，measure方法会将上述的宽度和高度的限制条件依次传递给onMeasure方法。onMeasure方法会完成具体的量算工作，并将量算的结果通过调用View的setMeasuredDimension方法保存到View的成员变量mMeasuredWidth 和mMeasuredHeight中。</p>
<p>量算完成之后，View的父控件就可以通过调用getMeasuredWidth、getMeasuredState、getMeasuredWidthAndState这三个方法获取View的量算结果。</p>
<p>以上就是非ViewGroup类型的View量算的总体过程。</p>
<p>##MeasureSpec简介</p>
<p>上面我们提到ViewGroup在调用View的measure方法时，会传入ViewGroup对View的宽度及高度的限制条件，这是合理的，例如ViewGroup的空间有限，它需要告诉子View要量算的尺寸的上限。</p>
<p>上面提到的尺寸的限制条件就是MeasureSpec，它可以通过一个Int类型的值来表示的，该Int值会同时包含两种信息：mode和size，即模式和尺寸。我们知道Java中Int类型的值是4个字节的，Android会用第一个高位字节存储mode，然后用剩余的三个字节存储size。</p>
<p>View有一个静态内部类MeasureSpec，该类有几个静态方法以及静态常量，我们可以用这些方法将mode和size打包成一个Int值或者是从一个Int值中解析出mode和size。</p>
<p>假设我们已有了一个包含MeasureSpec信息的Int值measureSpec，那么</p>
<p>通过调用MeasureSpec.getSize(int measureSpec)即可从measureSpec解析出三个字节所包含的尺寸size信息，该方法返回Int类型，也就是说我们得到的size实际上就是对原有的measureSpec的高位字节的8个二进制位都设置为0，该方法的返回值size虽然也是4个字节的Int值，但是已经完全不包含mode信息。</p>
<p>通过调用MeasureSpec.getMode(int measureSpec)即可从measureSpec解析出高位字节所包含的模式mode信息，该方法返回Int类型，也就是说我们得到的mode实际上对原有的measureSpec的低位的三个字节的24个二进制码都设置为0，该方法的返回值mode虽然也是4个字节的Int值，但是已经完全不包含size信息。</p>
<p>对于尺寸size，我们很好理解，比如表示某个宽度值或者表示某个高度值。那么mode是什么呢？</p>
<p>mode的取值有三种，分别是：</p>
<p>MeasureSpec.AT_MOST，即0x80000000，该值表示View最大可以取其父ViewGroup给其指定的尺寸，例如现在有个Int值widthMeasureSpec，ViewGroup将其传递给了View的measure方法，如果widthMeasureSpec中的mode值是AT_MOST，size是200，那么表示View能取的最大的宽度是200。</p>
<p>MeasureSpec.EXACTLY，即0x40000000，该值表示View必须使用其父ViewGroup指定的尺寸，还是以widthMeasureSpec为例，如果其mode值是EXACTLY，size是200，那么表示View的宽度必须是200，不多不少才行。</p>
<p>MeasureSpec.UNSPECIFIED，即0x00000000，该值表示View的父ViewGroup没有给View在尺寸上设置限制条件，这种情况下View可以忽略measureSpec中的size，View可以取自己想要的值作为量算的尺寸。</p>
<p>更多信息可参考API文档 android/view/View.MeasureSpec。</p>
<p>##measure方法</p>
<p>measure()的方法签名是public final void measure(int widthMeasureSpec, int heightMeasureSpec)。</p>
<p>当View的父控件ViewGroup对View进行量算时，会调用View的measure方法，ViewGroup会传入widthMeasureSpec和heightMeasureSpec，分别表示父控件对View的宽度和高度的一些限制条件。</p>
<p>measure方法的源码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">    //首先判断当前View的layoutMode是不是特例LAYOUT_MODE_OPTICAL_BOUNDS</div><div class="line">    boolean optical = isLayoutModeOptical(this);</div><div class="line">    if (optical != isLayoutModeOptical(mParent)) &#123;</div><div class="line">        //LAYOUT_MODE_OPTICAL_BOUNDS是特例情况，比较少见</div><div class="line">        Insets insets = getOpticalInsets();</div><div class="line">        int oWidth  = insets.left + insets.right;</div><div class="line">        int oHeight = insets.top  + insets.bottom;</div><div class="line">        widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);</div><div class="line">        heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//根据widthMeasureSpec和heightMeasureSpec计算key值，我们在下面用key值作为键，缓存我们量算的结果</div><div class="line">    long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL;</div><div class="line">    //mMeasureCache是LongSparseLongArray类型的成员变量，</div><div class="line">    //其缓存着View在不同widthMeasureSpec、heightMeasureSpec下量算过的结果</div><div class="line">    //如果mMeasureCache为空，我们就新new一个对象赋值给mMeasureCache</div><div class="line">    if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2);</div><div class="line">    //mOldWidthMeasureSpec和mOldHeightMeasureSpec分别表示上次对View进行量算时的widthMeasureSpec和heightMeasureSpec</div><div class="line">    //执行View的measure方法时，View总是先检查一下是不是真的有必要费很大力气去做真正的量算工作</div><div class="line">    //mPrivateFlags是一个Int类型的值，其记录了View的各种状态位</div><div class="line">    //如果(mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT，</div><div class="line">    //那么表示当前View需要强制进行layout（比如执行了View的forceLayout方法），所以这种情况下要尝试进行量算</div><div class="line">    //如果新传入的widthMeasureSpec/heightMeasureSpec与上次量算时的mOldWidthMeasureSpec/mOldHeightMeasureSpec不等，</div><div class="line">    //那么也就是说该View的父ViewGroup对该View的尺寸的限制情况有变化，这种情况下要尝试进行量算</div><div class="line">    if ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</div><div class="line">            widthMeasureSpec != mOldWidthMeasureSpec ||</div><div class="line">            heightMeasureSpec != mOldHeightMeasureSpec) &#123;</div><div class="line"></div><div class="line">        //通过按位操作，重置View的状态mPrivateFlags，将其标记为未量算状态</div><div class="line">        mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</div><div class="line"></div><div class="line">        //对阿拉伯语、希伯来语等从右到左书写、布局的语言进行特殊处理</div><div class="line">        resolveRtlPropertiesIfNeeded();</div><div class="line"></div><div class="line">        //在View真正进行量算之前，View还想进一步确认能不能从已有的缓存mMeasureCache中读取缓存过的量算结果</div><div class="line">        //如果是强制layout导致的量算，那么将cacheIndex设置为-1，即不从缓存中读取量算结果</div><div class="line">        //如果不是强制layout导致的量算，那么我们就用上面根据measureSpec计算出来的key值作为缓存索引cacheIndex。</div><div class="line">        int cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -1 :</div><div class="line">                mMeasureCache.indexOfKey(key);</div><div class="line"></div><div class="line">        //sIgnoreMeasureCache是一个boolean类型的成员变量，其值是在View的构造函数中计算的，而且只计算一次</div><div class="line">        //一些老的App希望在一次layou过程中，onMeasure方法总是被调用，</div><div class="line">        //具体来说其值是通过如下计算的: sIgnoreMeasureCache = targetSdkVersion &lt; KITKAT;</div><div class="line">        //也就是说如果targetSdkVersion的API版本低于KITKAT，即API level小于19，那么sIgnoreMeasureCache为true</div><div class="line"></div><div class="line">        if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123;</div><div class="line">            //如果运行到此处，表示我们没有从缓存中找到量算过的尺寸或者是sIgnoreMeasureCache为true导致我们要忽略缓存结果</div><div class="line">            //此处调用onMeasure方法，并把尺寸限制条件widthMeasureSpec和heightMeasureSpec传入进去</div><div class="line">            //onMeasure方法中将会进行实际的量算工作，并把量算的结果保存到成员变量中</div><div class="line">            onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">            //onMeasure执行完后，通过位操作，重置View的状态mPrivateFlags，将其标记为在layout之前不必再进行量算的状态</div><div class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">        &#125; else &#123;</div><div class="line">            //如果运行到此处，那么表示当前的条件允许View从缓存成员变量mMeasureCache中读取量算过的结果</div><div class="line">            //用上面得到的cacheIndex从缓存mMeasureCache中取出值，不必在调用onMeasure方法进行量算了</div><div class="line">            long value = mMeasureCache.valueAt(cacheIndex);</div><div class="line">            //一旦我们从缓存中读到值，我们就可以调用setMeasuredDimensionRaw方法将当前量算的结果到成员变量中</div><div class="line">            setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value);</div><div class="line">            mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //如果我们自定义的View重写了onMeasure方法，但是没有调用setMeasuredDimension()方法，</div><div class="line">        //那么此处就会抛出异常，提醒开发者在onMeasure方法中调用setMeasuredDimension()方法</div><div class="line">        //Android是如何知道我们有没有在onMeasure方法中调用setMeasuredDimension()方法的呢？</div><div class="line">        //方法很简单，还是通过解析状态位mPrivateFlags。</div><div class="line">        //setMeasuredDimension()方法中会将mPrivateFlags设置为PFLAG_MEASURED_DIMENSION_SET状态，即已量算状态，</div><div class="line">        //此处就检查mPrivateFlags是否含有PFLAG_MEASURED_DIMENSION_SET状态即可判断setMeasuredDimension是否被调用</div><div class="line">        if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</div><div class="line">            throw new IllegalStateException(&quot;View with id &quot; + getId() + &quot;: &quot;</div><div class="line">                    + getClass().getName() + &quot;#onMeasure() did not set the&quot;</div><div class="line">                    + &quot; measured dimension by calling&quot;</div><div class="line">                    + &quot; setMeasuredDimension()&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //mOldWidthMeasureSpec和mOldHeightMeasureSpec保存着最近一次量算时的MeasureSpec，</div><div class="line">    //在量算完成后将这次新传入的MeasureSpec赋值给它们</div><div class="line">    mOldWidthMeasureSpec = widthMeasureSpec;</div><div class="line">    mOldHeightMeasureSpec = heightMeasureSpec;</div><div class="line"></div><div class="line">    //最后用上面计算出的key作为键，量算结果作为值，将该键值对放入成员变量mMeasureCache中，</div><div class="line">    //这样就实现了对本次量算结果的缓存，以便在下次measure方法执行的时候，有可能将其从中直接读出，</div><div class="line">    //从而省去实际量算的步骤</div><div class="line">    mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 |</div><div class="line">            (long) mMeasuredHeight &amp; 0xffffffffL);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>上面的注释对每行代码都进行了详细的说明，如果大家仔细读了的话，相信能一目了然，这里根据上面的注释简单总结一下measure方法都干了什么事：</p>
<p>首先，我们要知道并不是只要View的measure方法执行的时候View就一定要傻傻的真的去做量算工作，View也喜欢偷懒，如果View发现没有必要去量算的话，那它就不会真的去做量算的工作。</p>
<p>具体来说，View先查看是不是要强制量算以及这次measure中传入的MeasureSpec与上次量算的MeasureSpec是否相同，如果不是强制量算或者MeasureSpec与上次的量算的MeasureSpec相同，那么View就不必真的去量算了。</p>
<p>如果不满足上述条件，View就考虑去做量算工作。但是在量算之前，View还想偷懒，它会以MeasureSpec计算出的key值作为键，去成员变量mMeasureCache中查找是否缓存过对应key的量算结果，如果能找到，那么就简单调用一下setMeasuredDimensionRaw方法，将从缓存中读到的量算结果保存到成员变量mMeasuredWidth和mMeasuredHeight中。</p>
<p>如果不能从mMeasureCache中读到缓存过的量算结果，那么这次View就真的不能再偷懒了，只能乖乖地调用onMeasure方法去完成实际的量算工作，并且将尺寸限制条件widthMeasureSpec和heightMeasureSpec传递给onMeasure方法。关于onMeasure方法，我们会在下面详细介绍。</p>
<p>不论上面代码走了哪个判断的分支，最终View都会得到量算的结果，并且将结果缓存到成员变量mMeasureCache中，以便下次执行measure方法时能够从其中读取缓存值。</p>
<p>需要说明的是，View有一个成员变量mPrivateFlags，用以保存View的各种状态位，在量算开始前，会将其设置为未量算状态，在量算完成后会将其设置为已量算状态。</p>
<p>##onMeasure方法</p>
<p>我们在上面提到，当View在measure方法中发现不得不进行实际的量算工作时，将会调用onMeasure方法，并且将尺寸限制条件widthMeasureSpec和heightMeasureSpec作为参数传递给onMeasure方法。View的onMeasure方法不是空方法，它提供了一个默认的具体实现。<br>onMeasure方法的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">    //onMeasure调用了setMeasuredDimension方法，</div><div class="line">    //setMeasuredDimension又需要调用getDefaultSize方法，</div><div class="line">    //getDefaultSize又需要调用getSuggestedMinimumWidth和getSuggestedMinimumHeight方法</div><div class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们发现onMeasure方法中会调用setMeasuredDimension方法，setMeasuredDimension又需要调用getDefaultSize方法，getDefaultSize又需要调用getSuggestedMinimumWidth和getSuggestedMinimumHeight方法，即<br>setMeasuredDimension -&gt; getDefaultSize -&gt; getSuggestedMinimumWidth/Height</p>
<p>那我们就先研究getSuggestedMinimumWidth/Height，然后再依次研究getDefaultSize和setMeasuredDimension，这样就能把onMeasure方法搞明白了。其实getSuggestedMinimumWidth和getSuggestedMinimumHeight的实现逻辑基本一样，我们此处只研究getSuggestedMinimumWidth方法即可。</p>
<p>getSuggestedMinimumWidth方法</p>
<p>getSuggestedMinimumWidth用于返回View推荐的最小宽度，其代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">protected int getSuggestedMinimumWidth() &#123;</div><div class="line">    //如果没有给View设置背景，那么就返回View本身的最小宽度mMinWidth</div><div class="line">    //如果给View设置了背景，那么就取View本身最小宽度mMinWidth和背景的最小宽度的最大值</div><div class="line">    return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果没有给View设置背景，那么就返回View本身的最小宽度mMinWidth</p>
<p>如果给View设置了背景，那么就取View本身最小宽度mMinWidth和背景的最小宽度的最大值</p>
<p>那你可能有疑问，View中保存的最小宽度mMinWidth的值是从哪来的呢？实际上有两种办法给View设置最小宽度。</p>
<p>第一种情况是，mMinWidth是在View的构造函数中被赋值的，View通过读取XML中定义的minWidth的值来设置View的最小宽度mMinWidth，以下代码片段是View构造函数中解析minWidth的部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//遍历到XML中定义的minWith属性</div><div class="line">case R.styleable.View_minWidth:</div><div class="line">//读取XML中定义的属性值作为mMinWidth，如果XML中未定义，则设置为0</div><div class="line">mMinWidth = a.getDimensionPixelSize(attr, 0);</div><div class="line">break;</div></pre></td></tr></table></figure></p>
<p>第二种情况是调用View的setMinimumWidth方法给View的最小宽度mMinWidth赋值，setMinimumWidth方法的代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void setMinimumWidth(int minWidth) &#123;</div><div class="line">    mMinWidth = minWidth;</div><div class="line">    requestLayout();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样我们就搞明白了getSuggestedMinimumWidth方法是怎么执行的了，getSuggestedMinimumHeight方法与其逻辑完全一致，只不过是把宽度换成了高度，在此就不再赘述了。</p>
<p>getDefaultSize</p>
<p>我们在onMeasure方法中发现，onMeasure会执行以下两行代码：getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec)<br>getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)</p>
<p>我们已经研究了getSuggestedMinimumWidth/Height，知道其会返回View的最小宽度和高度，现在我们开始研究getDefaultSize方法。</p>
<p>Android会将View想要的尺寸以及其父控件对其尺寸限制信息measureSpec传递给getDefaultSize方法，该方法要根据这些综合信息计算最终的量算的尺寸。</p>
<p>其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public static int getDefaultSize(int size, int measureSpec) &#123;</div><div class="line">    //size表示的是View想要的尺寸信息，比如最小宽度或最小高度</div><div class="line">    int result = size;</div><div class="line">    //从measureSpec中解析出specMode信息</div><div class="line">    int specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">    //从measureSpec中解析出specSize信息，不要将specSize与上面的size变量搞混</div><div class="line">    int specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">    switch (specMode) &#123;</div><div class="line">    //如果mode是UNSPECIFIED，表示View的父ViewGroup没有给View在尺寸上设置限制条件</div><div class="line">    case MeasureSpec.UNSPECIFIED:</div><div class="line">        //此处当mode是UNSPECIFIED时，View就直接用自己想要的尺寸size作为量算的结果</div><div class="line">        result = size;</div><div class="line">        break;</div><div class="line">    //如果mode是UNSPECIFIED，那么表示View最大可以取其父ViewGroup给其指定的尺寸</div><div class="line">    //如果mode是EXACTLY，那么表示View必须使用其父ViewGroup指定的尺寸</div><div class="line">    case MeasureSpec.AT_MOST:</div><div class="line">    case MeasureSpec.EXACTLY:</div><div class="line">        //此处mode是UNSPECIFIED或EXACTLY时，View就用其父ViewGroup指定的尺寸作为量算的结果</div><div class="line">        result = specSize;      </div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过以上代码，我们就会发现View的父ViewGroup传递给View的限制条件measureSpec的作用在该方法中体现的淋漓尽致。</p>
<p>首先根据measuredSpec解析出对应的specMode和specSize</p>
<p>当mode是UNSPECIFIED时，View就直接用自己想要的尺寸size作为量算的结果</p>
<p>当mode是UNSPECIFIED或EXACTLY时，View就用其父ViewGroup指定的尺寸作为量算的结果</p>
<p>最终，View会根据measuredSpec限制条件，得到最终的量算的尺寸。</p>
<p>这样在onMeasure方法中，<br>当执行getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec)时，我们就得到了最终量算到的宽度值；<br>当执行getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)时，我们就得到了最终量算到的高度值。</p>
<p>##setMeasuredDimension</p>
<p>在前面我们研究onMeasure方法时就已经看到setMeasuredDimension会调用getDefaultSize方法，会将已经量算到的宽度值和高度值作为参数传递给setMeasuredDimension方法，我们研究一下该方法。</p>
<p>其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123;</div><div class="line">    boolean optical = isLayoutModeOptical(this);</div><div class="line">    if (optical != isLayoutModeOptical(mParent)) &#123;</div><div class="line">        //layoutMode是LAYOUT_MODE_OPTICAL_BOUNDS的特殊情况，我们不考虑</div><div class="line">        Insets insets = getOpticalInsets();</div><div class="line">        int opticalWidth  = insets.left + insets.right;</div><div class="line">        int opticalHeight = insets.top  + insets.bottom;</div><div class="line"></div><div class="line">        measuredWidth  += optical ? opticalWidth  : -opticalWidth;</div><div class="line">        measuredHeight += optical ? opticalHeight : -opticalHeight;</div><div class="line">    &#125;</div><div class="line">    //最终调用setMeasuredDimensionRaw方法，将量算结果传入进去</div><div class="line">    setMeasuredDimensionRaw(measuredWidth, measuredHeight);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法会在开始判断layoutMode是不是LAYOUT_MODE_OPTICAL_BOUNDS的特殊情况，这种特例很少见，我们直接忽略掉。</p>
<p>setMeasuredDimension方法最后将量算的结果传递给方法setMeasuredDimensionRaw，我们再研究一下setMeasuredDimensionRaw这方法。</p>
<p>setMeasuredDimensionRaw</p>
<p>setMeasuredDimensionRaw接收两个参数，分别是已经量算完成的宽度和高度。</p>
<p>其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123;</div><div class="line">    //将量算完成的宽度measuredWidth保存到View的成员变量mMeasuredWidth中</div><div class="line">    mMeasuredWidth = measuredWidth;</div><div class="line">    //将量算完成的高度measuredHeight保存到View的成员变量mMeasuredHeight中</div><div class="line">    mMeasuredHeight = measuredHeight;</div><div class="line">    //最后将View的状态位mPrivateFlags设置为已量算状态</div><div class="line">    mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们发现，在该方法中做了三件事：</p>
<p>将量算完成的宽度measuredWidth保存到View的成员变量mMeasuredWidth中</p>
<p>将量算完成的高度measuredHeight保存到View的成员变量mMeasuredHeight中</p>
<p>最后将View的状态位mPrivateFlags设置为已量算状态</p>
<p>量算完成的尺寸的state</p>
<p>至此，View的量算过程就完成了，但是View的父ViewGroup如何读取到View量算的结果呢？</p>
<p>为此，View提供了三组方法，分别是： </p>
<ol>
<li>getMeasuredWidth和getMeasuredHeight方法 </li>
<li>getMeasuredWidthAndState和getMeasuredHeightAndState方法 </li>
<li>getMeasuredState方法</li>
</ol>
<p>有些人可能会纳闷，只要有了第一组方法不就行了吗？后面那两组方法有啥用？</p>
<p>此处我们要再仔细研究一下View中保存量算结果的成员变量mMeasuredWidth和mMeasuredHeight，下面的讨论我们都只讨论宽度，理解了宽度的处理方式，高度也是完全一样的。</p>
<p>mMeasuredWidth是一个Int类型的值，其是由4个字节组成的。</p>
<p>我们先假设mMeasuredWidth只存储了量算完成的宽度信息，而且View的父ViewGroup可以通过相关方法得到该值。但是存在这样一种情况：View在量算时，父ViewGroup给其传递的widthMeasureSpec中的specMode的值是AT_MOST，specSize是100，但是View的最小宽度是200，显然父ViewGroup指定的specSize不能满足View的大小，但是由于specMode的值是AT_MOST，View在getDefaultSize方法中不得不妥协，只能含泪将量算的最终宽度设置为100。然后其父ViewGroup通过某些方法获取到该View的量算宽度为100时，ViewGroup以为子View只需要100就够了，最终给了子View宽度为100的空间，这就导致了在UI界面上View特别窄，用户体验也就不好。</p>
<p>Android为让其View的父控件获取更多的信息，就在mMeasuredWidth上下了很大功夫，虽然是一个Int值，但是想让它存储更多信息，具体来说就是把mMeasuredWidth分成两部分：</p>
<p>其高位的第一个字节为第一部分，用于标记量算完的尺寸是不是达到了View想要的宽度，我们称该信息为量算的state信息。<br>其低位的三个字节为第二部分，用于存储实际的量算到的宽度。<br>由此我们可以看出Android真是物尽其用，一个变量能包含两个信息，这个有点类似于measureSpec的道理，但是二者又有不同：</p>
<p>measureSpec是将限制条件mode从ViewGroup传递给其子View。<br>mMeasuredWidth、mMeasuredHeight是将带有量算结果的state标志位信息从View传递给其父ViewGroup。<br>那么你可能会问，在本文中我们没看到对mMeasuredWidth的高位字节进行特殊处理啊？我们下面看一下View中的resolveSizeAndState方法。</p>
<p>resolveSizeAndState</p>
<p>resolveSizeAndState方法与getDefaultSize方法类似，其内部实现的逻辑是一样的，但是又有区别，getDefaultSize仅仅返回最终量算的尺寸信息，但resolveSizeAndState除了返回最终尺寸信息还会有可能返回量算的state标志位信息。</p>
<p>resolveSizeAndState方法的源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) &#123;</div><div class="line">    final int specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">    final int specSize = MeasureSpec.getSize(measureSpec);</div><div class="line">    final int result;</div><div class="line">    switch (specMode) &#123;</div><div class="line">        case MeasureSpec.AT_MOST:</div><div class="line">            if (specSize &lt; size) &#123;</div><div class="line">                //当specMode为AT_MOST，并且父控件指定的尺寸specSize小于View自己想要的尺寸时，</div><div class="line">                //我们就会用掩码MEASURED_STATE_TOO_SMALL向量算结果加入尺寸太小的标记</div><div class="line">                //这样其父ViewGroup就可以通过该标记其给子View的尺寸太小了，</div><div class="line">                //然后可能分配更大一点的尺寸给子View</div><div class="line">                result = specSize | MEASURED_STATE_TOO_SMALL;</div><div class="line">            &#125; else &#123;</div><div class="line">                result = size;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        case MeasureSpec.EXACTLY:</div><div class="line">            result = specSize;</div><div class="line">            break;</div><div class="line">        case MeasureSpec.UNSPECIFIED:</div><div class="line">        default:</div><div class="line">            result = size;</div><div class="line">    &#125;</div><div class="line">    return result | (childMeasuredState &amp; MEASURED_STATE_MASK);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当specMode为AT_MOST，并且父控件指定的尺寸specSize小于View自己想要的尺寸时，我们就会用掩码MEASURED_STATE_TOO_SMALL向量算结果加入尺寸太小的标记，这样其父ViewGroup就可以通过该标记其给子View的尺寸太小了，然后可能分配更大一点的尺寸给子View。</p>
<p>getDefaultSize方法只是onMeasure方法中获取最终尺寸的默认实现，其返回的信息比resolveSizeAndState要少，那么什么时候才会调用resolveSizeAndState方法呢？ 主要有两种情况：</p>
<p>Android中的许多layout类都调用了resolveSizeAndState方法，比如LinearLayout在量算过程中会调用resolveSizeAndState方法而非getDefaultSize方法。<br>我们自己在实现自定义的View或ViewGroup时，我们可以重写onMeasure方法，并在该方法内调用resolveSizeAndState方法。<br>getMeasuredXXX系列方法</p>
<p>现在我们再回过头来看以下三组方法：</p>
<p>getMeasuredWidth和getMeasuredHeight方法<br>该组方法只返回量算结果中的的尺寸信息，去掉了高位字节的state信息，以getMeasuredWidth方法为例，其源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public final int getMeasuredWidth() &#123;</div><div class="line">    //MEASURED_SIZE_MASK的值为0x00ffffff，用mMeasuredWidth与掩码MEASURED_SIZE_MASK进行按位与运算，</div><div class="line">    //可以将返回值中的高位字节的8个bit位全置为0，从而去掉了高位字节的state信息</div><div class="line">    return mMeasuredWidth &amp; MEASURED_SIZE_MASK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>MEASURED_SIZE_MASK的值为0x00ffffff，用mMeasuredWidth与掩码MEASURED_SIZE_MASK进行按位与运算，可以将返回值中的高位字节的8个bit位全置为0，从而去掉了高位字节的state信息</p>
<p>getMeasuredWidthAndState和getMeasuredHeightAndState方法<br>该组方法返回的量算结果中同时包含尺寸和state信息（如果state存在的话），以getMeasuredWidthAndState方法为例，其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final int getMeasuredWidthAndState() &#123;</div><div class="line">    //该方法直接返回成员变量mMeasuredWidth，因为mMeasuredWidth本身已经包含了尺寸以及可能的state信息</div><div class="line">    return mMeasuredWidth;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法直接返回成员变量mMeasuredWidth，因为mMeasuredWidth本身已经包含了尺寸以及可能的state信息</p>
<p>getMeasuredState方法<br>该方法返回的Int值中同时包含宽度量算的state以及高度量算的state，不包含任何的尺寸信息，其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final int getMeasuredState() &#123;</div><div class="line">    //将宽度量算的state存储在Int值的第一个字节中，即高位首字节</div><div class="line">    //将高度量算的state存储在Int值的第三个字节中</div><div class="line">    return (mMeasuredWidth&amp;MEASURED_STATE_MASK)</div><div class="line">            | ((mMeasuredHeight&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT)</div><div class="line">                    &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们简单分析一下以上代码：</p>
<p>掩码MEASURED_STATE_MASK的值为常量0xff000000，其高位字节的8个bit位全为1，剩余低位字节的三个字节的24个bit位全为0</p>
<p>MEASURED_HEIGHT_STATE_SHIFT的值为常量16</p>
<p>当执行(mMeasuredWidth&amp;MEASURED_STATE_MASK)时，将mMeasuredWidth与MEASURED_STATE_MASK进行按位与操作，该表达式的值高位字节保留了量算后宽度的state，过滤掉了其低位三个字节所存储的宽度size</p>
<p>由于我们已经用高位首字节存储了量算后宽度的state，所以高度的state就不能存储在高位首字节了。Android打算把它存储在第三个字节中。(mMeasuredHeight&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT)表示将mMeasuredHeight向右移16位，这样高度的state字节就从原来的第一个字节右移动到了第三个字节，由于高度的state向右移动了，所以其对应的掩码也有相应移动。(MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT)表示state的掩码也从第一个字节右移16位到了第三个字节，即掩码从0xff000000变成了0x0000ff00。然后用右移后的state与右移后的掩码执行按位与操作，这样就在第三个字节保留了高度的state信息，并且过滤掉了第1、2、4字节中的信息，即将这三个字节中的24个bit位置为0。</p>
<p>最后，将我们得到的宽度的state与高度的state进行按位或操作，这样就将宽度和高度的state都保存在一个Int值中：第一个字节存储宽度的state，第三个字节存储高度的state。</p>
<p>##总结</p>
<p>至此，View中量算的关键类以及方法我们基本都涉及到了，我们发现View的measure方法还是比较聪明的，知道如何偷懒利用以前量算过的数据，如果情况有变，那么就调用onMeasure方法进行实际的量算工作，在onMeasure中，View要根据父ViewGroup给其传递进来的widthMeasureSpec和heightMeasureSpec，并结合View自身想要的尺寸，综合考虑，计算出最终的量算的宽度和高度，并存储到相应的成员变量中，这才标志着该View量算有效的完成了，如果没有将值存入到成员变量中，View会抛出异常。在该成员变量中有可能也存储了量算过程中的state信息。由于View的measure已经实现了很多逻辑判断，所以我们在自定义View或ViewGroup时，都不应该重写measure方法，而应该重写onMeasure方法，在其中实现我们自己的量算逻辑。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2016/12/11/Android中View的量算、布局以及绘图机制/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/11/Android中View的量算、布局以及绘图机制/" itemprop="url">
                  Android中View的量算、布局以及绘图机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-11T16:38:25+08:00">
                2016-12-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>为了研究Android中View的布局及绘图机制，我创建了一个非常简单的App，该App只有一个Activity，该Activity对应的layout如下所示：</p>
<pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;
android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;
android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;
android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; tools:context=&quot;.MainActivity&quot;&gt;

&lt;TextView android:text=&quot;@string/hello_world&quot; android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre><p>该布局文件很简单，RelativeLayout下面就一个TextView。</p>
<p>我们启动App后，通过Hierarchy Viewer查看App中的布局层级，如下所示：<br><img src="http://fastabler.online/images/20151016204222311.png" alt=""></p>
<p>从上图我们可以看出，App的根结点是PhoneWindow\$DecorView，此处的\$表示DecorView是PhoneWindow下面的内部类实例。PhoneWindow\$DecorView下面有三个child，分别是LinearLayout实例、View@49da043和View@44ff410。View@49da043表示的是navigationBarBackground，View@44ff410表示的是statusBarBackground。LinearLayout下面有两个child，分别是ViewStub实例和FrameLayout实例，其中ViewStub不需要绘制，所以我们在下面的讨论中可以直接对其忽略。FrameLayout下有一个child，RelativeLayout实例，该RelativeLayout实例对应的就是布局文件activity_main.xml中的RelativeLayout，RelativeLayout下有一个child，即TextView。</p>
<p>以上提到的控件都是View的实例，有的则是ViewGroup的实例，ViewGroup继承自View，PhoneWindow\$DecorView、RelativeLayout、FrameLayout、RelativeLayout都直接或间接继承自ViewGroup，只有ViewGroup实例才能有子节点。</p>
<p>当我们在onCreate()方法中调用setContentView(R.layout.activity_main)方法后，Android会从layout的树形结构中自上而下开始对所有的View进行量算、布局、绘图，具体来说经过以下过程：</p>
<p>Android自上而下对所有View进行量算，这样Android就知道了每个View想要的尺寸大小，即宽高信息</p>
<p>在完成了对所有View的量算工作后，Android会自上而下对所有View进行布局，Android就知道了每个View在其父控件中的位置，即View到其父控件四边的left、right、top、bottom</p>
<p>在完成了对所有View的布局工作后，Android会自上而下对所有View进行绘图，这样Android就将所有的View渲染到屏幕上了</p>
<p>以下是涉及到的相关类的源码： </p>
<p><a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/view/View.java" target="_blank" rel="external">View源码</a></p>
<p><a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/view/ViewGroup.java" target="_blank" rel="external">ViewGroup源码</a></p>
<p><a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/view/ViewRootImpl.java" target="_blank" rel="external">ViewRootImpl源码</a></p>
<p><a href="https://github.com/android/platform_frameworks_base/blob/d59921149bb5948ffbcb9a9e832e9ac1538e05a0/core/java/com/android/internal/policy/PhoneWindow.java" target="_blank" rel="external">PhoneWindow\$DecorView源码</a></p>
<p><a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/widget/LinearLayout.java" target="_blank" rel="external">LinearLayout源码</a></p>
<p><a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/widget/FrameLayout.java" target="_blank" rel="external">FrameLayout源码</a></p>
<p><a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/widget/RelativeLayout.java" target="_blank" rel="external">RelativeLayout源码</a></p>
<p><a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/widget/TextView.java" target="_blank" rel="external">TextView源码</a></p>
<h2 id="量算"><a href="#量算" class="headerlink" title="量算"></a>量算</h2><h3 id="关于Measure："><a href="#关于Measure：" class="headerlink" title="关于Measure："></a>关于Measure：</h3><p>View用measure()方法进行量算，量算的目的是View让其父节点知道它想要多大的尺寸，所以说量算是后面对View进行布局以及绘图的基础。</p>
<p>View的measure()方法中会执行onMeasure()方法，View类本身的onMeasure()方法不是空方法，其将量算完的结果保存到View中。View的子类不应该重写measure()方法，如果需要的话应该重写onMeasure()方法，ViewGroup的子类都应该重写onMeasure()方法，比如PhoneWindow\$DecorView、RelativeLayout、FrameLayout、RelativeLayout都重写了onMeasure()方法，这些类都在onMeasure()方法中遍历child，并调用child的measure()方法，对child进行量算，纵向递归进行，从而实现自上而下对View树进行量算，直至完成对叶子节点View的量算。</p>
<p>量算的起点是ViewRootImpl类，ViewRootImpl是根View，即View树上面的根结点，严格来说ViewRootImpl不属于View，其实现了ViewParent接口， 其下才是PhoneWindow\$DecorView。</p>
<p>Android在对View树进行自上而下的量算时，采用的是深度优先算法，而非广度优先算法，即遍历到某个View时，Android会首先沿着该View一直纵向遍历并量算到处于叶子节点的View，只有对该View及其所有子孙View（如果存在子孙View的话）完成量算后，才会量算该View的兄弟节点View。</p>
<p>以下是Android对所有View自上而下量算的调用过程：</p>
<p><img src="http://fastabler.online/images/20151017110657231.png" alt=""></p>
<p>由上我们可以看出，首先ViewRootImpl执行了doTraversal()和performTraversals() 方法，然后执行ViewRootImpl的performMeasure()方法，该方法是Android对所有View进行量算的起点。在该方法中会从ViewRootImpl开始自上而上对View树进行遍历，首先ViewRootImpl对PhoneWindow\$DecorView进行量算，在执行到PhoneWindow\$DecorView的onMeasure()方法时，其遍历所有的child，对依次它们进行量算，首先对调用LinearLayout的measure()方法，对第一个子节点LinearLayout进行量算。</p>
<p>LinearLayout在measure()方法中会调用onMeasure()方法，在该方法中LinearLayout调用了measureVertical()方法，该方法会遍历其child并对其进行量算，由于其子节点ViewStub不用于渲染，所以此处不对其量算，对其忽略，对另一个child FrameLayout进行量算，调用FrameLayout的measure()方法。</p>
<p>FrameLayout在执行measure()方法时会执行onMeasure()方法，在该方法中会遍历所有的child，并对它们进行量算。其下只有一个child，即RelativeLayout，调用RelativeLayout的measure()方法，对其进行量算。</p>
<p>RelativeLayout在measure()方法中会执行onMeasure()方法，在该方法中会遍历所有的child，并对它们进行量算。其下只有一个child，即TextView，调用TextView的measure()方法对其进行量算，在其中会执行onMeasure()方法。</p>
<p>以上完成了对View树中LinearLayout及其所有子算View的量算工作，之后会对PhoneWindow\$DecorView中的另外两个View进行量算，这也体现了Android采用深度优先算法对View树进行遍历量算的过程。View@49da0d3和View@44ff410会依次执行measure()方法和onMeasure()方法。</p>
<p>这样整个View树自上而下的量算过程就结束了，经过量算Android知道了各个View想要渲染的尺寸大小，即宽度和高度信息。</p>
<p>关于量算中measure()和onMeasure()方法的一些细节可参见博文<a href="http://blog.csdn.net/iispring/article/details/49403315" target="_blank" rel="external">《源码解析Android中View的measure量算过程》</a>。</p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="关于Layout："><a href="#关于Layout：" class="headerlink" title="关于Layout："></a>关于Layout：</h3><p>布局的前提是已经对View进行了量算，View通过调用layout()方法进行布局，布局的目的是让Android知道View在其父控件中的位置，即距父控件四边的距离left、right、top、bottom。布局是绘图的基础，只有完成了布局，才能对View进行绘图。</p>
<p>View的layout()方法中会执行onLayout()方法，View类本身的onLayout()是空方法。View的子类不应该重写layout()方法，如果需要的话应该重写其onLayout()方法，ViewGroup的子类都应该重写onLayout()方法，比如PhoneWindow\$DecorView、RelativeLayout、FrameLayout、RelativeLayout都重写了onLayout()方法，这些类都在onLayout()方法中遍历child，并调用child的layout()方法，对child进行布局，纵向递归进行，从而实现自上而下对View树进行布局，直至完成对叶子节点View的布局。</p>
<p>布局的起点也是ViewRootImpl类，ViewRootImpl是根View，即View树上面的根结点，严格来说ViewRootImpl不属于View，其实现了ViewParent接口， 其下才是PhoneWindow\$DecorView。</p>
<p>Android在对View树进行自上而下的布局时，采用的是深度优先算法，而非广度优先算法，即遍历到某个View时，Android会首先沿着该View一直纵向遍历并布局到处于叶子节点的View，只有对该View及其所有子孙View（如果存在子孙View的话）完成布局后，才会布局该View的兄弟节点View。</p>
<p>Android中的布局过程与之前上面提到的量算过程很类似，以下是Android对所有View自上而下布局的调用过程：</p>
<p><img src="http://fastabler.online/images/20151017124528354.png" alt=""></p>
<p>由上我们可以看出，首先ViewRootImpl执行了doTraversal()和performTraversals() 方法，然后执行ViewRootImpl的performLayout()方法，该方法是Android对所有View进行布局的起点。在该方法中会从ViewRootImpl开始自上而下对View树进行遍历，首先ViewRootImpl执行PhoneWindow\$DecorView的layout()方法，对其进行布局。</p>
<p>PhoneWindow\$DecorView在其layout()方法中会执行onLayout()方法，PhoneWindow\$DecorView会在onLayout()方法中遍历其所有的child，并依次调用child的layout()方法，实现对child的布局。首先调用其第一个child LinearLayout的layout()方法。</p>
<p>LinearLayout在layout()方法中会执行onLayout()方法，在该方法中会调用layoutVertical()方法，该方法会遍历其所有的child并依次调用child的layout()方法进行布局。由于其子节点ViewStub不用于渲染，所以此处不对其进行布局，对其忽略，对另一个child FrameLayout进行布局，调用FrameLayout的layout()方法。</p>
<p>FrameLayout在layout()方法中会执行onLayout()方法，在该方法中会调用layoutChildren()方法，该方法会遍历其所有的child并依次调用child的layout()方法进行布局。其下只有一个child，即RelativeLayout，执行RelativeLayout的layout()方法，对其进行布局。</p>
<p>RelativeLayout在layout()方法中会执行onLayout()方法，在该方法中会遍历所有的child并依次调用child的layout()方法进行布局。其下只有一个child，即TextView，调用TextView的layout()方法对其进行布局，在其中会执行onLayout()方法。</p>
<p>以上完成了对View树中LinearLayout及其所有子孙View的布局工作，之后会对PhoneWindow\$DecorView中的另外两个View进行布局，这也体现了Android采用深度优先算法对View树进行遍历布局的过程。View@49da043和View@44ff410会依次执行layout()方法和onLayout()方法。</p>
<p>这样整个View树自上而下的布局过程就结束了，经过布局Android知道了各个View在其父控件中的位置。</p>
<p>关于布局layout的细节可参见博文<a href="http://blog.csdn.net/iispring/article/details/50366021" target="_blank" rel="external">《源码解析Android中View的layout布局过程》</a>。</p>
<h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><h3 id="关于Draw："><a href="#关于Draw：" class="headerlink" title="关于Draw："></a>关于Draw：</h3><p>绘图的前提是已经对View进行了量算和布局，View通过调用draw()方法进行绘图，绘图的目的就是让View在UI界面上呈现出来。</p>
<p>View的draw()方法中会依次onDraw()和dispatchDraw()方法，View类本身的onDraw()和dispatchDraw()方法都是空方法。View的子类不应该重写draw()方法，如果需要的话应该按具体情况选择重写onDraw()方法或dispatchDraw()方法，具体来说：</p>
<p>当我们需要自定义一个View（而非ViewGroup）时，我们需要重写View的onDraw()方法以实现对自定义View的绘制，即onDraw()用于绘制View自身UI。<br>Android中的ViewGroup类重写了View中的dispatchDraw()方法，ViewGroup.dispatchDraw()方法会遍历其所有的child，并依次调用child的draw()方法，即dispatchDraw()用于绘制ViewGroup的所有子孙View的UI，这是与onDraw()不同的。由于ViewGroup已经具体实现了dispatchDraw()方法，所以大部分情况下ViewGroup的子类无需再对其进行重写，例如PhoneWindow\$DecorView、RelativeLayout、FrameLayout、RelativeLayout都没有重写dispatchDraw()方法。只有在极少数情况下，为了实现某些特殊需求，我们才有可能重写ViewGroup的dispatchDraw()方法，但是即便重写该方法我们也应该在我们的实现中调用super.dispatchDraw()方法以便实现对子孙View进行绘制。<br>绘图的起点也是ViewRootImpl类，ViewRootImpl是根View，即View树上面的根结点，严格来说ViewRootImpl不属于View，其实现了ViewParent接口， 其下才是PhoneWindow\$DecorView。</p>
<p>Android在对View树进行自上而下的绘图时，采用的也是深度优先算法，而非广度优先算法，即遍历到某个View时，Android会首先沿着该View一直纵向遍历并绘图到处于叶子节点的View，只有对该View及其所有子孙View（如果存在子孙View的话）完成绘图后，才会渲染该View的兄弟节点View。</p>
<p>Android中的绘图过程与之前上面提到的量算、布局过程类似，以下是Android对所有View进行自上而下绘图的调用过程：</p>
<p><img src="http://fastabler.online/images/20151017134329148.png" alt=""></p>
<p>由上我们可以看出，首先ViewRootImpl执行了doTraversal()和performTraversals() 方法，然后执行ViewRootImpl的performDraw()方法，该方法是Android对所有View进行绘图的起点。在该方法中会从ViewRootImpl开始自上而下对View树进行遍历，首先ViewRootImpl执行PhoneWindow\$DecorView的draw()方法，对其绘图。</p>
<p>PhoneWindow\$DecorView在其draw()方法中会依次执行onDraw()方法和dispatchDraw()方法，在dispatchDraw()方法中会遍历所有的child，调用child的draw()方法，对child进行绘图。首先调用其第一个child LinearLayout的draw()方法。</p>
<p>LinearLayout在darw()方法中也会依次执行onDraw()方法和dispatchDraw()方法，在dispatchDraw()方法中会遍历所有的child，调用child的draw()方法，对child进行绘图。由于其子节点ViewStub不用于渲染，所以此处不对其进行绘图，对其忽略，对另一个child FrameLayout进行绘图，调用FrameLayout的draw()方法。</p>
<p>FrameLayout在draw()方法中也会依次执行onDraw()方法和dispatchDraw()方法，在dispatchDraw()方法中会遍历所有的child，调用child的draw()方法，对child进行绘图。其下只有一个child，即RelativeLayout，执行RelativeLayout的draw()方法，对其进行绘图。</p>
<p>RelativeLayout在draw()方法中也会依次执行onDraw()方法和dispatchDraw()方法，在dispatchDraw()方法中会遍历所有的child，调用child的draw()方法，对child进行绘图。其下只有一个child，即TextView，执行TextView的draw()方法，对其进行绘图，并在其中执行TextView的onDraw()方法，对TextView进行实际的渲染。</p>
<p>以上完成了对View树中LinearLayout及其所有子孙View的绘图工作，之后会对PhoneWindow\$DecorView中的另外两个View进行绘图，这也体现了Android采用深度优先算法对View树进行遍历绘图的过程。View@49da043和View@44ff410会依次执行draw()方法和onDraw()方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当我们在onCreate()方法中调用setContentView(R.layout.activity_main)方法后，Android会从layout的树形结构中自上而下开始对所有的View进行量算、布局、绘图：</p>
<p>量算、布局、绘图的起点都是ViewRootImpl</p>
<p>通过调用ViewRootImpl的performMeasure() 方法，开始驱动Android自上而下对所有View进行量算，这样Android就知道了每个View想要的尺寸大小，即宽高信息</p>
<p>在完成了对所有View的量算工作后，通过调用ViewRootImpl的performLayout()方法，开始驱动Android会自上而下对所有View进行布局，Android就知道了每个View在其父控件中的位置，即View到其父控件四边的left、right、top、bottom</p>
<p>在完成了对所有View的布局工作后，通过调用ViewRootImpl的performDraw()方法，开始驱动Android会自上而下对所有View进行绘图，这样Android就将所有的View渲染到屏幕上了</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg"
               alt="fastabler" />
          <p class="site-author-name" itemprop="name">fastabler</p>
          <p class="site-description motion-element" itemprop="description">Efforts can only pass,hard to be excellent.</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fastabler</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  




  
  

  

  

  

  


</body>
</html>

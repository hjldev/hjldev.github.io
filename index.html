<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="Efforts can only pass,hard to be excellent.">
<meta property="og:type" content="website">
<meta property="og:title" content="黄金龙的博客">
<meta property="og:url" content="http://hjlinfo.top/index.html">
<meta property="og:site_name" content="黄金龙的博客">
<meta property="og:description" content="Efforts can only pass,hard to be excellent.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="黄金龙的博客">
<meta name="twitter:description" content="Efforts can only pass,hard to be excellent.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hjlinfo.top/">





  <title> 黄金龙的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ad1350e91810844821a7ad3e1f8ac561";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">黄金龙的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">fastabler</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2018/08/08/Linux安装拓展教程-以安装php-redis为例-适用于所有场景/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content>
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/08/08/Linux安装拓展教程-以安装php-redis为例-适用于所有场景/" itemprop="url">
                  Linux安装php拓展教程,以安装php redis为例,适用于所有场景
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-08T10:59:21+08:00">
                2018-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文以本地虚拟环境homestead为例，通过安装redis扩展来安装其他的扩展，安装流程基本雷同。</p>
<p>本地虚拟环境homestead中php环境没有redis扩展的窘境，网上的教程也不通用，因为那些教程都只是针对单一机器单一版本php环境下的安装方法，而homestead安装了多个php版本（针对多个php版本安装，单一php版本安装更简单），安装方式略有不同，怎么办？往下看：</p>
<p>注意：命令权限不够时请自动在命令前加上sudo前缀提权；教程还要求你会使用vi编辑器简单地写入文件内容（当然你有其它方法创建文件内容也可以）。</p>
<h2 id="使用vagrant命令的ssh选项连接到homestead"><a href="#使用vagrant命令的ssh选项连接到homestead" class="headerlink" title="使用vagrant命令的ssh选项连接到homestead"></a>使用vagrant命令的ssh选项连接到homestead</h2><p><code>vagrant ssh</code></p>
<h2 id="下载编译php的redis扩展"><a href="#下载编译php的redis扩展" class="headerlink" title="下载编译php的redis扩展"></a>下载编译php的redis扩展</h2><p><code>$ git clone https://github.com/phpredis/phpredis.git</code><br><code>$ cd phpredis</code><br><code>$ /usr/bin/phpize7.1</code>（不同php版本的情况下phpize版本不同，如果是单一版本，那么只有一个phpize<br><code>$ ./configure --with-php-config=/usr/bin/php-config7.1</code>（这里边也需要根据情况指定php-config的版本，且和phpize的版本保持一致。如果只有一个版本，那么只有一个php-config）<br><code>$ make &amp;&amp; make install</code></p>
<p>编译完成后，redis的php扩展在module目录中，它的文件名是redis.so</p>
<h2 id="查看php的extension-dir"><a href="#查看php的extension-dir" class="headerlink" title="查看php的extension_dir"></a>查看php的extension_dir</h2><p><code>php -i|grep extension_dir</code></p>
<p>在小黑窗中可能会见到如下字段</p>
<p><code>extension_dir =&gt; /usr/lib/php/20160303 =&gt; /usr/lib/php/20160303</code></p>
<p>这说明php的扩展目录是/usr/lib/php/20160303</p>
<p>或者你用phpinfo()输出一个页面，在里面找extension_dir也可以找到</p>
<h2 id="把redis-so扩展模块移入php扩展目录中"><a href="#把redis-so扩展模块移入php扩展目录中" class="headerlink" title="把redis.so扩展模块移入php扩展目录中"></a>把redis.so扩展模块移入php扩展目录中</h2><p><code>sudo mv ./module/redis.so  /usr/lib/php/20160303</code></p>
<p>注意，前提要求当前工作目录是在刚才编译的phpredis目录中</p>
<h2 id="添加php配置文件的ini文件"><a href="#添加php配置文件的ini文件" class="headerlink" title="添加php配置文件的ini文件"></a>添加php配置文件的ini文件</h2><p>创建一个文件</p>
<p><code>sudo touch /etc/php/7.1/fpm/conf.d/20-redis.ini</code><br>使用vi编辑器写入如下内容:</p>
<p><code>extension=redis.so</code></p>
<p>记得使用vi编辑器时使用：wq命令保存</p>
<h2 id="万事大吉，重启php-fpm"><a href="#万事大吉，重启php-fpm" class="headerlink" title="万事大吉，重启php-fpm"></a>万事大吉，重启php-fpm</h2><p>命令：</p>
<p><code>/etc/phpredis$ sudo service php7.1-fpm restart</code> </p>
<p>再次在网页中使用phpinfo()时就会发现，redis扩展出现了，new Redis()可用了。</p>
<p>同理，什么mongodb的扩展啊什么的，也都能够通过类似的方法完成安装</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2018/06/28/使用容器jenkins-docker自动化部署项目/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content>
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/06/28/使用容器jenkins-docker自动化部署项目/" itemprop="url">
                  使用容器jenkins+docker自动化部署项目
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-28T23:49:08+08:00">
                2018-06-28
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于这篇文章的产生"><a href="#关于这篇文章的产生" class="headerlink" title="关于这篇文章的产生"></a>关于这篇文章的产生</h2><p>直接使用jenkins部署项目的流程很简单，直接配置完maven+git插件，然后创建工程可以直接部署，后面再加几个简单的shell脚本命令就完事了。现在我有一台1核2G内存的小霸王，想要所有服务docker化，即当内存不够用的时候能迅速结束掉某个不相关的服务，保存系统最大程度的可用性，各个服务之间保持独立性。首先解决程序自动化部署问题。docker下jenkins+由jenkins构建完成后的系统打包成镜像运行。我们假设宿主机是完全纯净的系统，即只有一个docker服务，没有java运行环境，我们只需要由docker提供所需要的服务就可以了</p>
<h3 id="首先部署jenkins"><a href="#首先部署jenkins" class="headerlink" title="首先部署jenkins"></a>首先部署jenkins</h3><p>获取jenkins镜像（该步骤可以省略，为了让流程清晰，我还是加上了）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull jenkins</span><br></pre></td></tr></table></figure></p>
<p>在用户根目录创建一个共享文件夹jenkins_home，赋予1000组跟用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir jenkins_home</span><br><span class="line">chown -R 1000:1000 jenkins_home</span><br></pre></td></tr></table></figure>
<p>直接启动镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name jenkins -p 8085:8080 -p 50000:50000 -v ~/jenkins_home:/var/jenkins_home -u 0 jenkins</span><br></pre></td></tr></table></figure>
<p>启动镜像之后访问域名加8085就可以进入jenkins初始化配置阶段了，具体的页面不再展示，网上有很多安装jenkins的教程，根据提示一步步来就可以了。<strong>需要注意的是：在安装插件的时候会有一个推荐设置，这时候我们最好不要勾选，因为插件安装的有点多，很多不是我们需要的，如果网络不好的话会安装失败，后面我们只需要安装一个git插件和一个maven插件还有一个ssh基本就能满足我们的需要了</strong><br>推荐安装的几个插件</p>
<ul>
<li>Deploy to container Plugin</li>
<li>Git Parameter Plug-In</li>
<li>Maven Integration plugin</li>
<li>Publish Over SSH</li>
<li>Safe Restart Plugin</li>
</ul>
<p>jenkins所有构建的目录都会映射到宿主机~/jenkins_home目录下面，目录结构也是顾名思义，plugins表示安装的插件，插件的调用命令放在tools里面，这个我们后面会用到。workspace目录就是工作目录，即所有的构建项目都会放在这里面，构建完成之后我们可以随意操作里面的资源</p>
<h3 id="开始部署项目"><a href="#开始部署项目" class="headerlink" title="开始部署项目"></a>开始部署项目</h3><p>配置好jenkins之后创建maven构建项目，然后最后配置一下一个shell脚本。<br>maven的项目会自动进行打包处理，我们需要处理的是打包之后如果构建成docker镜像来直接运行。<br>由于我们的jenkins是在容器内的，所以无法直接调用宿主机的docker命令来构建镜像。有两种方法可以调用到docker，一种是网上比较通用的，在启动jenkins的时候将docker运行环境目录配置到jenkins里面可以调用宿主机，这种方法我没有试过。另一种是我用的比较简单粗暴的方法，直接由容器内jenkins通过ssh连接到宿主机，然后根据映射到宿主机内的workspace去执行命令。<br>主要是执行这个shell脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">mvn install</span><br><span class="line">echo please wait, connect host and build images.</span><br><span class="line">ssh root@172.18.0.1 &gt; /dev/null 2&gt;&amp;1 &lt;&lt; hjlinfo</span><br><span class="line">cd /root/jenkins_home/workspace/mall</span><br><span class="line">/root/jenkins_home/tools/hudson.tasks.Maven_MavenInstallation/maven3.6/bin/mvn install</span><br><span class="line">docker stop mall-admin</span><br><span class="line">docker rm mall-admin</span><br><span class="line">docker image rm stingers/mall-admin</span><br><span class="line">cd /root/jenkins_home/workspace/mall/mall-admin</span><br><span class="line">/root/jenkins_home/tools/hudson.tasks.Maven_MavenInstallation/maven3.6/bin/mvn clean package docker:build</span><br><span class="line">docker run --name mall-admin -d -p 8086:8086 stingers/mall-admin</span><br><span class="line">exit</span><br><span class="line">hjlinfo</span><br><span class="line">echo done!</span><br></pre></td></tr></table></figure>
<p>这样就实现了容器jenkins+docker自动化部署。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2017/04/10/SQL优化/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content>
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/10/SQL优化/" itemprop="url">
                  数据库优化方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-10T11:22:36+08:00">
                2017-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h1><h3 id="负向查询不能使用索引"><a href="#负向查询不能使用索引" class="headerlink" title="负向查询不能使用索引"></a>负向查询不能使用索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>应该修改为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from user where id in (2,5,6);</span><br></pre></td></tr></table></figure>
<h3 id="前导模糊查询不能使用索引"><a href="#前导模糊查询不能使用索引" class="headerlink" title="前导模糊查询不能使用索引"></a>前导模糊查询不能使用索引</h3><p>如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%zhangsan'</span></span><br></pre></td></tr></table></figure>
<p>非前导则可以:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'zhangsan%'</span></span><br></pre></td></tr></table></figure></p>
<p>建议可以考虑使用 <code>Lucene</code> 等全文索引工具来代替频繁的模糊查询。</p>
<h3 id="数据区分不明显的不建议创建索引"><a href="#数据区分不明显的不建议创建索引" class="headerlink" title="数据区分不明显的不建议创建索引"></a>数据区分不明显的不建议创建索引</h3><p>如 user 表中的性别字段，可以明显区分的才建议创建索引，如身份证等字段。</p>
<h3 id="字段的默认值不要为-null"><a href="#字段的默认值不要为-null" class="headerlink" title="字段的默认值不要为 null"></a>字段的默认值不要为 null</h3><p>这样会带来和预期不一致的查询结果。</p>
<h3 id="在字段上进行计算不能命中索引"><a href="#在字段上进行计算不能命中索引" class="headerlink" title="在字段上进行计算不能命中索引"></a>在字段上进行计算不能命中索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> FROM_UNIXTIME(create_time) &lt; <span class="keyword">CURDATE</span>();</span><br></pre></td></tr></table></figure>
<p>应该修改为:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> create_time &lt; FROM_UNIXTIME(<span class="keyword">CURDATE</span>());</span><br></pre></td></tr></table></figure>
<h3 id="最左前缀问题"><a href="#最左前缀问题" class="headerlink" title="最左前缀问题"></a>最左前缀问题</h3><p>如果给 user 表中的 username pwd 字段创建了复合索引那么使用以下SQL 都是可以命中索引:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username=<span class="string">'zhangsan'</span> <span class="keyword">and</span> pwd =<span class="string">'axsedf1sd'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> pwd =<span class="string">'axsedf1sd'</span> <span class="keyword">and</span> username=<span class="string">'zhangsan'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username=<span class="string">'zhangsan'</span></span><br></pre></td></tr></table></figure>
<p>但是使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> pwd =<span class="string">'axsedf1sd'</span></span><br></pre></td></tr></table></figure>
<p>是不能命中索引的。</p>
<h3 id="如果明确知道只有一条记录返回"><a href="#如果明确知道只有一条记录返回" class="headerlink" title="如果明确知道只有一条记录返回"></a>如果明确知道只有一条记录返回</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username=<span class="string">'zhangsan'</span> <span class="keyword">limit</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以提高效率，可以让数据库停止游标移动。</p>
<h3 id="不要让数据库帮我们做强制类型转换"><a href="#不要让数据库帮我们做强制类型转换" class="headerlink" title="不要让数据库帮我们做强制类型转换"></a>不要让数据库帮我们做强制类型转换</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> telno=<span class="number">18722222222</span></span><br></pre></td></tr></table></figure>
<p>这样虽然可以查出数据，但是会导致全表扫描。</p>
<p>需要修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from user where telno=&apos;18722222222&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="如果需要进行-join-的字段两表的字段类型要相同"><a href="#如果需要进行-join-的字段两表的字段类型要相同" class="headerlink" title="如果需要进行 join 的字段两表的字段类型要相同"></a>如果需要进行 join 的字段两表的字段类型要相同</h3><p>不然也不会命中索引。</p>
<h1 id="数据库水平垂直拆分"><a href="#数据库水平垂直拆分" class="headerlink" title="数据库水平垂直拆分"></a>数据库水平垂直拆分</h1><p>当数据库量非常大的时候，DB 已经成为系统瓶颈时就可以考虑进行水平垂直拆分了。</p>
<h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><p>一般水平拆分是根据表中的某一字段(通常是主键 ID )取模处理，将一张表的数据拆分到多个表中。这样每张表的表结构是相同的但是数据不同。</p>
<p>不但可以通过 ID 取模分表还可以通过时间分表，比如每月生成一张表。<br>按照范围分表也是可行的:一张表只存储 <code>0~1000W</code>的数据，超过只就进行分表，这样分表的优点是扩展灵活，但是存在热点数据。</p>
<p>按照取模分表拆分之后我们的查询、修改、删除也都是取模。比如新增一条数据的时候往往需要一张临时表来生成 ID,然后根据生成的 ID 取模计算出需要写入的是哪张表(也可以使用<a href="https://github.com/crossoverJie/Java-Interview/blob/master/MD/ID-generator.md" target="_blank" rel="noopener">分布式 ID 生成器</a>来生成 ID)。</p>
<p>分表之后不能避免的就是查询要比以前复杂，通常不建议 <code>join</code> ，一般的做法是做两次查询。</p>
<h2 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h2><p>当一张表的字段过多时则可以考虑垂直拆分。<br>通常是将一张表的字段才分为主表以及扩展表，使用频次较高的字段在一张表，其余的在一张表。</p>
<p>这里的多表查询也不建议使用 <code>join</code> ，依然建议使用两次查询。</p>
<h2 id="拆分之后带来的问题"><a href="#拆分之后带来的问题" class="headerlink" title="拆分之后带来的问题"></a>拆分之后带来的问题</h2><p>拆分之后由一张表变为了多张表，一个库变为了多个库。最突出的一个问题就是事务如何保证。</p>
<h3 id="两段提交"><a href="#两段提交" class="headerlink" title="两段提交"></a>两段提交</h3><h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>如果业务对强一致性要求不是那么高那么最终一致性则是一种比较好的方案。</p>
<p>通常的做法就是补偿，比如 一个业务是 A 调用 B，两个执行成功才算最终成功，当 A 成功之后，B 执行失败如何来通知 A 呢。</p>
<p>比较常见的做法是 失败时 B 通过 MQ 将消息告诉 A，A 再来进行回滚。这种的前提是 A 的回滚操作得是幂等的，不然 B 重复发消息就会出现问题。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2017/03/09/基于资源的权限管理-Resource-Based-Access-Control/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content>
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/09/基于资源的权限管理-Resource-Based-Access-Control/" itemprop="url">
                  基于资源的权限管理(Resource-Based Access Control)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-09T22:26:31+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文讨论以角色概念进行的权限管理策略及主要以基于角色的机制进行权限管理是远远不够的。同时我将讨论一种我认为更好的权限管理方式。</p>
<h2 id="什么是角色"><a href="#什么是角色" class="headerlink" title="什么是角色"></a>什么是角色</h2><p>当说到程序的权限管理时，人们往往想到角色这一概念。角色是代表一系列可执行的操作或责任的实体，用于限定你在软件系统中能做什么、不能做什么。用户帐号往往与角色相关联，因此，一个用户在软件系统中能做什么取决于与之关联的各个角色。<br>例如，一个用户以关联了”项目管理员”角色的帐号登录系统，那这个用户就可以做项目管理员能做的所有事情――如列出项目中的应用、管理项目组成员、产生项目报表等。<br>从这个意义上来说，角色更多的是一种行为的概念：它表示用户能在系统中进行的操作。</p>
<h2 id="基于角色的访问控制（Role-Based-Access-Control）"><a href="#基于角色的访问控制（Role-Based-Access-Control）" class="headerlink" title="基于角色的访问控制（Role-Based Access Control）"></a>基于角色的访问控制（Role-Based Access Control）</h2><p>既然角色代表了可执行的操作这一概念，一个合乎逻辑的做法是在软件开发中使用角色来控制对软件功能和数据的访问。你可能已经猜到，这种权限控制方法就叫基于角色的访问控制(Role-Based Access Control)，或简称为RBAC。<br>有两种正在实践中使用的RBAC访问控制方式：隐式(模糊)的方式和显示(明确)的方式。<br>今天依旧有大量的软件应用是使用隐式的访问控制方式。但我肯定的说，显示的访问控制方式更适合于当前的软件应用。</p>
<h2 id="隐式的访问控制"><a href="#隐式的访问控制" class="headerlink" title="隐式的访问控制"></a>隐式的访问控制</h2><p>前面提到，角色代表一系列的可执行的操作。但我们如何知道一个角色到底关联了哪些可执行的操作呢？<br>答案是：目前的大多数应用，你并能不明确的知道一个角色到底关联了哪些可执行操作。可能你心里是清楚的（你知道一个有”管理员”角色的用户可以锁定用户帐号、进行系统配置；一个关联了”消费者”这一角色的用户可在网站上进行商品选购），但这些系统并没有明确定义一个角色到底包含了哪些可执行的行为。<br>拿”项目管理员”来说，系统中并没有对”项目管理员”能进行什么样的操作进行明确定义，它仅是一个字符串名词。开发人员通常将这个名词写在程序里以进行访问控制。例如，判断一个用户是否能查看项目报表，程序员可能会编码如下：</p>
<ul>
<li>代码块1. 隐式地基于角色的权限控制:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (user.hasRole(&quot;Project Manager&quot;) ) &#123;</span><br><span class="line">    //show the project report button</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    //don&apos;t show the button</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在上面的示例代表中，开发人员判断用户是否有”项目管理员”角色来决定是否显示查看项目报表按钮。请注意上面的代码，它并没有明确语句来定义”项目管理员”这一角色到底包含哪些可执行的行为，它只是假设一个关联了项目管理员角色的用户可查看项目报表，而开发人员也是基于这一假设来写 if/else 语句。</p>
<h2 id="脆弱的权限策略"><a href="#脆弱的权限策略" class="headerlink" title="脆弱的权限策略"></a>脆弱的权限策略</h2><p>像上面的权限访问控制是非常脆弱的。一个极小的权限方面的需求的变动都可能导致上面的代码需要重新修改。<br>举例来说，假如某一天这个开发团队被告知：“哦，顺便说一下，我们需要一个’部门管理员’角色，他们也可以查看项目报表。请做到这一点。”<br>这种情况下，开发人员需要找到上面的代码块并将其修改为：</p>
<ul>
<li>代码块2. 修改过的隐式的基于角色的权限控制:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (user.hasRole(&quot;Project Manager&quot;) || user.hasRole(&quot;Department Manager&quot;) ) &#123;</span><br><span class="line">    //show the project report button</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    //don&apos;t show the button</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>随后，开发人员需要更新他的测试用例、重新编译系统，还可能需要重走软件质量控制(QA)流程，然后再重新部署上线。这一切仅仅是因为一个微小的权限方面的需求变动！<br>后面如果需求方又回来告诉你说我们又有另一个角色可查看报表，或是前面关于”部门管理员可查看报表”的需求不再需要了，岂不把人累死了。<br>如果需求方要求动态地创建、删除角色以便他们自己配置角色，又该如何应对呢？<br>像上面的情况，这种隐式的(静态字符串)形式的基于角色的访问控制方式难以满足需求。理想的情况是如果权限需求变动不需要修改任何代码。怎样才能做到这一点呢？</p>
<h2 id="显式地访问控制：更好的选择"><a href="#显式地访问控制：更好的选择" class="headerlink" title="显式地访问控制：更好的选择"></a>显式地访问控制：更好的选择</h2><p>从上面的例子我们看到，当权限需求发生变动时，隐式的权限访问控制方式会给程序开发带来沉重的负担。如果能有一种方式在权限需求发生变化时不需要去修改代码就能满足需求那就好了。理解的情况是，即使是正在运行的系统，你也可以修改权限策略却又不影响最终用户的使用。当你发现某些错误的或危险的安全策略时，你可以迅速地修改策略配置，同时你的系统还能正常使用，而不需要重构代码重新部署系统。<br>怎样才能达到上面的理想效果呢？我们可以通过显式的(明确的)界定我们在应用中能做的操作来进行。<br>回顾上面隐式的权限控制的例子，思考一下这些代码最终的目的，想一下它们最终是要做什么样的控制？<br>从根本上说，这些代码最终是在保护资源(项目报表)，是要界定一个用户能对这些资源进行什么样的操作(查看/修改)。当我们将权限访问控制分解到这种最原始的层次，我们就可以用一种更细粒度(更富有弹性)的方式来表达权限控制策略。<br>我们可以修改上面的代码块，以基于资源的语义来更有效地进行权限访问控制：</p>
<ul>
<li>代码块3. 显式的权限控制:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (user.isPermitted(&quot;projectReport:view:12345&quot;)) &#123;</span><br><span class="line">    //show the project report button</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    //don&apos;t show the button</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的例子中，我们可明确地看到我们是在控制什么。不要太在意冒号分隔的语法，这仅是一个例子，重点是上面的语句明确地表示了“如果当前用户允许查看编号为12345的项目报表，则显示项目报表按钮”。也就是说，我们明确地说明了一个用户帐号可对一个的资源实例进行的具体的操作。</p>
<h2 id="为什么说这种方式更好"><a href="#为什么说这种方式更好" class="headerlink" title="为什么说这种方式更好"></a>为什么说这种方式更好</h2><p>上面最后的示例代码块与前面的代码的主要区别：最后的代码块是基于什么是受保护的， 而不是谁可能有能力做什么。看似简单的区别，但后者对系统开发及部署有着深刻的影响：</p>
<ol>
<li><p>更少的代码重构：我们是基于系统的功能(系统的资源及对资源的操作)来进行权限控制，而相应来说，系统的功能需求一旦确定下来后，一段时间内对它的改动相应还是比较少的。只是当系统的功能需求改变时，才会涉及到权限代码的改变。例如上面提到的查看项目报表的功能，显式的权限控制方式不会像传统隐式的RBAC权限控制那样因不同的用户/角色要进行这个操作就需要重构代码；只要这个功能存在，显式的方式的权限控制代码是不需要改变的。</p>
</li>
<li><p>更直观：保护资源对象、控制对资源对象的操作(对象及对象的行为)，这样的权限控制方式更符合人们的思想习惯。正因为符合这种直观的思维方式，面向对象的编辑思想及REST通信模型变得非常成功。</p>
</li>
<li><p>更有弹性：上面的示例代码中没有写死哪些用户、组或角色可对资源进行什么操作。这意味着它可支持任何安全模型的设计。例如，可以将操作（权限）直接分配给用户 ，或者他们可以被分配到一个角色，然后再将角色与用户关联，或者将多个角色关联到组(group)上，等等。你完全可以根据应用的特点定制权限模型。</p>
</li>
<li><p>外部安全策略管理：由于源代码只反映资源和行为，而不是用户、组和角色，这样资源/行为与用户、组、角色的关联可以通过外部的模块或专用工具或管理控制台来完成。这意味着在权限需求变化时，开发人员并不需要花费时间来修改代码，业务分析师甚至最终用户就可以通过相应的管理工具修改权限策略配置。</p>
</li>
<li><p>可在运行环境做修改：因为基于资源的权限控制代码并不依赖于行为的主体(如组、角色、用色)，你并没有将行为的主体的字符名词写在代码中，所以你甚至可以在程序运行的时候通过修改主体能对资源进行的操作这样一些方式，通过配置的方式就可应对权限方面需求的变动，再也不需要像隐式的RBAC方式那样需要重构代码。</p>
</li>
</ol>
<h2 id="RBAC新解：Resource-Based-Access-Control"><a href="#RBAC新解：Resource-Based-Access-Control" class="headerlink" title="RBAC新解：Resource-Based Access Control"></a>RBAC新解：Resource-Based Access Control</h2><p>对于上面列出的诸多好处，我重点要说是这种显式的机制带给我们的富有弹性的权限模型。<br>如果你仍想保留或模拟传统的基于角色的权限访问控制，你可以将权限(可执行的操作)直接分配给某个角色。这种情况下，你依旧是在使用基于角色的权限访问控制方式(不同之处在于你需要明确地界定角色中的权限，而不是传统的使用角色字符串隐式地进行权限控制)。<br>但在这种新的模型下，已不必再局限于角色了。你可以将权限直接分配给用户、组或其它你觉得可以的对象。<br>因为上面显式地、基于资源的权限访问控制的诸多好处，或许可以给RBAC一个新的定义：“Resource-Based Access Control”。只是我的一个想法：）</p>
<h2 id="现实世界的例子：Apache-Shiro"><a href="#现实世界的例子：Apache-Shiro" class="headerlink" title="现实世界的例子：Apache Shiro"></a>现实世界的例子：Apache Shiro</h2><p>如果你好奇现实世界有没有被多个系统使用的基于资源的权限控制框架，你可以了解一下Apache Shiro。它是一个java平台的现代权限管理框架。通过它的权限(Permission)概念，Shiro很好地支持基于资源的权限访问控制。<br>当然，并不需要借用Shiro来理解本文所说的一些概念，但Shiro对理解本文所讨论的概念及示例有一定的帮助。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2017/02/10/nginx基本使用/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content>
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/10/nginx基本使用/" itemprop="url">
                  nginx基本使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-10T15:24:42+08:00">
                2017-02-10
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>主要介绍一下Nginx的最基本功能以及简单配置</p>
<h2 id="1、静态HTTP服务器"><a href="#1、静态HTTP服务器" class="headerlink" title="1、静态HTTP服务器"></a>1、静态HTTP服务器</h2><p>首先，Nginx是一个HTTP服务器，可以将服务器上的静态文件（如HTML、图片）通过HTTP协议展现给客户端。<br>配置: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	listen 80;</span><br><span class="line">	lication / &#123;	</span><br><span class="line">		root /usr/share/nginx/html; #静态文件路径</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、反向代理"><a href="#2、反向代理" class="headerlink" title="2、反向代理"></a>2、反向代理</h2><p>什么是反向代理？<br>客户端本来可以直接通过HTTP协议访问某网站应用服务器，如果网站管理者在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。<br><img src="http://fastabler.online/images/20150517220513170.png" alt="反向代理"><br>配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	listen 80;</span><br><span class="line">	location / &#123;</span><br><span class="line">		proxy_pass http://192.168.20.1:8080; # 应用服务器HTTP地址</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>既然服务器可以直接HTTP访问，为什么要在中间加上一个反向代理，不是多此一举吗？反向代理有什么作用？继续往下看，下面的负载均衡、虚拟主机，都基于反向代理实现，当然反向代理的功能也不仅仅是这些。</p>
<h2 id="3、负载均衡"><a href="#3、负载均衡" class="headerlink" title="3、负载均衡"></a>3、负载均衡</h2><p>当网站访问量非常大，网站站长开心赚钱的同时，也摊上事儿了。因为网站越来越慢，一台服务器已经不够用了。于是将相同的应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。同时带来的好处是，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。</p>
<p>Nginx可以通过反向代理来实现负载均衡。<br><img src="http://fastabler.online/images/blogs/20150517221003659.jpg" alt="负载均衡"><br>配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">upstream myapp &#123;</span><br><span class="line">	server 192.168.20.1:8080; # 应用服务器1</span><br><span class="line">	server 192.168.20.2:8080; # 应用服务器2</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	listen 80;</span><br><span class="line">	location / &#123;</span><br><span class="line">		proxy_pass http://myapp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4、虚拟主机"><a href="#4、虚拟主机" class="headerlink" title="4、虚拟主机"></a>4、虚拟主机</h2><p>网站访问量大，需要负载均衡。然而并不是所有网站都如此出色，有的网站，由于访问量太小，需要节省成本，将多个网站部署在同一台服务器上。<br>例如将<a href="http://www.aaa.com和www.bbb.com两个网站部署在同一台服务器上，两个域名解析到同一个IP地址，但是用户通过两个域名却可以打开两个完全不同的网站，互相不影响，就像访问两个服务器一样，所以叫两个虚拟主机。" target="_blank" rel="noopener">www.aaa.com和www.bbb.com两个网站部署在同一台服务器上，两个域名解析到同一个IP地址，但是用户通过两个域名却可以打开两个完全不同的网站，互相不影响，就像访问两个服务器一样，所以叫两个虚拟主机。</a><br>配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	listen 80 default_server;</span><br><span class="line">	server_name _;</span><br><span class="line">	return 444; # 过滤其他域名的请求，返回444状态码</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	listen 80;</span><br><span class="line">	server_name www.aaa.com; # www.aaa.com域名</span><br><span class="line">	location / &#123;</span><br><span class="line">		proxy_pass http://localhost:8080; # 对应端口号8080</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">	listen 80;</span><br><span class="line">	server_name www.bbb.com; # www.bbb.com域名</span><br><span class="line">	location / &#123;</span><br><span class="line">		proxy_pass http://localhost:8081; # 对应端口号8081</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在服务器8080和8081分别开了一个应用，客户端通过不同的域名访问，根据server_name可以反向代理到对应的应用服务器。<br>虚拟主机的原理是通过HTTP请求头中的Host是否匹配server_name来实现的，有兴趣的同学可以研究一下HTTP协议。<br>另外，server_name配置还可以过滤有人恶意将某些域名指向你的主机服务器。</p>
<h2 id="5、FastCGI"><a href="#5、FastCGI" class="headerlink" title="5、FastCGI"></a>5、FastCGI</h2><p>Nginx本身不支持PHP等语言，但是它可以通过FastCGI来将请求扔给某些语言或框架处理（例如PHP、Python、Perl）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	listen 80;</span><br><span class="line">	location ~ \.php$ &#123;</span><br><span class="line">		include fastcgi_params;</span><br><span class="line">		fastcgi_param SCRIPT_FILENAME /PHP文件路径$fastcgi_script_name; # PHP文件路径</span><br><span class="line">		fastcgi_pass 127.0.0.1:9000; # PHP-FPM地址和端口号</span><br><span class="line">		# 另一种方式：fastcgi_pass unix:/var/run/php5-fpm.sock;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>配置中将.php结尾的请求通过FashCGI交给PHP-FPM处理，PHP-FPM是PHP的一个FastCGI管理器。有关FashCGI可以查阅其他资料，本文不再介绍。<br>fastcgi_pass和proxy_pass有什么区别？下面一张图带你看明白：<br><img src="http://fastabler.online/images/blogs/20150517221800380.jpg" alt="fastcgi_pass和proxy_pass区别"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2017/02/09/搭建后台技术框架/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content>
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/09/搭建后台技术框架/" itemprop="url">
                  搭建后台技术框架
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-09T14:13:58+08:00">
                2017-02-09
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>针对中小型互联网公司，特别适用于手机App的后台架构，支撑5万日活，满足中小型公司需求</p>
<blockquote>
<p>QPS， 如果是5万日活，使用集中在每天的4小时，每个用户大概产生100的请求，那么平均下来，我们系统大概应该支撑的请求为：50000 <em> 100 / (4 </em> 60 * 60) = 350 qps/s</p>
</blockquote>
<blockquote>
<p>业务数据 业务量，我们自己是新闻业务，可能会有其他的业务，比如游戏，商城等等，基本每天新增的业务数据都会在同一个量级， 每日10000， 另外跟用户相关的信息也是比较大的一块，比如用户的订阅等行为，一共5万的用户，保存相关信息可能大概需要100条的数据。</p>
</blockquote>
<blockquote>
<p>缓存大小 主要业务数据和用户相关的热点数据限时保存在缓存中， 大概需要5个G左右。</p>
</blockquote>
<blockquote>
<p>日志大小 用户日志和请求日志。 大概每天3个G左右</p>
</blockquote>
<h2 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h2><p>基于阿里云服务搭建</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>前期可以单机运行，业务量上来之后集群，使用nginx进行负载均衡，也可以选择阿里云的收费SLB</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>用于保存静态文件，阿里云跟七牛云都可以。一些图片数据如用户头像等由前端直接上传到七牛云，将返回的地址再返回给数据库，图片等大型文件不再经过服务器处理。app的新版本也直接保存在七牛云，更新的时候直接从七牛云下载，减少客户端请求服务器的带宽，可以明显提高访问速度</p>
<h2 id="分布式调用框架"><a href="#分布式调用框架" class="headerlink" title="分布式调用框架"></a>分布式调用框架</h2><p>可以直接选用dubbo，这个是使用最多应用范围最广的，遇到问题也能快速解决。springcloud目前国内用的较少，而且eureka2.0之后不再开源。也可以选择当当的dubboX</p>
<h2 id="消息队列MQ"><a href="#消息队列MQ" class="headerlink" title="消息队列MQ"></a>消息队列MQ</h2><p>可选的有： ActiveMQ, 阿里云消息， robbitMQ, 各有好处， 但是考虑到运维的难度，推荐阿里云消息。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>使用Redis</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>主要基于读写分离和主从复制考虑</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>建议ELK， 可以自动同步数据库，除了搜索引擎的功能外，还可以做日志搜索，监控系统</p>
<h2 id="一些典型的业务场景说明"><a href="#一些典型的业务场景说明" class="headerlink" title="一些典型的业务场景说明"></a>一些典型的业务场景说明</h2><ul>
<li>把业务底层做成SOA模块，通过分布式调用框架对外提供服务。</li>
<li>单独做一个小的系统来运行定时任务</li>
<li>热点数据放缓存，然后通过MQ来更新缓存</li>
<li>日志等数据有必要可以考虑上个Mongo</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2017/01/28/android右滑手势返回问题的解决思路/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content>
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/28/android右滑手势返回问题的解决思路/" itemprop="url">
                  android右滑手势返回问题的解决思路
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-28T17:42:21+08:00">
                2017-01-28
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于android右滑返回的几种解决办法"><a href="#关于android右滑返回的几种解决办法" class="headerlink" title="关于android右滑返回的几种解决办法"></a>关于android右滑返回的几种解决办法</h2><p>最近简单看了一下ios开发，界面开发方法感觉不如android来的痛快。可能接触的比较少，大概在做界面开发的时候各种要切图，还是android来的实在。而且关于屏幕适配在android上没法解决，在ios上也是一大痛点啊，这些在web上解决起来游刃有余，这也是web以后一统天下的一大原因吧。<br>看了几天ios开发之后，感觉android上的东西基本都是按照ios的标准来的。个人感觉谷歌的Material design非常棒，不知道在国内为啥流行不起来。但是ios设计有官方支持，开发起来更酸爽，android按照苹果的规范来开发就显得不这么自然，当然，ios用户体验确实无懈可击，大部分都是手势操作，例如滑动删除，滑动返回等等。今天就来分析一下滑动返回在android上实现的方法思路。</p>
<h3 id="滑动返回的核心就是View的滑动"><a href="#滑动返回的核心就是View的滑动" class="headerlink" title="滑动返回的核心就是View的滑动"></a>滑动返回的核心就是View的滑动</h3><p>滑动返回的核心不过就是根据手势来进行滑动，听起来确实像一句废话。关于View滑动大概就是三种方法，而滑动返回就是根据这三种方法进行拓展的。</p>
<ol>
<li>通过View自带的scrollTo和scrollBy</li>
<li>通过动画，包括属性动画和视图动画</li>
<li>通过动态的布局</li>
<li>还有一种在v4包里面的ViewDragHelper，关于用法不是本文的重点，但是绝对是开发的神器类，市面上的手势操作应用，基本都能用它来实现</li>
</ol>
<h3 id="滑动返回的几种解决方案"><a href="#滑动返回的几种解决方案" class="headerlink" title="滑动返回的几种解决方案"></a>滑动返回的几种解决方案</h3><p>以上View滑动方法结合滑动返回需求的实际使用场景</p>
<h4 id="第一种通过scrollTo和scrollBy实现滑动"><a href="#第一种通过scrollTo和scrollBy实现滑动" class="headerlink" title="第一种通过scrollTo和scrollBy实现滑动"></a>第一种通过scrollTo和scrollBy实现滑动</h4><p>结合固定的弹性滑动方法。scrollTo/scrollBy只能滑动View内的内容，所以适合二级页面少的情况，我们可以在同一个Activity中添加两个视图，通过scrollTo/scrollBy进行动态的添加删除View。<br>最好的应用场景就是最多二级页面，而且页面结构不复杂的情况。这样我们就不用多创建额外的Activity，在进行页面切换的时候异常的流畅。缺点也是显而易见的，就是要在逻辑性以及界面结构及其简单的情况下使用，最重要的是页面的跳转不能过多。因为太多原因的限制，所以这种方法适用的场景很少，但也有些情况使用它却会让页面流畅度增加N+1倍。<br>例如像nice应用中拍照和摄影就放在了同一个Activity中，然后结合ViewPage+Fragment使用。很明显的问题就是在切换的时候会明显的卡顿一段时间，我用价位在2500左右的手机进行测试的时候都能感到非常明显的卡顿。造成卡顿的原因是什么呢？因为在调用系统摄像头，在两个Fragment中分别调用了打开和关闭方法，这样就会有卡顿的情况。在这种场景下就可以使用scrollTo/scrollBy，在同一个页面中添加两个视图，但是两个视图共用同一个Camera，这样在切换的时候速度就会很快了。</p>
<h4 id="第二种我们可以使用动画或者动态布局或者ViewDragHelper，当滑动到一定距离的时候进行弹性滑动，然后结束掉此Activity，就实现了"><a href="#第二种我们可以使用动画或者动态布局或者ViewDragHelper，当滑动到一定距离的时候进行弹性滑动，然后结束掉此Activity，就实现了" class="headerlink" title="第二种我们可以使用动画或者动态布局或者ViewDragHelper，当滑动到一定距离的时候进行弹性滑动，然后结束掉此Activity，就实现了"></a>第二种我们可以使用动画或者动态布局或者ViewDragHelper，当滑动到一定距离的时候进行弹性滑动，然后结束掉此Activity，就实现了</h4><p>主要是首先要实现View跟随着手势滑动。主要的问题是需要设置一个透明背景。关于git上很多第三方都是基于此方法，而核心问题需要设置窗口半透明windowIsTranslucent为true，设置之后当滑动返回的时候，就能看到上一个窗口的view了。当然设置了这个属性之后会出现各种各样的问题，需要根据具体需求来修改。</p>
<h4 id="第三种方法也是首先实现滑动，在滑动的时候把上一个Activity的页面加到滑动的左边，也就是说我们在滑动时候看到的上一个视图是个假视图，并不是上一个Activity，只是Activity绘制的一个图。"><a href="#第三种方法也是首先实现滑动，在滑动的时候把上一个Activity的页面加到滑动的左边，也就是说我们在滑动时候看到的上一个视图是个假视图，并不是上一个Activity，只是Activity绘制的一个图。" class="headerlink" title="第三种方法也是首先实现滑动，在滑动的时候把上一个Activity的页面加到滑动的左边，也就是说我们在滑动时候看到的上一个视图是个假视图，并不是上一个Activity，只是Activity绘制的一个图。"></a>第三种方法也是首先实现滑动，在滑动的时候把上一个Activity的页面加到滑动的左边，也就是说我们在滑动时候看到的上一个视图是个假视图，并不是上一个Activity，只是Activity绘制的一个图。</h4><p>这种方法对程序的影响最小，但是也存在问题。首先我们需要在视图结束的时候执行finish方法真正结束掉这个Activity，在一些定制的系统上，每次finishActivity都会闪屏一下，这样我们可以清楚的看到这种不好的体验。还有就是因为我们看到的上一个Activity是个假的视图，所以当滑动完成之后立即点击会没有反应。</p>
<p>以上就是解决右滑返回的三种方案，关于代码，<a href="https://github.com/search?l=Java&amp;o=desc&amp;q=swipeback&amp;s=stars&amp;type=Repositories&amp;utf8=✓" target="_blank" rel="noopener">请移步github选择合适的解决方法</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2017/01/08/属性动画的使用原理/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content>
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/08/属性动画的使用原理/" itemprop="url">
                  属性动画的使用原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-08T10:38:47+08:00">
                2017-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>属性动画是API 11新加入的特性，和View动画不同，它对作用对象进行了扩展，属性动画可以对任何对象做动画，甚至还可以没有对象。除了作用对象进行了扩展以外，属性动画的效果也得到了加强，属性动画中有ValueAnimator（对值进行动画）、ObjectAnimator（对对象进行动画）、AnimatorSet（动画集合）等概念，通过他们可以实现绚丽的动画效果。</p>
<h2 id="使用属性动画"><a href="#使用属性动画" class="headerlink" title="使用属性动画"></a>使用属性动画</h2><p>属性动画可以对任意的对象属性进行动画而不仅仅是View，<strong>动画默认的时间为300ms</strong>，默认帧率为10ms／帧。其可以达到的效果是在一个时间间隔内完成对象从一个属性值到另一个属性值到改变。因此属性动画几乎无所不能。因为现在android版本都在4.0以上，所以我们不用考虑API 11以下手机。</p>
<ul>
<li>例如我们想改变一个对象的translationY的属性，让其沿着Y轴向上平移一段距离：它的高度。该动画在默认时间内完成，动画的完成时间是可以定义的。想要更灵活的效果我们还可以定义插值器和估值算法，但是一般我们不需要自定义，系统已经预置了一些，能够满足常用动画</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(myObject, &quot;translationY&quot;, -myObject.getHeight()).start();</span><br></pre></td></tr></table></figure>
<ul>
<li>改变一个对象的背景色属性，典型的情形是改变View的背景色，下面的动画可以让View在3s内实现从0xFFFF8080到0xFF8080FF的渐变，动画会无限循环且会有反转的效果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator colorAnim = ObjectAnimator.ofInt(this, &quot;backgroundColor&quot;,0xFFFF8080, 0xFF8080FF);</span><br><span class="line">colorAnim.setDuration(3000);</span><br><span class="line">colorAnim.setEvaluator(new ArgbEvaluator());</span><br><span class="line">colorAnim.setRepeatCount(ValueAnimator.INFINITE);</span><br><span class="line">colorAnim.setRepeatMode(ValueAnimator.REVERSE);</span><br><span class="line">colorAnim.start();</span><br></pre></td></tr></table></figure>
<ul>
<li>动画集合，5s内对View的旋转、平移、缩放和透明度都进行了改变</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AnimatorSet set = new AnimatorSet();</span><br><span class="line">set.playTogether(ObjectAnimator.ofFloat(myView, &quot;rotationX&quot;, 0, 360),</span><br><span class="line">	ObjectAnimator.ofFloat(myView, &quot;rotationY&quot;, 0, 180),</span><br><span class="line">	ObjectAnimator.ofFloat(myView, &quot;rotation&quot;, 0, -90),</span><br><span class="line">	ObjectAnimator.ofFloat(myView, &quot;translationX&quot;, 0, 90),</span><br><span class="line">	ObjectAnimator.ofFloat(myView, &quot;translationY&quot;, 0, 90),</span><br><span class="line">	ObjectAnimator.ofFloat(myView, &quot;scaleX&quot;, 1, 1.5f),</span><br><span class="line">	ObjectAnimator.ofFloat(myView, &quot;scaleX&quot;, 1, 0.5f),</span><br><span class="line">	ObjectAnimator.ofFloat(myView, &quot;alpha&quot;, 1, 0.25, 1),);</span><br><span class="line">set.setDuration(5 * 1000).start();</span><br></pre></td></tr></table></figure>
<p>属性动画在XML定义就不在多讲，因为它不如直接在代码中写起来方便，当然如果多个对象使用同一个动画，写在XML里面更好。</p>
<h2 id="插值器和估值器"><a href="#插值器和估值器" class="headerlink" title="插值器和估值器"></a>插值器和估值器</h2><h3 id="插值器"><a href="#插值器" class="headerlink" title="插值器"></a>插值器</h3><p>插值器只是一个概念，系统中与之相关的类叫做 TimeInterpolator ，其只是一个接口，准确来说叫做“时间插值器”。该接口的注释为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A time interpolator defines the rate of change of an animation. This allows animations to have non-linear motion, such as acceleration and deceleration.</span><br></pre></td></tr></table></figure>
<p>意思是：该时间插值器定义了动画的变化率，允许动画做非线性的运动，比如加速、减速。</p>
<p>这样，插值器的主要作用我们就明白了。接下来，看看这个接口的代码，该接口只有一个接口方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param input A value between 0 and 1.0 indicating our current point</span><br><span class="line"> *        in the animation where 0 represents the start and 1.0 represents</span><br><span class="line"> *        the end</span><br><span class="line"> * @return The interpolation value. This value can be more than 1.0 for</span><br><span class="line"> *         interpolators which overshoot their targets, or less than 0 for</span><br><span class="line"> *         interpolators that undershoot their targets.</span><br><span class="line"> */</span><br><span class="line">float getInterpolation(float input);</span><br></pre></td></tr></table></figure></p>
<p>不管是系统内置的插值器，还是我们自定义插值器，只需要实现接口并重写该方法，就可以起到插值器的作用。</p>
<p>该方法的作用是什么呢？上图保留了源码中对方法的注释，我就不直译了，说下大概的意思：</p>
<p>方法参数 input 接收 0 和 1.0 之间的值表示动画的当前进度，是线性变化的，其中0表示开始，1.0表示结束；<br>返回值表示对 input 进行插值之后的值，我们就是在这儿做“手脚”，让返回值不再是线性的，就完成自己定义动画的变化率了。<br>TimeInterpolator中文翻译为时间插值器，它的作用是根据时间流逝的百分比来计算出当前属性值改变的百分比，系统预置的有LinearInterpolator（线性插值器：匀速动画）、AccelerateDecelerateInterpolator（加速减速插值器：动画两头慢中间快）和DecelerateInterpolator（减速插值器：动画越来越慢）等。</p>
<h3 id="估值器"><a href="#估值器" class="headerlink" title="估值器"></a>估值器</h3><p>TypeEvalutor等中文翻译为类型估值算法，也叫作估值器。估值器的是用来决定属性的计算方式，最终使用反射机制来改变属性变化。它的作用是根据当前属性改变的百分比来计算改变后的属性值。系统预置的有IntEvalutor（针对整形属性）、FloatEvalutor（针对浮点型属性）和ArgbEvalutor（针对color属性）。</p>
<h2 id="属性动画的监听"><a href="#属性动画的监听" class="headerlink" title="属性动画的监听"></a>属性动画的监听</h2><p>属性动画提供了监听器用于监听动画的播放过程，主要有如下两个接口AnimatorUpdateListener和AnimatorListener。<br>AnimatorListener的定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**	</span><br><span class="line">    * &lt;p&gt;An animation listener receives notifications from an animation.</span><br><span class="line">    * Notifications indicate animation related events, such as the end or the</span><br><span class="line">    * repetition of the animation.&lt;/p&gt;</span><br><span class="line">    */</span><br><span class="line">   public static interface AnimatorListener &#123;</span><br><span class="line">       /**</span><br><span class="line">        * &lt;p&gt;Notifies the start of the animation.&lt;/p&gt;</span><br><span class="line">        *</span><br><span class="line">        * @param animation The started animation.</span><br><span class="line">        */</span><br><span class="line">       void onAnimationStart(Animator animation);</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * &lt;p&gt;Notifies the end of the animation. This callback is not invoked</span><br><span class="line">        * for animations with repeat count set to INFINITE.&lt;/p&gt;</span><br><span class="line">        *</span><br><span class="line">        * @param animation The animation which reached its end.</span><br><span class="line">        */</span><br><span class="line">       void onAnimationEnd(Animator animation);</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * &lt;p&gt;Notifies the cancellation of the animation. This callback is not invoked</span><br><span class="line">        * for animations with repeat count set to INFINITE.&lt;/p&gt;</span><br><span class="line">        *</span><br><span class="line">        * @param animation The animation which was canceled.</span><br><span class="line">        */</span><br><span class="line">       void onAnimationCancel(Animator animation);</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * &lt;p&gt;Notifies the repetition of the animation.&lt;/p&gt;</span><br><span class="line">        *</span><br><span class="line">        * @param animation The animation which was repeated.</span><br><span class="line">        */</span><br><span class="line">       void onAnimationRepeat(Animator animation);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>AnimatorUpdateListener的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Implementors of this interface can add themselves as update listeners</span><br><span class="line">     * to an &lt;code&gt;ValueAnimator&lt;/code&gt; instance to receive callbacks on every animation</span><br><span class="line">     * frame, after the current frame&apos;s values have been calculated for that</span><br><span class="line">     * &lt;code&gt;ValueAnimator&lt;/code&gt;.</span><br><span class="line">     */</span><br><span class="line">    public static interface AnimatorUpdateListener &#123;</span><br><span class="line">        /**</span><br><span class="line">         * &lt;p&gt;Notifies the occurrence of another frame of the animation.&lt;/p&gt;</span><br><span class="line">         *</span><br><span class="line">         * @param animation The animation which was repeated.</span><br><span class="line">         */</span><br><span class="line">        void onAnimationUpdate(ValueAnimator animation);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="对任意属性做动画"><a href="#对任意属性做动画" class="headerlink" title="对任意属性做动画"></a>对任意属性做动画</h2><p>比如我们用属性动画对Button做宽度的增加，会首先想到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofInt(mButton, &quot;width&quot;, 500).setDuration(5000).start();</span><br></pre></td></tr></table></figure>
<p>上述代码运行后会发现没有效果，其实没有效果是正常现象，因为如果随便传一个属性（例如width）轻则没有动画效果，重则程序直接crash。<br>下面分析属性动画的原理：<strong>属性动画要求动画的作用对象提供该属性的get和set方法，属性动画根据该属性的初始值和最终值，以动画的效果多次去调用set方法，每次传递给set方法等值都不一样，确切的来说是随着时间的推移，所传递的值越来越接近最终值</strong></p>
<ol>
<li>作用对象必须提供该属性的get和set方法</li>
<li>作用对象的set方法必须要能使UI效果改变，否则动画无效果</li>
</ol>
<p>那么为什么我们对Button的width属性做动画会没有效果呢？这是因为虽然Button内部提供了getWidth和setWidth方法，但是这个setWidth方法并不是改变视图的大小，它是TextView新添加的方法，View是没有setWidth这个方法的。由于Button继承TextView，所以Button有setWidth方法，来看一下setWidth和getWidth方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Makes the TextView exactly this many pixels wide.</span><br><span class="line">     * You could do the same thing by specifying this number in the</span><br><span class="line">     * LayoutParams.</span><br><span class="line">     *</span><br><span class="line">     * @see #setMaxWidth(int)</span><br><span class="line">     * @see #setMinWidth(int)</span><br><span class="line">     * @see #getMinWidth()</span><br><span class="line">     * @see #getMaxWidth()</span><br><span class="line">     *</span><br><span class="line">     * @attr ref android.R.styleable#TextView_width</span><br><span class="line">     */</span><br><span class="line">    @android.view.RemotableViewMethod</span><br><span class="line">    public void setWidth(int pixels) &#123;</span><br><span class="line">        mMaxWidth = mMinWidth = pixels;</span><br><span class="line">        mMaxWidthMode = mMinWidthMode = PIXELS;</span><br><span class="line"></span><br><span class="line">        requestLayout();</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Return the width of the your view.</span><br><span class="line">     *</span><br><span class="line">     * @return The width of your view, in pixels.</span><br><span class="line">     */</span><br><span class="line">    @ViewDebug.ExportedProperty(category = &quot;layout&quot;)</span><br><span class="line">    public final int getWidth() &#123;</span><br><span class="line">        return mRight - mLeft;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上述源码中可以看出，getWidth的确是获取View的宽度，而setWidth是TextView和其子类的专属方法，它的作用不是设置宽度，而是设置最大宽度和最小宽度的。具体来说在布局XML中android:layout_width对应宽度，android:width对应最大最小宽度。所以setWidth无法改变控件的宽度。<br>针对上述问题，官方告诉我们有三种解决方法</p>
<ul>
<li>给你的对象加上set和get方法，如果你有权限的话</li>
<li>用一个类来包装原始对象，间接为其提供set和get方法</li>
<li>采用ValueAnimator，监听动画的过程，自己实现属性的改变。</li>
</ul>
<p>针对以上解决方法，结合实际情况我们得出，Button设置宽度无法使用第一种方法，因为我们没有权限更改它的源码。所以我们可以采用第二种和第三种解决方法。</p>
<p>采用第二种解决方法，创建包裹类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 改变宽度</span><br><span class="line">    */</span><br><span class="line">   private void changeWidth()&#123;</span><br><span class="line">       ViewWrapper wrapper = new ViewWrapper(mButton);</span><br><span class="line">       ObjectAnimator.ofInt(wrapper, &quot;width&quot;, 500).setDuration(5000).start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 用于包裹类</span><br><span class="line">    */</span><br><span class="line">   private static class ViewWrapper&#123;</span><br><span class="line">       private View mTarget;</span><br><span class="line"></span><br><span class="line">       public ViewWrapper(View target)&#123;</span><br><span class="line">           this.mTarget = target;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public int getWidth()&#123;</span><br><span class="line">           return mTarget.getLayoutParams().width;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public void setWidth(int width)&#123;</span><br><span class="line">           mTarget.getLayoutParams().width = width;</span><br><span class="line">           mTarget.requestLayout();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>采用第三种解决方法，利用ValueAnimator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    *</span><br><span class="line">    * @param target 要改变的目标View</span><br><span class="line">    * @param start 开始的宽度</span><br><span class="line">    * @param end   结束的宽度</span><br><span class="line">    */</span><br><span class="line">   private void performAnimte(final View target, final int start, final int end)&#123;</span><br><span class="line">       ValueAnimator valueAnimator = ValueAnimator.ofInt(1, 100);</span><br><span class="line">       valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">           private IntEvaluator mEvaluator = new IntEvaluator();</span><br><span class="line">           @Override</span><br><span class="line">           public void onAnimationUpdate(ValueAnimator animation) &#123;</span><br><span class="line">               // 获取当前动画的进度</span><br><span class="line">               int currentValue = (int) animation.getAnimatedFraction();</span><br><span class="line">               // 获取当前进度占整个动画的比例</span><br><span class="line">               float fraction = animation.getAnimatedFraction();</span><br><span class="line">               // 直接调用整型估值器，通过比例计算出宽度，然后赋值</span><br><span class="line">               target.getLayoutParams().width = mEvaluator.evaluate(fraction, start, end);</span><br><span class="line">               target.requestLayout();</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       valueAnimator.setDuration(5000).start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性动画的工作原理"><a href="#属性动画的工作原理" class="headerlink" title="属性动画的工作原理"></a>属性动画的工作原理</h2><p>属性动画要求动画作用的对象提供该属性的set方法，属性动画根据你传递的该属性的初始值和最终值，以动画的效果多次去调用set方法。每次传递给set方法的值都不一样，确切的来说是随着时间的推移，所传递的值越来越接近最终值。如果动画的时候没有传递初始值，那么还要提供get方法，因为系统要去获取属性的初始值。对于属性动画来说，其动画过程中所做的就是这么多。</p>
<h2 id="使用动画的注意事项"><a href="#使用动画的注意事项" class="headerlink" title="使用动画的注意事项"></a>使用动画的注意事项</h2><ol>
<li>内存泄漏：在属性动画中有一类无限循环的动画，这类动画需要在Activity退出时及时停止，否则将导致Activity无法释放从而造成内存泄漏，View动画并不存在这种现象。</li>
<li>兼容性问题：动画在3.0以下的系统上存在兼容性问题，现在android系统大部分都是4.0的</li>
<li>不要使用px：在进行动画的过程中，要尽量使用dp，使用px会导致在不同的设备上有不同的效果</li>
<li>硬件加速：使用动画的过程中建议开启硬件加速，这样会提高动画的流畅性。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2017/01/06/Rxjava操作符大全/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content>
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/06/Rxjava操作符大全/" itemprop="url">
                  Rxjava操作符大全
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-06T18:19:52+08:00">
                2017-01-06
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="创建操作"><a href="#创建操作" class="headerlink" title="创建操作"></a>创建操作</h2><h3 id="以下操作符用于创建Observable。"><a href="#以下操作符用于创建Observable。" class="headerlink" title="以下操作符用于创建Observable。"></a>以下操作符用于创建Observable。</h3><h4 id="create：-使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe-call方法中检查订阅状态，以便及时停止发射数据或者运算。"><a href="#create：-使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe-call方法中检查订阅状态，以便及时停止发射数据或者运算。" class="headerlink" title="create： 使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe#call方法中检查订阅状态，以便及时停止发射数据或者运算。"></a>create： 使用OnSubscribe从头创建一个Observable，这种方法比较简单。需要注意的是，使用该方法创建时，建议在OnSubscribe#call方法中检查订阅状态，以便及时停止发射数据或者运算。</h4><pre><code>Observable.create(new Observable.OnSubscribe&lt;String&gt;() {

    @Override
    public void call(Subscriber&lt;? super String&gt; subscriber) {

        subscriber.onNext(&quot;item1&quot;);
        subscriber.onNext(&quot;item2&quot;);
        subscriber.onCompleted();
    }
});
</code></pre><h4 id="from：-将一个Iterable-一个Future-或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。"><a href="#from：-将一个Iterable-一个Future-或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。" class="headerlink" title="from： 将一个Iterable, 一个Future, 或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。"></a>from： 将一个Iterable, 一个Future, 或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。</h4><p><img src="http://static.zybuluo.com/maplejaw/1a7gi8os6u4kgk7aahzmj1d0/image_1arcl6d0a1iej60e6ccp48qic9.png" alt="Markdown preferences pane"></p>
<pre><code>//Iterable
List&lt;String&gt; list=new ArrayList&lt;&gt;();
...
Observable.from(list)
        .subscribe(new Action1&lt;String&gt;() {
    @Override
    public void call(String s) {

    }
});

//Future
 Future&lt;String&gt; futrue= Executors.newSingleThreadExecutor().submit(new Callable&lt;String&gt;() {

    @Override
    public String call() throws Exception {
        Thread.sleep(1000);
        return &quot;maplejaw&quot;;
    }
});

Observable.from(futrue)
          .subscribe(new Action1&lt;String&gt;() {
    @Override
    public void call(String s) {

    }
});
</code></pre><h4 id="just：-将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。"><a href="#just：-将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。" class="headerlink" title="just： 将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。"></a>just： 将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。</h4><h4 id="empty：-创建一个什么都不做直接通知完成的Observable"><a href="#empty：-创建一个什么都不做直接通知完成的Observable" class="headerlink" title="empty： 创建一个什么都不做直接通知完成的Observable"></a>empty： 创建一个什么都不做直接通知完成的Observable</h4><h4 id="error：-创建一个什么都不做直接通知错误的Observable"><a href="#error：-创建一个什么都不做直接通知错误的Observable" class="headerlink" title="error： 创建一个什么都不做直接通知错误的Observable"></a>error： 创建一个什么都不做直接通知错误的Observable</h4><h4 id="never：-创建一个什么都不做的Observable"><a href="#never：-创建一个什么都不做的Observable" class="headerlink" title="never： 创建一个什么都不做的Observable"></a>never： 创建一个什么都不做的Observable</h4><pre><code>Observable observable1=Observable.empty();//直接调用onCompleted。
Observable observable2=Observable.error(new RuntimeException());//直接调用onError。这里可以自定义异常
Observable observable3=Observable.never();//啥都不做
</code></pre><h4 id="timer：-创建一个在给定的延时之后发射数据项为0的Observable-内部通过OnSubscribeTimerOnce工作"><a href="#timer：-创建一个在给定的延时之后发射数据项为0的Observable-内部通过OnSubscribeTimerOnce工作" class="headerlink" title="timer： 创建一个在给定的延时之后发射数据项为0的Observable,内部通过OnSubscribeTimerOnce工作"></a>timer： 创建一个在给定的延时之后发射数据项为0的Observable<long>,内部通过OnSubscribeTimerOnce工作</long></h4><pre><code>Observable.timer(1000,TimeUnit.MILLISECONDS)
        .subscribe(new Action1&lt;Long&gt;() {
            @Override
            public void call(Long aLong) {
                Log.d(&quot;JG&quot;,aLong.toString()); // 0
            }
        });
</code></pre><h4 id="interval：-创建一个按照给定的时间间隔发射从0开始的整数序列的Observable，内部通过OnSubscribeTimerPeriodically工作。"><a href="#interval：-创建一个按照给定的时间间隔发射从0开始的整数序列的Observable，内部通过OnSubscribeTimerPeriodically工作。" class="headerlink" title="interval： 创建一个按照给定的时间间隔发射从0开始的整数序列的Observable，内部通过OnSubscribeTimerPeriodically工作。"></a>interval： 创建一个按照给定的时间间隔发射从0开始的整数序列的Observable<long>，内部通过OnSubscribeTimerPeriodically工作。</long></h4><pre><code>Observable.interval(1, TimeUnit.SECONDS)
        .subscribe(new Action1&lt;Long&gt;() {
            @Override
            public void call(Long aLong) {
                 //每隔1秒发送数据项，从0开始计数
                 //0,1,2,3....
            }
        });
</code></pre><h4 id="range：-创建一个发射指定范围的整数序列的Observable"><a href="#range：-创建一个发射指定范围的整数序列的Observable" class="headerlink" title="range： 创建一个发射指定范围的整数序列的Observable"></a>range： 创建一个发射指定范围的整数序列的Observable<integer></integer></h4><pre><code>Observable.range(2,5).subscribe(new Action1&lt;Integer&gt;() {
    @Override
    public void call(Integer integer) {
        Log.d(&quot;JG&quot;,integer.toString());// 2,3,4,5,6 从2开始发射5个数据
    }
});
</code></pre><h5 id="defer：-只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。"><a href="#defer：-只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。" class="headerlink" title="defer： 只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。"></a>defer： 只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。</h5><pre><code>Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() {
    @Override
    public Observable&lt;String&gt; call() {
        return Observable.just(&quot;hello&quot;);
    }
}).subscribe(new Action1&lt;String&gt;() {
    @Override
    public void call(String s) {
        Log.d(&quot;JG&quot;,s);
    }
});
</code></pre><h2 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h2><p>以下操作符用于组合多个Observable。</p>
<p>注意，为了使结构更加清晰以及缩小代码量，之后的例子部分地方将会使用Lambda表达式书写，如果你对Lambda表达式不太熟悉的话，可以阅读JAVA8 Lambda表达式完全解析这篇文章。</p>
<h4 id="concat：-按顺序连接多个Observables。需要注意的是Observable-concat-a-b-等价于a-concatWith-b-。"><a href="#concat：-按顺序连接多个Observables。需要注意的是Observable-concat-a-b-等价于a-concatWith-b-。" class="headerlink" title="concat： 按顺序连接多个Observables。需要注意的是Observable.concat(a,b)等价于a.concatWith(b)。"></a>concat： 按顺序连接多个Observables。需要注意的是Observable.concat(a,b)等价于a.concatWith(b)。</h4><pre><code>Observable&lt;Integer&gt; observable1=Observable.just(1,2,3,4);
Observable&lt;Integer&gt;  observable2=Observable.just(4,5,6);

Observable.concat(observable1,observable2)
        .subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString()));//1,2,3,4,4,5,6
</code></pre><h4 id="startWith：-在数据序列的开头增加一项数据。startWith的内部也是调用了concat"><a href="#startWith：-在数据序列的开头增加一项数据。startWith的内部也是调用了concat" class="headerlink" title="startWith： 在数据序列的开头增加一项数据。startWith的内部也是调用了concat"></a>startWith： 在数据序列的开头增加一项数据。startWith的内部也是调用了concat</h4><pre><code>Observable.just(1,2,3,4,5)
        .startWith(6,7,8)
.subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString()));//6,7,8,1,2,3,4,5
</code></pre><h4 id="merge：-将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。"><a href="#merge：-将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。" class="headerlink" title="merge： 将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。"></a>merge： 将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。</h4><h4 id="zip：-使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过OperatorZip进行压合。"><a href="#zip：-使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过OperatorZip进行压合。" class="headerlink" title="zip： 使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过OperatorZip进行压合。"></a>zip： 使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过OperatorZip进行压合。</h4><p>Observable<integer>  observable1=Observable.just(1,2,3,4);<br>Observable<integer>  observable2=Observable.just(4,5,6);</integer></integer></p>
<pre><code>Observable.zip(observable1, observable2, new Func2&lt;Integer, Integer, String&gt;() {
    @Override
    public String call(Integer item1, Integer item2) {
        return item1+&quot;and&quot;+item2;
    }
})
.subscribe(item-&gt;Log.d(&quot;JG&quot;,item)); //1and4,2and5,3and6
</code></pre><h4 id="combineLatest：-当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable最近的数据压合。具体请看下面流程图。"><a href="#combineLatest：-当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable最近的数据压合。具体请看下面流程图。" class="headerlink" title="combineLatest： 当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable最近的数据压合。具体请看下面流程图。"></a>combineLatest： 当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable最近的数据压合。具体请看下面流程图。</h4><p>zip工作流程<br><img src="http://static.zybuluo.com/maplejaw/bu67z13p279yu074arzslsyd/image_1ard6160913ui3r6orodc41pntm.png" alt="Markdown preferences pane"></p>
<p>combineLatest工作流程<br><img src="http://static.zybuluo.com/maplejaw/tuo7jn6ijtzsa1c3ak77umtu/image_1ard609fsi3p9n7160iq0r1rqe9.png" alt="Markdown preferences pane"></p>
<h2 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h2><h4 id="filter：-过滤数据。内部通过OnSubscribeFilter过滤数据。"><a href="#filter：-过滤数据。内部通过OnSubscribeFilter过滤数据。" class="headerlink" title="filter： 过滤数据。内部通过OnSubscribeFilter过滤数据。"></a>filter： 过滤数据。内部通过OnSubscribeFilter过滤数据。</h4><pre><code>Observable.just(3,4,5,6)
        .filter(new Func1&lt;Integer, Boolean&gt;() {
            @Override
            public Boolean call(Integer integer) {
                return integer&gt;4;
            }
        })
.subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString())); //5,6 
</code></pre><h4 id="ofType：-过滤指定类型的数据，与filter类似，"><a href="#ofType：-过滤指定类型的数据，与filter类似，" class="headerlink" title="ofType： 过滤指定类型的数据，与filter类似，"></a>ofType： 过滤指定类型的数据，与filter类似，</h4><pre><code>Observable.just(1,2,&quot;3&quot;)
        .ofType(Integer.class)
        .subscribe(item -&gt; Log.d(&quot;JG&quot;,item.toString()));
</code></pre><h4 id="take：-只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。"><a href="#take：-只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。" class="headerlink" title="take： 只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。"></a>take： 只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。</h4><pre><code>Observable.just(3,4,5,6)
        .take(3)//发射前三个数据项
        .take(100, TimeUnit.MILLISECONDS)//发射100ms内的数据
</code></pre><h4 id="takeLast：-只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。"><a href="#takeLast：-只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。" class="headerlink" title="takeLast： 只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。"></a>takeLast： 只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射。</h4><pre><code>Observable.just(3,4,5,6)
        .takeLast(3)
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));//4,5,6
</code></pre><h4 id="takeFirst：提取满足条件的第一项。内部实现源码如下："><a href="#takeFirst：提取满足条件的第一项。内部实现源码如下：" class="headerlink" title="takeFirst：提取满足条件的第一项。内部实现源码如下："></a>takeFirst：提取满足条件的第一项。内部实现源码如下：</h4><pre><code>public final Observable&lt;T&gt; takeFirst(Func1&lt;? super T, Boolean&gt; predicate) {
  return filter(predicate).take(1); //先过滤，后提取
}
</code></pre><h4 id="first-firstOrDefault：只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。"><a href="#first-firstOrDefault：只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。" class="headerlink" title="first/firstOrDefault：只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。"></a>first/firstOrDefault：只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。</h4><pre><code>Observable.just(3,4,5,6)
        .first()
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));//3

Observable.just(3,4,5,6)
           .first(new Func1&lt;Integer, Boolean&gt;() {
               @Override
               public Boolean call(Integer integer) {
                   return integer&gt;3;
               }
           }) .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));//4
</code></pre><h4 id="last-lastOrDefault：只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。"><a href="#last-lastOrDefault：只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。" class="headerlink" title="last/lastOrDefault：只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。"></a>last/lastOrDefault：只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。</h4><h4 id="skip：跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。"><a href="#skip：跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。" class="headerlink" title="skip：跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。"></a>skip：跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。</h4><pre><code>Observable.just(3,4,5,6)
           .skip(1)
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));//4,5,6
</code></pre><h4 id="skipLast：跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。"><a href="#skipLast：跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。" class="headerlink" title="skipLast：跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。"></a>skipLast：跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。</h4><h4 id="elementAt-elementAtOrDefault：发射某一项数据，如果超过了范围可以的指定默认值。内部通过OperatorElementAt过滤。"><a href="#elementAt-elementAtOrDefault：发射某一项数据，如果超过了范围可以的指定默认值。内部通过OperatorElementAt过滤。" class="headerlink" title="elementAt/elementAtOrDefault：发射某一项数据，如果超过了范围可以的指定默认值。内部通过OperatorElementAt过滤。"></a>elementAt/elementAtOrDefault：发射某一项数据，如果超过了范围可以的指定默认值。内部通过OperatorElementAt过滤。</h4><pre><code>Observable.just(3,4,5,6)
         .elementAt(2)
.subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString())); //5
</code></pre><h4 id="ignoreElements：丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。"><a href="#ignoreElements：丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。" class="headerlink" title="ignoreElements：丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。"></a>ignoreElements：丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。</h4><h4 id="distinct：过滤重复数据，内部通过OperatorDistinct实现。"><a href="#distinct：过滤重复数据，内部通过OperatorDistinct实现。" class="headerlink" title="distinct：过滤重复数据，内部通过OperatorDistinct实现。"></a>distinct：过滤重复数据，内部通过OperatorDistinct实现。</h4><pre><code>Observable.just(3,4,5,6,3,3,4,9)
   .distinct()
  .subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString())); //3,4,5,6,9
</code></pre><h4 id="distinctUntilChanged：过滤掉连续重复的数据。内部通过OperatorDistinctUntilChanged实现"><a href="#distinctUntilChanged：过滤掉连续重复的数据。内部通过OperatorDistinctUntilChanged实现" class="headerlink" title="distinctUntilChanged：过滤掉连续重复的数据。内部通过OperatorDistinctUntilChanged实现"></a>distinctUntilChanged：过滤掉连续重复的数据。内部通过OperatorDistinctUntilChanged实现</h4><pre><code>Observable.just(3,4,5,6,3,3,4,9)
   .distinctUntilChanged()
  .subscribe(item-&gt;Log.d(&quot;JG&quot;,item.toString())); //3,4,5,6,3,4,9
</code></pre><h4 id="throttleFirst：定期发射Observable发射的第一项数据。内部通过OperatorThrottleFirst实现。"><a href="#throttleFirst：定期发射Observable发射的第一项数据。内部通过OperatorThrottleFirst实现。" class="headerlink" title="throttleFirst：定期发射Observable发射的第一项数据。内部通过OperatorThrottleFirst实现。"></a>throttleFirst：定期发射Observable发射的第一项数据。内部通过OperatorThrottleFirst实现。</h4><pre><code>Observable.create(subscriber -&gt; {
    subscriber.onNext(1);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(2);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }

    subscriber.onNext(3);
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(4);
    subscriber.onNext(5);
    subscriber.onCompleted();

}).throttleFirst(999, TimeUnit.MILLISECONDS)
        .subscribe(item-&gt; Log.d(&quot;JG&quot;,item.toString())); //结果为1,3,4
</code></pre><h4 id="throttleWithTimeout-debounce：发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据-直到指定时间内都没有新数据发射时"><a href="#throttleWithTimeout-debounce：发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据-直到指定时间内都没有新数据发射时" class="headerlink" title="throttleWithTimeout/debounce：发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据,直到指定时间内都没有新数据发射时"></a>throttleWithTimeout/debounce：发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据,直到指定时间内都没有新数据发射时</h4><p>才进行发射</p>
<pre><code>Observable.create(subscriber -&gt; {
    subscriber.onNext(1);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(2);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }

    subscriber.onNext(3);
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(4);
    subscriber.onNext(5);
    subscriber.onCompleted();

}).debounce(999, TimeUnit.MILLISECONDS)//或者为throttleWithTimeout(1000, TimeUnit.MILLISECONDS)
        .subscribe(item-&gt; Log.d(&quot;JG&quot;,item.toString())); //结果为3,5
</code></pre><h4 id="sample-throttleLast：定期发射Observable最近的数据。内部通过OperatorSampleWithTime实现。"><a href="#sample-throttleLast：定期发射Observable最近的数据。内部通过OperatorSampleWithTime实现。" class="headerlink" title="sample/throttleLast：定期发射Observable最近的数据。内部通过OperatorSampleWithTime实现。"></a>sample/throttleLast：定期发射Observable最近的数据。内部通过OperatorSampleWithTime实现。</h4><pre><code>Observable.create(subscriber -&gt; {
    subscriber.onNext(1);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(2);
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }

    subscriber.onNext(3);
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(4);
    subscriber.onNext(5);
    subscriber.onCompleted();

}).sample(999, TimeUnit.MILLISECONDS)//或者为throttleLast(1000, TimeUnit.MILLISECONDS)
        .subscribe(item-&gt; Log.d(&quot;JG&quot;,item.toString())); //结果为2,3,5
</code></pre><h4 id="timeout：-如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。"><a href="#timeout：-如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。" class="headerlink" title="timeout： 如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。"></a>timeout： 如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。</h4><pre><code>Observable.create(( subscriber) -&gt; {
    subscriber.onNext(1);
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        throw Exceptions.propagate(e);
    }
    subscriber.onNext(2);

    subscriber.onCompleted();

}).timeout(999, TimeUnit.MILLISECONDS,Observable.just(99,100))//如果不指定备用Observable将会抛出异常
        .subscribe(item-&gt; Log.d(&quot;JG&quot;,item.toString()),error-&gt;Log.d(&quot;JG&quot;,&quot;onError&quot;)); //结果为1,99,100  如果不指定备用Observable结果为1,onError
}
</code></pre><h3 id="条件-布尔操作"><a href="#条件-布尔操作" class="headerlink" title="条件/布尔操作"></a>条件/布尔操作</h3><h4 id="all：-判断所有的数据项是否满足某个条件，内部通过OperatorAll实现。"><a href="#all：-判断所有的数据项是否满足某个条件，内部通过OperatorAll实现。" class="headerlink" title="all： 判断所有的数据项是否满足某个条件，内部通过OperatorAll实现。"></a>all： 判断所有的数据项是否满足某个条件，内部通过OperatorAll实现。</h4><pre><code>Observable.just(2,3,4,5)
        .all(new Func1&lt;Integer, Boolean&gt;() {
            @Override
            public Boolean call(Integer integer) {
                return integer&gt;3;
            }
        })
.subscribe(new Action1&lt;Boolean&gt;() {
    @Override
    public void call(Boolean aBoolean) {
        Log.d(&quot;JG&quot;,aBoolean.toString()); //false
    }
})
;
</code></pre><h4 id="exists：-判断是否存在数据项满足某个条件。内部通过OperatorAny实现。"><a href="#exists：-判断是否存在数据项满足某个条件。内部通过OperatorAny实现。" class="headerlink" title="exists： 判断是否存在数据项满足某个条件。内部通过OperatorAny实现。"></a>exists： 判断是否存在数据项满足某个条件。内部通过OperatorAny实现。</h4><pre><code>Observable.just(2,3,4,5)
        .exists(integer -&gt; integer&gt;3)
        .subscribe(aBoolean -&gt; Log.d(&quot;JG&quot;,aBoolean.toString())); //true
</code></pre><h4 id="contains：-判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是exists"><a href="#contains：-判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是exists" class="headerlink" title="contains： 判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是exists"></a>contains： 判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是exists</h4><pre><code>Observable.just(2,3,4,5)
        .contains(3)
        .subscribe(aBoolean -&gt; Log.d(&quot;JG&quot;,aBoolean.toString())); //true
</code></pre><h4 id="sequenceEqual：-用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。"><a href="#sequenceEqual：-用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。" class="headerlink" title="sequenceEqual： 用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。"></a>sequenceEqual： 用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。</h4><pre><code>Observable.sequenceEqual(Observable.just(2,3,4,5),Observable.just(2,3,4,5))
        .subscribe(aBoolean -&gt; Log.d(&quot;JG&quot;,aBoolean.toString()));//true
</code></pre><h4 id="isEmpty：-用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。"><a href="#isEmpty：-用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。" class="headerlink" title="isEmpty： 用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。"></a>isEmpty： 用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。</h4><pre><code>Observable.just(3,4,5,6)
           .isEmpty()
          .subscribe(item -&gt; Log.d(&quot;JG&quot;,item.toString()));//false
</code></pre><p>amb： 给定多个Observable，只让第一个发射数据的Observable发射全部数据，其他Observable将会被忽略。</p>
<pre><code>Observable&lt;Integer&gt; observable1=Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() {
    @Override
    public void call(Subscriber&lt;? super Integer&gt; subscriber) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            subscriber.onError(e);
        }
        subscriber.onNext(1);
        subscriber.onNext(2);
        subscriber.onCompleted();
    }
}).subscribeOn(Schedulers.computation());

Observable&lt;Integer&gt; observable2=Observable.create(subscriber -&gt; {
    subscriber.onNext(3);
    subscriber.onNext(4);
    subscriber.onCompleted();
});

Observable.amb(observable1,observable2)
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString())); //3,4
</code></pre><h4 id="switchIfEmpty：-如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。"><a href="#switchIfEmpty：-如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。" class="headerlink" title="switchIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。"></a>switchIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。</h4><pre><code>Observable.empty()
        .switchIfEmpty(Observable.just(2,3,4))
.subscribe(o -&gt; Log.d(&quot;JG&quot;,o.toString())); //2,3,4
</code></pre><h4 id="defaultIfEmpty：-如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值-内部调用的switchIfEmpty。"><a href="#defaultIfEmpty：-如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值-内部调用的switchIfEmpty。" class="headerlink" title="defaultIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值,内部调用的switchIfEmpty。"></a>defaultIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值,内部调用的switchIfEmpty。</h4><h4 id="takeUntil：-当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据。"><a href="#takeUntil：-当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据。" class="headerlink" title="takeUntil： 当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据。"></a>takeUntil： 当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据。</h4><pre><code>Observable.just(2,3,4,5)
        .takeUntil(new Func1&lt;Integer, Boolean&gt;() {
            @Override
            public Boolean call(Integer integer) {
                return integer==4;
            }
        }).subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString())); //2,3,4
</code></pre><h4 id="takeWhile：-当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。"><a href="#takeWhile：-当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。" class="headerlink" title="takeWhile： 当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。"></a>takeWhile： 当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。</h4><pre><code>Observable.just(2,3,4,5)
        .takeWhile(new Func1&lt;Integer, Boolean&gt;() {
            @Override
            public Boolean call(Integer integer) {
                return integer==4;
            }
        })
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString())); //2,3
</code></pre><h4 id="skipUntil：-丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）"><a href="#skipUntil：-丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）" class="headerlink" title="skipUntil： 丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）"></a>skipUntil： 丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据）</h4><h4 id="skipWhile：-丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）"><a href="#skipWhile：-丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）" class="headerlink" title="skipWhile： 丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）"></a>skipWhile： 丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据）</h4><h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><h4 id="reduce：-对序列使用reduce-函数并发射最终的结果-内部使用OnSubscribeReduce实现。"><a href="#reduce：-对序列使用reduce-函数并发射最终的结果-内部使用OnSubscribeReduce实现。" class="headerlink" title="reduce： 对序列使用reduce()函数并发射最终的结果,内部使用OnSubscribeReduce实现。"></a>reduce： 对序列使用reduce()函数并发射最终的结果,内部使用OnSubscribeReduce实现。</h4><pre><code>Observable.just(2,3,4,5)
        .reduce(new Func2&lt;Integer, Integer, Integer&gt;() {
            @Override
            public Integer call(Integer sum, Integer item) {
                return sum+item;
            }
        })
</code></pre><h4 id="collect：-使用collect收集数据到一个可变的数据结构。"><a href="#collect：-使用collect收集数据到一个可变的数据结构。" class="headerlink" title="collect： 使用collect收集数据到一个可变的数据结构。"></a>collect： 使用collect收集数据到一个可变的数据结构。</h4><pre><code>Observable.just(3,4,5,6)
           .collect(new Func0&lt;List&lt;Integer&gt;&gt;() { //创建数据结构

               @Override
               public List&lt;Integer&gt; call() {
                   return new ArrayList&lt;Integer&gt;();
               }
           }, new Action2&lt;List&lt;Integer&gt;, Integer&gt;() { //收集器
               @Override
               public void call(List&lt;Integer&gt; integers, Integer integer) {
                   integers.add(integer);
               }
           })
          .subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {
              @Override
              public void call(List&lt;Integer&gt; integers) {

              }
          });
</code></pre><h4 id="count-countLong：-计算发射的数量，内部调用的是reduce"><a href="#count-countLong：-计算发射的数量，内部调用的是reduce" class="headerlink" title="count/countLong： 计算发射的数量，内部调用的是reduce."></a>count/countLong： 计算发射的数量，内部调用的是reduce.</h4><h2 id="转换操作"><a href="#转换操作" class="headerlink" title="转换操作"></a>转换操作</h2><h4 id="toList：-收集原始Observable发射的所有数据到一个列表，然后返回这个列表"><a href="#toList：-收集原始Observable发射的所有数据到一个列表，然后返回这个列表" class="headerlink" title="toList： 收集原始Observable发射的所有数据到一个列表，然后返回这个列表."></a>toList： 收集原始Observable发射的所有数据到一个列表，然后返回这个列表.</h4><pre><code>Observable.just(2,3,4,5)
        .toList()
        .subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {
            @Override
            public void call(List&lt;Integer&gt; integers) {

            }
        });
</code></pre><h4 id="toSortedList：-收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表。"><a href="#toSortedList：-收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表。" class="headerlink" title="toSortedList： 收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表。"></a>toSortedList： 收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表。</h4><pre><code>Observable.just(6,2,3,4,5)
        .toSortedList(new Func2&lt;Integer, Integer, Integer&gt;() {//自定义排序
            @Override
            public Integer call(Integer integer, Integer integer2) {
                return integer-integer2; //&gt;0 升序 ，&lt;0 降序
            }
        })
        .subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {
            @Override
            public void call(List&lt;Integer&gt; integers) {
                Log.d(&quot;JG&quot;,integers.toString()); // [2, 3, 4, 5, 6]
            }
        });
</code></pre><h4 id="toMap：-将序列数据转换为一个Map。我们可以根据数据项生成key和生成value。"><a href="#toMap：-将序列数据转换为一个Map。我们可以根据数据项生成key和生成value。" class="headerlink" title="toMap： 将序列数据转换为一个Map。我们可以根据数据项生成key和生成value。"></a>toMap： 将序列数据转换为一个Map。我们可以根据数据项生成key和生成value。</h4><pre><code>Observable.just(6,2,3,4,5)
        .toMap(new Func1&lt;Integer, String&gt;() {
            @Override
            public String call(Integer integer) {
                return &quot;key：&quot; + integer; //根据数据项生成map的key
            }
        }, new Func1&lt;Integer, String&gt;() {
            @Override
            public String call(Integer integer) {
                return &quot;value：&quot;+integer; //根据数据项生成map的kvalue
            }
        }).subscribe(new Action1&lt;Map&lt;String, String&gt;&gt;() {
    @Override
    public void call(Map&lt;String, String&gt; stringStringMap) {
        Log.d(&quot;JG&quot;,stringStringMap.toString()); // {key：6=value：6, key：5=value：5, key：4=value：4, key：2=value：2, key：3=value：3}
    }
});
</code></pre><h4 id="toMultiMap：-类似于toMap，不同的地方在于map的value是一个集合。"><a href="#toMultiMap：-类似于toMap，不同的地方在于map的value是一个集合。" class="headerlink" title="toMultiMap： 类似于toMap，不同的地方在于map的value是一个集合。"></a>toMultiMap： 类似于toMap，不同的地方在于map的value是一个集合。</h4><h2 id="变换操作"><a href="#变换操作" class="headerlink" title="变换操作"></a>变换操作</h2><h4 id="map：-对Observable发射的每一项数据都应用一个函数来变换。"><a href="#map：-对Observable发射的每一项数据都应用一个函数来变换。" class="headerlink" title="map： 对Observable发射的每一项数据都应用一个函数来变换。"></a>map： 对Observable发射的每一项数据都应用一个函数来变换。</h4><pre><code>Observable.just(6,2,3,4,5)
        .map(integer -&gt; &quot;item:&quot;+integer)
        .subscribe(s -&gt; Log.d(&quot;JG&quot;,s));//item:6,item:2....
</code></pre><h4 id="cast：-在发射之前强制将Observable发射的所有数据转换为指定类型"><a href="#cast：-在发射之前强制将Observable发射的所有数据转换为指定类型" class="headerlink" title="cast： 在发射之前强制将Observable发射的所有数据转换为指定类型"></a>cast： 在发射之前强制将Observable发射的所有数据转换为指定类型</h4><h4 id="flatMap：-将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。"><a href="#flatMap：-将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。" class="headerlink" title="flatMap： 将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。"></a>flatMap： 将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。</h4><pre><code>   Observable.just(2,3,5)
        .flatMap(new Func1&lt;Integer, Observable&lt;String&gt;&gt;() {
            @Override
            public Observable&lt;String&gt; call(Integer integer) {
                return Observable.create(subscriber -&gt; {
                    subscriber.onNext(integer*10+&quot;&quot;);
                    subscriber.onNext(integer*100+&quot;&quot;);
                    subscriber.onCompleted();
                });
            }
        })
.subscribe(o -&gt; Log.d(&quot;JG&quot;,o)) //20,200,30,300,50,500
</code></pre><h4 id="flatMapIterable：-和flatMap的作用一样，只不过生成的是Iterable而不是Observable。"><a href="#flatMapIterable：-和flatMap的作用一样，只不过生成的是Iterable而不是Observable。" class="headerlink" title="flatMapIterable： 和flatMap的作用一样，只不过生成的是Iterable而不是Observable。"></a>flatMapIterable： 和flatMap的作用一样，只不过生成的是Iterable而不是Observable。</h4><pre><code>    Observable.just(2,3,5)
        .flatMapIterable(new Func1&lt;Integer, Iterable&lt;String&gt;&gt;() {
            @Override
            public Iterable&lt;String&gt; call(Integer integer) {
                return Arrays.asList(integer*10+&quot;&quot;,integer*100+&quot;&quot;);
            }
        }).subscribe(new Action1&lt;String&gt;() {
          @Override
          public void call(String s) {

          }
});
</code></pre><h4 id="concatMap：-类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。"><a href="#concatMap：-类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。" class="headerlink" title="concatMap： 类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。"></a>concatMap： 类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。</h4><h4 id="switchMap：-和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。"><a href="#switchMap：-和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。" class="headerlink" title="switchMap： 和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。"></a>switchMap： 和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。</h4><pre><code>Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() {

    @Override
    public void call(Subscriber&lt;? super Integer&gt; subscriber) {
        for(int i=1;i&lt;4;i++){
            subscriber.onNext(i);
            Utils.sleep(500,subscriber);//线程休眠500ms
        }

        subscriber.onCompleted();
    }
}).subscribeOn(Schedulers.newThread())
  .switchMap(new Func1&lt;Integer, Observable&lt;Integer&gt;&gt;() {
         @Override
       public Observable&lt;Integer&gt; call(Integer integer) {
               //每当接收到新的数据，之前的Observable将会被取消订阅
                return Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() {
                    @Override
                    public void call(Subscriber&lt;? super Integer&gt; subscriber) {
                        subscriber.onNext(integer*10);
                        Utils.sleep(500,subscriber);
                        subscriber.onNext(integer*100);
                        subscriber.onCompleted();
                    }
                }).subscribeOn(Schedulers.newThread());
            }
        })
        .subscribe(s -&gt; Log.d(&quot;JG&quot;,s.toString()));//10,20,30,300
</code></pre><h4 id="scan：-与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值。"><a href="#scan：-与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值。" class="headerlink" title="scan： 与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值。"></a>scan： 与reduce很像，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射每一个值。</h4><pre><code>Observable.just(2,3,5)
        .scan(new Func2&lt;Integer, Integer, Integer&gt;() {
            @Override
            public Integer call(Integer sum, Integer item) {
                return sum+item;
            }
        })
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString())) //2,5,10
</code></pre><h4 id="groupBy：-将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据。"><a href="#groupBy：-将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据。" class="headerlink" title="groupBy： 将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据。"></a>groupBy： 将Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据。</h4><pre><code>Observable.just(2,3,5,6)
        .groupBy(new Func1&lt;Integer, String&gt;() {
            @Override
            public String call(Integer integer) {//分组
                return integer%2==0?&quot;偶数&quot;:&quot;奇数&quot;;
            }
        })
.subscribe(new Action1&lt;GroupedObservable&lt;String, Integer&gt;&gt;() {
    @Override
    public void call(GroupedObservable&lt;String, Integer&gt; o) {

        o.subscribe(new Action1&lt;Integer&gt;() {
            @Override
            public void call(Integer integer) {
                Log.d(&quot;JG&quot;,o.getKey()+&quot;:&quot;+integer.toString()); //偶数：2，奇数：3，...
            }
        });
    }
})
</code></pre><h4 id="buffer：-它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个"><a href="#buffer：-它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个" class="headerlink" title="buffer： 它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个"></a>buffer： 它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个</h4><pre><code>Observable.just(2,3,5,6)
        .buffer(3)
        .subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {
            @Override
            public void call(List&lt;Integer&gt; integers) {

            }
        })
</code></pre><h4 id="window：-定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。"><a href="#window：-定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。" class="headerlink" title="window： 定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。"></a>window： 定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。</h4><pre><code>Observable.just(2,3,5,6)
        .window(3)
        .subscribe(new Action1&lt;Observable&lt;Integer&gt;&gt;() {
            @Override
            public void call(Observable&lt;Integer&gt; integerObservable) {
                integerObservable.subscribe(new Action1&lt;Integer&gt;() {
                    @Override
                    public void call(Integer integer) {

                    }
                });
            }
        })
</code></pre><p>##错误处理/重试机制</p>
<h4 id="onErrorResumeNext：-当原始Observable在遇到错误时，使用备用Observable。。"><a href="#onErrorResumeNext：-当原始Observable在遇到错误时，使用备用Observable。。" class="headerlink" title="onErrorResumeNext： 当原始Observable在遇到错误时，使用备用Observable。。"></a>onErrorResumeNext： 当原始Observable在遇到错误时，使用备用Observable。。</h4><pre><code>Observable.just(1,&quot;2&quot;,3)
.cast(Integer.class)
.onErrorResumeNext(Observable.just(1,2,3))
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString())) //1,2,3
;
</code></pre><h4 id="onExceptionResumeNext：-当原始Observable在遇到异常时，使用备用的Observable。与onErrorResumeNext类似，区别在于onErrorResumeNext可以处理所有的错误，onExceptionResumeNext只能处理异常。"><a href="#onExceptionResumeNext：-当原始Observable在遇到异常时，使用备用的Observable。与onErrorResumeNext类似，区别在于onErrorResumeNext可以处理所有的错误，onExceptionResumeNext只能处理异常。" class="headerlink" title="onExceptionResumeNext： 当原始Observable在遇到异常时，使用备用的Observable。与onErrorResumeNext类似，区别在于onErrorResumeNext可以处理所有的错误，onExceptionResumeNext只能处理异常。"></a>onExceptionResumeNext： 当原始Observable在遇到异常时，使用备用的Observable。与onErrorResumeNext类似，区别在于onErrorResumeNext可以处理所有的错误，onExceptionResumeNext只能处理异常。</h4><h4 id="onErrorReturn：-当原始Observable在遇到错误时发射一个特定的数据。"><a href="#onErrorReturn：-当原始Observable在遇到错误时发射一个特定的数据。" class="headerlink" title="onErrorReturn： 当原始Observable在遇到错误时发射一个特定的数据。"></a>onErrorReturn： 当原始Observable在遇到错误时发射一个特定的数据。</h4><pre><code>Observable.just(1,&quot;2&quot;,3)
        .cast(Integer.class)
        .onErrorReturn(new Func1&lt;Throwable, Integer&gt;() {
            @Override
            public Integer call(Throwable throwable) {
                return 4;
            }
        }).subscribe(new Action1&lt;Integer&gt;() {
    @Override
    public void call(Integer integer) {
        Log.d(&quot;JG&quot;,integer.toString());1,4
    }
});
</code></pre><h4 id="retry：-当原始Observable在遇到错误时进行重试。"><a href="#retry：-当原始Observable在遇到错误时进行重试。" class="headerlink" title="retry： 当原始Observable在遇到错误时进行重试。"></a>retry： 当原始Observable在遇到错误时进行重试。</h4><pre><code>Observable.just(1,&quot;2&quot;,3)
.cast(Integer.class)
.retry(3)
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()),throwable -&gt; Log.d(&quot;JG&quot;,&quot;onError&quot;))
;//1,1,1,1,onError
</code></pre><h4 id="retryWhen：-当原始Observable在遇到错误，将错误传递给另一个Observable来决定是否要重新订阅这个Observable-内部调用的是retry。"><a href="#retryWhen：-当原始Observable在遇到错误，将错误传递给另一个Observable来决定是否要重新订阅这个Observable-内部调用的是retry。" class="headerlink" title="retryWhen： 当原始Observable在遇到错误，将错误传递给另一个Observable来决定是否要重新订阅这个Observable,内部调用的是retry。"></a>retryWhen： 当原始Observable在遇到错误，将错误传递给另一个Observable来决定是否要重新订阅这个Observable,内部调用的是retry。</h4><pre><code>Observable.just(1,&quot;2&quot;,3)
.cast(Integer.class)
.retryWhen(new Func1&lt;Observable&lt;? extends Throwable&gt;, Observable&lt;Long&gt;&gt;() {
    @Override
    public Observable&lt;Long&gt; call(Observable&lt;? extends Throwable&gt; observable) {
        return Observable.timer(1, TimeUnit.SECONDS);
    }
})
.subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()),throwable -&gt; Log.d(&quot;JG&quot;,&quot;onError&quot;));
//1,1
</code></pre><h2 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h2><h4 id="ConnectableObservable与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect-被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。"><a href="#ConnectableObservable与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect-被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。" class="headerlink" title="ConnectableObservable与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect()被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。"></a>ConnectableObservable与普通的Observable差不多，但是可连接的Observable在被订阅时并不开始发射数据，只有在它的connect()被调用时才开始。用这种方法，你可以等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。</h4><h4 id="ConnectableObservable-connect-指示一个可连接的Observable开始发射数据"><a href="#ConnectableObservable-connect-指示一个可连接的Observable开始发射数据" class="headerlink" title="ConnectableObservable.connect()指示一个可连接的Observable开始发射数据."></a>ConnectableObservable.connect()指示一个可连接的Observable开始发射数据.</h4><h4 id="Observable-publish-将一个Observable转换为一个可连接的Observable"><a href="#Observable-publish-将一个Observable转换为一个可连接的Observable" class="headerlink" title="Observable.publish()将一个Observable转换为一个可连接的Observable"></a>Observable.publish()将一个Observable转换为一个可连接的Observable</h4><h4 id="Observable-replay-确保所有的订阅者看到相同的数据序列的ConnectableObservable，即使它们在Observable开始发射数据之后才订阅。"><a href="#Observable-replay-确保所有的订阅者看到相同的数据序列的ConnectableObservable，即使它们在Observable开始发射数据之后才订阅。" class="headerlink" title="Observable.replay()确保所有的订阅者看到相同的数据序列的ConnectableObservable，即使它们在Observable开始发射数据之后才订阅。"></a>Observable.replay()确保所有的订阅者看到相同的数据序列的ConnectableObservable，即使它们在Observable开始发射数据之后才订阅。</h4><h4 id="ConnectableObservable-refCount-让一个可连接的Observable表现得像一个普通的Observable。"><a href="#ConnectableObservable-refCount-让一个可连接的Observable表现得像一个普通的Observable。" class="headerlink" title="ConnectableObservable.refCount()让一个可连接的Observable表现得像一个普通的Observable。"></a>ConnectableObservable.refCount()让一个可连接的Observable表现得像一个普通的Observable。</h4><pre><code>ConnectableObservable&lt;Integer&gt; co= Observable.just(1,2,3)
         .publish();

 co .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()) );
 co.connect();//此时开始发射数据
</code></pre><h2 id="阻塞操作"><a href="#阻塞操作" class="headerlink" title="阻塞操作"></a>阻塞操作</h2><h4 id="BlockingObservable是一个阻塞的Observable。普通的Observable-转换为BlockingObservable，可以使用-Observable-toBlocking-方法或者BlockingObservable-from-方法。内部通过CountDownLatch实现了阻塞操作。"><a href="#BlockingObservable是一个阻塞的Observable。普通的Observable-转换为BlockingObservable，可以使用-Observable-toBlocking-方法或者BlockingObservable-from-方法。内部通过CountDownLatch实现了阻塞操作。" class="headerlink" title="BlockingObservable是一个阻塞的Observable。普通的Observable 转换为BlockingObservable，可以使用 Observable.toBlocking( )方法或者BlockingObservable.from( )方法。内部通过CountDownLatch实现了阻塞操作。"></a>BlockingObservable是一个阻塞的Observable。普通的Observable 转换为BlockingObservable，可以使用 Observable.toBlocking( )方法或者BlockingObservable.from( )方法。内部通过CountDownLatch实现了阻塞操作。</h4><p>以下的操作符可以用于BlockingObservable，如果是普通的Observable，务必使用Observable.toBlocking()转为阻塞Observable后使用，否则达不到预期的效果。</p>
<h4 id="forEach：-对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。"><a href="#forEach：-对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。" class="headerlink" title="forEach： 对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。"></a>forEach： 对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。</h4><pre><code>Observable.just(2,3).observeOn(Schedulers.newThread()).toBlocking()
      .forEach(integer -&gt; {
          Log.d(&quot;JG&quot;,integer.toString()+&quot; &quot;+Thread.currentThread().getName());
          Utils.sleep(500);
      });

Log.d(&quot;JG&quot;,Thread.currentThread().getName());
// 2 RxNewThreadScheduler-1
// 3 RxNewThreadScheduler-1
// main
</code></pre><h4 id="first-firstOrDefault-last-lastOrDefault：这几个操作符之前有介绍过。也可以用于阻塞操作。"><a href="#first-firstOrDefault-last-lastOrDefault：这几个操作符之前有介绍过。也可以用于阻塞操作。" class="headerlink" title="first/firstOrDefault/last/lastOrDefault：这几个操作符之前有介绍过。也可以用于阻塞操作。"></a>first/firstOrDefault/last/lastOrDefault：这几个操作符之前有介绍过。也可以用于阻塞操作。</h4><h4 id="single-singleOrDefault：如果Observable终止时只发射了一个值，返回那个值，否则抛出异常或者发射默认值。"><a href="#single-singleOrDefault：如果Observable终止时只发射了一个值，返回那个值，否则抛出异常或者发射默认值。" class="headerlink" title="single/singleOrDefault：如果Observable终止时只发射了一个值，返回那个值，否则抛出异常或者发射默认值。"></a>single/singleOrDefault：如果Observable终止时只发射了一个值，返回那个值，否则抛出异常或者发射默认值。</h4><h4 id="mostRecent：返回一个总是返回Observable最近发射的数据的Iterable。"><a href="#mostRecent：返回一个总是返回Observable最近发射的数据的Iterable。" class="headerlink" title="mostRecent：返回一个总是返回Observable最近发射的数据的Iterable。"></a>mostRecent：返回一个总是返回Observable最近发射的数据的Iterable。</h4><h4 id="next：-返回一个Iterable，会阻塞直到Observable发射了第二个值，然后返回那个值。"><a href="#next：-返回一个Iterable，会阻塞直到Observable发射了第二个值，然后返回那个值。" class="headerlink" title="next： 返回一个Iterable，会阻塞直到Observable发射了第二个值，然后返回那个值。"></a>next： 返回一个Iterable，会阻塞直到Observable发射了第二个值，然后返回那个值。</h4><h4 id="latest：-返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值"><a href="#latest：-返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值" class="headerlink" title="latest： 返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值"></a>latest： 返回一个iterable，会阻塞直到或者除非Observable发射了一个iterable没有返回的值，然后返回这个值</h4><h4 id="toFuture：-将Observable转换为一个Future"><a href="#toFuture：-将Observable转换为一个Future" class="headerlink" title="toFuture： 将Observable转换为一个Future"></a>toFuture： 将Observable转换为一个Future</h4><h4 id="toIterable：将一个发射数据序列的Observable转换为一个Iterable。"><a href="#toIterable：将一个发射数据序列的Observable转换为一个Iterable。" class="headerlink" title="toIterable：将一个发射数据序列的Observable转换为一个Iterable。"></a>toIterable：将一个发射数据序列的Observable转换为一个Iterable。</h4><h4 id="getIterator：将一个发射数据序列的Observable转换为一个Iterator工具集"><a href="#getIterator：将一个发射数据序列的Observable转换为一个Iterator工具集" class="headerlink" title="getIterator：将一个发射数据序列的Observable转换为一个Iterator工具集"></a>getIterator：将一个发射数据序列的Observable转换为一个Iterator工具集</h4><h4 id="materialize：-将Observable转换成一个通知列表。"><a href="#materialize：-将Observable转换成一个通知列表。" class="headerlink" title="materialize： 将Observable转换成一个通知列表。"></a>materialize： 将Observable转换成一个通知列表。</h4><pre><code>Observable.just(1,2,3)
       .materialize()
       .subscribe(new Action1&lt;Notification&lt;Integer&gt;&gt;() {
           @Override
           public void call(Notification&lt;Integer&gt; notification) {
               Log.d(&quot;JG&quot;,notification.getKind()+&quot; &quot;+notification.getValue());
               //OnNext 1
               //OnNext 2
               //OnNext 3
               //OnCompleted null
           }
       });
</code></pre><h4 id="dematerialize：-与上面的作用相反，将通知逆转回一个Observable。"><a href="#dematerialize：-与上面的作用相反，将通知逆转回一个Observable。" class="headerlink" title="dematerialize： 与上面的作用相反，将通知逆转回一个Observable。"></a>dematerialize： 与上面的作用相反，将通知逆转回一个Observable。</h4><h4 id="timestamp：-给Observable发射的每个数据项添加一个时间戳。"><a href="#timestamp：-给Observable发射的每个数据项添加一个时间戳。" class="headerlink" title="timestamp： 给Observable发射的每个数据项添加一个时间戳。"></a>timestamp： 给Observable发射的每个数据项添加一个时间戳。</h4><pre><code>Observable.just(1,2,3)
       .timestamp()
       .subscribe(new Action1&lt;Timestamped&lt;Integer&gt;&gt;() {
           @Override
           public void call(Timestamped&lt;Integer&gt; timestamped) {
               Log.d(&quot;JG&quot;,timestamped.getTimestampMillis()+&quot; &quot;+timestamped.getValue());
               //1472627510548 1
               //1472627510549 2
               //1472627510549 3
           }
       });
</code></pre><h4 id="timeInterval：给Observable发射的两个数据项间添加一个时间差，实现在OperatorTimeInterval中"><a href="#timeInterval：给Observable发射的两个数据项间添加一个时间差，实现在OperatorTimeInterval中" class="headerlink" title="timeInterval：给Observable发射的两个数据项间添加一个时间差，实现在OperatorTimeInterval中"></a>timeInterval：给Observable发射的两个数据项间添加一个时间差，实现在OperatorTimeInterval中</h4><p><img src="http://static.zybuluo.com/maplejaw/6dbl77xvh2z02hxil00juave/image_1argc8a1n17a61t441s5p1gln8231g.png" alt="Markdown preferences pane"></p>
<h4 id="serialize：-强制Observable按次序发射数据并且要求功能是完好的"><a href="#serialize：-强制Observable按次序发射数据并且要求功能是完好的" class="headerlink" title="serialize： 强制Observable按次序发射数据并且要求功能是完好的"></a>serialize： 强制Observable按次序发射数据并且要求功能是完好的</h4><h4 id="cache：-缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者"><a href="#cache：-缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者" class="headerlink" title="cache： 缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者"></a>cache： 缓存Observable发射的数据序列并发射相同的数据序列给后续的订阅者</h4><h4 id="observeOn：-指定观察者观察Observable的调度器"><a href="#observeOn：-指定观察者观察Observable的调度器" class="headerlink" title="observeOn： 指定观察者观察Observable的调度器"></a>observeOn： 指定观察者观察Observable的调度器</h4><h4 id="subscribeOn：-指定Observable执行任务的调度器"><a href="#subscribeOn：-指定Observable执行任务的调度器" class="headerlink" title="subscribeOn： 指定Observable执行任务的调度器"></a>subscribeOn： 指定Observable执行任务的调度器</h4><h4 id="doOnEach：-注册一个动作，对Observable发射的每个数据项使用"><a href="#doOnEach：-注册一个动作，对Observable发射的每个数据项使用" class="headerlink" title="doOnEach： 注册一个动作，对Observable发射的每个数据项使用"></a>doOnEach： 注册一个动作，对Observable发射的每个数据项使用</h4><pre><code>Observable.just(2,3)
        .doOnEach(new Action1&lt;Notification&lt;? super Integer&gt;&gt;() {
            @Override
            public void call(Notification&lt;? super Integer&gt; notification) {
                Log.d(&quot;JG&quot;,&quot;--doOnEach--&quot;+notification.toString());
            }
        })
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));
</code></pre><p>//结果为：<br> // –doOnEach–[rx.Notification@133c40b0 OnNext 2]<br>// 2<br> // –doOnEach–[rx.Notification@133c40b0 OnNext 3]<br>// 3<br>// –doOnEach–[rx.Notification@df4db0e OnCompleted]</p>
<h4 id="doOnCompleted：-注册一个动作，对正常完成的Observable使用"><a href="#doOnCompleted：-注册一个动作，对正常完成的Observable使用" class="headerlink" title="doOnCompleted： 注册一个动作，对正常完成的Observable使用"></a>doOnCompleted： 注册一个动作，对正常完成的Observable使用</h4><h4 id="doOnError：-注册一个动作，对发生错误的Observable使用"><a href="#doOnError：-注册一个动作，对发生错误的Observable使用" class="headerlink" title="doOnError： 注册一个动作，对发生错误的Observable使用"></a>doOnError： 注册一个动作，对发生错误的Observable使用</h4><h4 id="doOnTerminate：注册一个动作，对完成的Observable使用，无论是否发生错误"><a href="#doOnTerminate：注册一个动作，对完成的Observable使用，无论是否发生错误" class="headerlink" title="doOnTerminate：注册一个动作，对完成的Observable使用，无论是否发生错误"></a>doOnTerminate：注册一个动作，对完成的Observable使用，无论是否发生错误</h4><pre><code>Observable.just(2,3)
        .doOnTerminate(new Action0() {
            @Override
            public void call() {
                Log.d(&quot;JG&quot;,&quot;--doOnTerminate--&quot;);
            }
        })
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));// 2 , 3 , --doOnTerminate--
</code></pre><h4 id="doOnSubscribe：-注册一个动作，在观察者订阅时使用。内部由OperatorDoOnSubscribe实现，"><a href="#doOnSubscribe：-注册一个动作，在观察者订阅时使用。内部由OperatorDoOnSubscribe实现，" class="headerlink" title="doOnSubscribe： 注册一个动作，在观察者订阅时使用。内部由OperatorDoOnSubscribe实现，"></a>doOnSubscribe： 注册一个动作，在观察者订阅时使用。内部由OperatorDoOnSubscribe实现，<img src="http://static.zybuluo.com/maplejaw/9w3o5vxc0lzznbrpn4vwa78w/image_1argbe0o1atfqtbrj51gu0jho9.png" alt="Markdown preferences pane"></h4><h4 id="doOnUnsubscribe：-注册一个动作，在观察者取消订阅时使用。内部由OperatorDoOnUnsubscribe实现，在call中加入一个解绑动作。"><a href="#doOnUnsubscribe：-注册一个动作，在观察者取消订阅时使用。内部由OperatorDoOnUnsubscribe实现，在call中加入一个解绑动作。" class="headerlink" title="doOnUnsubscribe： 注册一个动作，在观察者取消订阅时使用。内部由OperatorDoOnUnsubscribe实现，在call中加入一个解绑动作。"></a>doOnUnsubscribe： 注册一个动作，在观察者取消订阅时使用。内部由OperatorDoOnUnsubscribe实现，在call中加入一个解绑动作。</h4><p><img src="http://static.zybuluo.com/maplejaw/791vkq1lxpl2etqaql85a6e8/image_1argbhutoi1a1b6a18s9il6npvm.png" alt="Markdown preferences pane"></p>
<h4 id="finallyDo-doAfterTerminate：-注册一个动作，在Observable完成时使用"><a href="#finallyDo-doAfterTerminate：-注册一个动作，在Observable完成时使用" class="headerlink" title="finallyDo/doAfterTerminate： 注册一个动作，在Observable完成时使用"></a>finallyDo/doAfterTerminate： 注册一个动作，在Observable完成时使用</h4><pre><code>Observable.just(2,3)
        .doAfterTerminate(new Action0() {
            @Override
            public void call() {
                Log.d(&quot;JG&quot;,&quot;--doAfterTerminate--&quot;);
            }
        })
        .subscribe(integer -&gt; Log.d(&quot;JG&quot;,integer.toString()));
    //2,3,  --doAfterTerminate-- 
</code></pre><h4 id="delay：-延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。"><a href="#delay：-延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。" class="headerlink" title="delay： 延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。"></a>delay： 延时发射Observable的结果。即让原始Observable在发射每项数据之前都暂停一段指定的时间段。效果是Observable发射的数据项在时间上向前整体平移了一个增量（除了onError，它会即时通知）。</h4><h4 id="delaySubscription：-延时处理订阅请求。实现在OnSubscribeDelaySubscription中"><a href="#delaySubscription：-延时处理订阅请求。实现在OnSubscribeDelaySubscription中" class="headerlink" title="delaySubscription： 延时处理订阅请求。实现在OnSubscribeDelaySubscription中"></a>delaySubscription： 延时处理订阅请求。实现在OnSubscribeDelaySubscription中</h4><p><img src="http://static.zybuluo.com/maplejaw/xqw7fto75revvct4zu3d56a5/image_1argc0tbetbj1rkj1etf4fcb1p13.png" alt="Markdown preferences pane"></p>
<h4 id="using：-创建一个只在Observable生命周期存在的资源，当Observable终止时这个资源会被自动释放。"><a href="#using：-创建一个只在Observable生命周期存在的资源，当Observable终止时这个资源会被自动释放。" class="headerlink" title="using： 创建一个只在Observable生命周期存在的资源，当Observable终止时这个资源会被自动释放。"></a>using： 创建一个只在Observable生命周期存在的资源，当Observable终止时这个资源会被自动释放。</h4><pre><code>Observable.using(new Func0&lt;File&gt;() {//资源工厂
    @Override
    public File call() {

        File file = new File(getCacheDir(), &quot;a.txt&quot;);
        if(!file.exists()){
            try {
                Log.d(&quot;JG&quot;,&quot;--create--&quot;);
                file.createNewFile();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return file;
    }
}, new Func1&lt;File, Observable&lt;String&gt;&gt;() { //Observable
    @Override
    public Observable&lt;String&gt; call(File file) {
        return Observable.just(file.exists() ? &quot;exist&quot; : &quot;no exist&quot;);
    }
}, new Action1&lt;File&gt;() {//释放资源动作
    @Override
    public void call(File file) {
        if(file!=null&amp;&amp;file.exists()){
            Log.d(&quot;JG&quot;,&quot;--delete--&quot;);
            file.delete();
        }
    }
})
.subscribe(s -&gt; Log.d(&quot;JG&quot;,s))
;
//--create--
//exist
//--delete--
</code></pre><h4 id="single-singleOrDefault：-强制返回单个数据，否则抛出异常或默认数据。"><a href="#single-singleOrDefault：-强制返回单个数据，否则抛出异常或默认数据。" class="headerlink" title="single/singleOrDefault： 强制返回单个数据，否则抛出异常或默认数据。"></a>single/singleOrDefault： 强制返回单个数据，否则抛出异常或默认数据。</h4><p>关于RxJava标准库的操作符已经介绍完毕，纯粹当个备忘录。如有错误之处，欢迎指出。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2016/12/26/Android中的TouchEvent触摸事件机制/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content>
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/26/Android中的TouchEvent触摸事件机制/" itemprop="url">
                  Android中的TouchEvent触摸事件机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-26T19:22:32+08:00">
                2016-12-26
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当我们的手指在Android屏幕上点击或滑动时，就会触发触摸事件TouchEvent。在App中ViewGroup和View存在多级嵌套，在最外层的是Activity，最内层的View，介于Activity与View之间的是一些ViewGroup。本文为了简化讨论，我们假设一个Activity中只有一个ViewGroup，这个ViewGroup中只有一个View。当我们用手指触摸到View的UI时，就会产生触摸事件TouchEvent，总的过程如下图所示：</p>
<p><img src="http://fastabler.online/images/20151219223049372.png" alt></p>
<p>首先是最外层的Activity接收到该事件，触发Activity的dispatchTouchEvent的执行，在该方法中Activity又会调用内部ViewGroup的dispatchTouchEvent方法的执行，在ViewGroup的dispatchTouchEvent方法中又会调用最内层的View的dispatchTouchEvent方法的执行，在View的dispatchTouchEvent方法中可能会执行View的onTouchEvent方法，然后ViewGroup也有可能执行ViewGroup的onTouchEvent方法，然后Activity也有可能执行Activity的onTouchEvent方法的执行。</p>
<p>上图是精简过的主要流程图，总共是两条主线：</p>
<p>第一条主线是，从Activity -&gt; ViewGroup -&gt; View，从外向内依次调用dispatchTouchEvent方法，Android会依次把MotionEvent参数传递给该方法。dispatchTouchEvent的作用是传递触摸事件，该主线体现了将触摸事件从外向内逐级传递派发的过程，dispatchTouchEvent是每次传递触摸事件的入口。</p>
<p>第二条主线是，从View -&gt; ViewGroup -&gt; Activity，从内向外依次调用onTouchEvent方法，Android会依次把MotionEvent参数传递给该方法。onTouchEvent的作用是处理触摸事件，该主线体现了将触摸事件从内向外逐级处理的过程。</p>
<p>dispatchTouchEvent和onTouchEvent都接收一个MotionEvent类型的参数，MotionEvent封装了触摸事件的数据信息，包括触摸事件的类型以及坐标位置等，详见博文《Android中的MotionEvent》。dispatchTouchEvent和onTouchEvent都有一个boolean类型的返回值，如果返回true，表示当前对象已经对触摸事件进行了处理；如果返回false，表示当前对象没有对触摸事件进行处理。</p>
<p>下面分别对Activity、ViewGroup、View的事件派发、处理的过程详细说明。</p>
<h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><h3 id="dispatchTouchEvent"><a href="#dispatchTouchEvent" class="headerlink" title="dispatchTouchEvent"></a>dispatchTouchEvent</h3><p>所有在UI上的触摸操作生成的触摸事件都首先会触发Activity中dispatchTouchEvent方法的执行，其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    if (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述方法的关键是，Activity会首先通过getWindow()方法获取当前的window对象，然后调用window的superDispatchTouchEvent方法，实际上，getWindow()返回的是一个PhoneWindow类型的实例，这样就会调用PhoneWindow的superDispatchTouchEvent方法，其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    return mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mDecor是PhoneWindow中一个DecorView类型的变量，DecorView代表了当前Window最顶级的View，可以看做是根View。由上代码看出，后面会执行DecorView的superDispatchTouchEvent方法，其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    return super.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上DectorView继承自FrameLayout，所以DectorView间接继承自ViewGroup，所以会DectorView执行其父类ViewGroup对应的dispatchTouchEvent方法。在该方法中，DectorView会找到其触摸的子节点，实际上其子节点也是一个ViewGroup，然后再执行该ViewGroup的dispatchTouchEvent方法，这样就实现了将触摸事件参数MotionEvent从Activity中传入到DecorView的子ViewGroup中了。我们会在后面探讨ViewGroup中的dispatchTouchEvent方法中的执行逻辑，此处就不再过多介绍了。</p>
<p>以上介绍了借助superDispatchTouchEvent和dispatchTouchEvent方法将触摸事件从Activity到ViewGroup中的传递过程，这两个方法均返回一个boolean类型的参数，如果返回true，表示触摸事件被处理了，反之表示触摸事件没有被处理。我们再看一下上面Activity中dispatchTouchEvent的源码，就会发现如果PhoneWindow的superDispatchTouchEvent返回了true，那么Activity的dispatchTouchEvent方法也就直接返回了true，表明触摸事件被Window给处理了，所以就不会执行后面Activity的 onTouchEvent方法。只有Window没处理触摸事件的情况下，Activity才会调用onTouchEvent方法去处理事件。</p>
<h3 id="onTouchEvent"><a href="#onTouchEvent" class="headerlink" title="onTouchEvent"></a>onTouchEvent</h3><p>onTouchEvent的源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    if (mWindow.shouldCloseOnTouch(this, event)) &#123;</span><br><span class="line">        finish();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只有当触摸事件没有被任何的View或ViewGroup处理过的时候，Activity才会执行自己的onTouchEvent去处理触摸事件。一种典型的情形就是，当前触摸点在Window范围之外，这样Window里面所有的View都不会接收更不会处理该触摸事件，这时候我们可以重写该方法实现一些自己的逻辑处理这种情形。如果我们处理了，就返回true，否则返回false。其默认实现基本一直返回false。</p>
<h2 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><h3 id="dispatchTouchEvent-1"><a href="#dispatchTouchEvent-1" class="headerlink" title="dispatchTouchEvent"></a>dispatchTouchEvent</h3><p>当Activity接收到触摸事件之后，会通过DectorView调用ViewGroup的dispatchTouchEvent方法，由于该方法的源码太长，此处就不贴源码了，点此查看其源码。此处主要说一下该方法中的主要逻辑。dispatchTouchEvent方法是ViewGroup对触摸事件进行处理的入口。</p>
<p>ViewGroup中定义了一个TouchTarget类型的成员变量mFirstTouchTarget，用于保存当前ViewGroup中处理了触摸事件的子View。</p>
<p>首先，dispatchTouchEvent方法会调用其自身的onInterceptTouchEvent方法，onInterceptTouchEvent是用来拦截ViewGroup将触摸事件传递给其子View的，如果该方法返回true，就表示ViewGroup应该拦截触摸事件；如果返回false，表示ViewGroup不应该拦截触摸事件，应该将触摸事件传递给子View。在dispathTouchEvent方法中还定义了一个boolean类型的handled变量，用于保存dispathTouchEvent方法的返回值，如果是true就表示触摸事件被当前的ViewGroup处理了，反之则表示没被处理。</p>
<p>然后，只有当onInterceptTouchEvent返回了false，ViewGroup才会依次遍历其子View，其会通过调用isTransformedTouchPointInView方法判断MotionEvent所携带的触摸事件的坐标是否落在子View的范围内，如果触摸事件的坐标恰好落在了该子View范围内，说明我们触摸了当前ViewGroup内的该子View，这样ViewGroup就会把触摸事件的坐标以及该子View传递给dispatchTransformedTouchEvent方法，在该方法内会调用子View的dispatchTouchEvent方法，其返回值表示自View是否处理了触摸事件，如果dispatchTransformedTouchEvent返回true，表示子View处理了触摸事件，这样ViewGroup会通过调用addTouchTarget方法将mFirstTouchTarget绑定该子View，并且变量alreadyDispatchedToNewTouchTarget也会设置为true，表示已经有子View处理了触摸事件。一旦有子View处理了触摸事件，ViewGroup就会通过break跳出for循环，不再对其他子View进行遍历。</p>
<p>在经过了对子View的for循环之后，如果没有任何的子View处理了触摸事件，那么mFirstTouchTarget就还是null，此时ViewGroup就会将null作为child参数传入dispatchTransformedTouchEvent方法中，该方法会调用super.dispatchTouchEvent方法，由于ViewGroup继承自View，以此处就相当于执行了View类中的dispatchTouchEvent方法，这样就很有可能执行ViewGroup从View中继承来的onTouchEvent方法。dispatchTransformedTouchEvent的返回值会作为局部变量handled的值。关于View类中的dispatchTouchEvent方法会在下面详细说明。</p>
<p>在经过了对子View的for循环之后，如果发现某个子View对触摸事件进行了处理，那么alreadyDispatchedToNewTouchTarget就是true，从而会将局部变量handled设置为true，即表示只要有子View处理了触摸事件，就表示当前的ViewGroup也处理了触摸事件，并且这种情况下ViewGroup不会调用从View中继承来的dispatchTouchEvent方法，从而不会触发ViewGroup的onTouchEvent方法的执行。</p>
<h3 id="onInterceptTouchEvent"><a href="#onInterceptTouchEvent" class="headerlink" title="onInterceptTouchEvent"></a>onInterceptTouchEvent</h3><p>之前提到过onInterceptTouchEvent用于拦截ViewGroup向子View传递触摸事件，ViewGroup中的默认实现一直返回false，即表示不拦截。我们可以重写该方法以实现我们自己的触摸事件拦截逻辑。</p>
<p>dispatchTransformedTouchEvent<br>点此查看源码，其主要的逻辑代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,</span><br><span class="line">        View child, int desiredPointerIdBits) &#123;</span><br><span class="line"></span><br><span class="line">  final boolean handled;</span><br><span class="line"></span><br><span class="line">  final MotionEvent transformedEvent;</span><br><span class="line"></span><br><span class="line">  ......        </span><br><span class="line"></span><br><span class="line">    // Perform any necessary transformations and dispatch.</span><br><span class="line">    if (child == null) &#123;</span><br><span class="line">        handled = super.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final float offsetX = mScrollX - child.mLeft;</span><br><span class="line">        final float offsetY = mScrollY - child.mTop;</span><br><span class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">        if (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">            transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Done.</span><br><span class="line">    transformedEvent.recycle();</span><br><span class="line">    return handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法的主要目的是将MotionEvent中的x、y的坐标转换成所传入的child变量所指定的的View的坐标系中的坐标，transformedEvent表示了已经完成了指定坐标系转换的MotionEvent。如果传入的child参数是null，表示传入的是当前的ViewGroup，此时就将直接调用super.dispatchTouchEvent(transformedEvent)，这样就让ViewGroup调用了父类View中的dispatchTouchEvent方法；如果传入的child参数不是null，表示传入的当前ViewGroup的一个子View，那么就会调用child.dispatchTouchEvent(transformedEvent)，从而将触摸事件从ViewGroup传递到子View中去。我们会在下面介绍View的dispatchTouchEvent的实现逻辑。</p>
<h3 id="onTouchEvent-1"><a href="#onTouchEvent-1" class="headerlink" title="onTouchEvent"></a>onTouchEvent</h3><p>ViewGroup的onTouchEvent继承自View的onTouchEvent方法，ViewGroup并没有重写，我们在下面会介绍View的onTouchEvent方法的实现逻辑。</p>
<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><h2 id="dispatchTouchEvent-2"><a href="#dispatchTouchEvent-2" class="headerlink" title="dispatchTouchEvent"></a>dispatchTouchEvent</h2><p>点此查看源码，其源码的主要逻辑如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    boolean result = false;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    if (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        //noinspection SimplifiableIfStatement</span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        //如果设置了OnTouchListener，那么会在此处执行OnTouchListener的onTouch方法</span><br><span class="line">        if (li != null &amp;&amp; li.mOnTouchListener != null</span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</span><br><span class="line">            //如果OnTouchListener的onTouch方法返回true，就表示触摸事件被处理了，result就会设置为true</span><br><span class="line">            result = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果触摸事件没有被OnTouchListener处理，那么就会执行View的onTouchEvent方法</span><br><span class="line">        if (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            //如果onTouchEvent返回了true，就表示触摸事件被View处理了，result就被设置为了true</span><br><span class="line">            result = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>dispatchTouchEvent是View处理触摸事件的入口。在该方法中，View首先会查看其有没有设置过OnTouchListener，如果设置过就调用OnTouchListener的onTouch方法，如果其返回了true，就表明触摸事件被处理了，result就会设置为true。如果触摸事件没有被OnTouchListener处理，那么就会执行View的onTouchEvent方法，如果onTouchEvent返回了true，就表示触摸事件被View处理了，result就被设置为了true。</p>
<p>由上可以看出，在dispatchTouchEvent方法中是先执行OnTouchListener的onTouch方法，一旦其返回true，就不会调用View自身的onTouchEvent方法了，只有OnTouchListener没有处理触摸事件才会在后面执行View的onTouchEvent方法。</p>
<h3 id="onTouchEvent-2"><a href="#onTouchEvent-2" class="headerlink" title="onTouchEvent"></a>onTouchEvent</h3><p>点此查看源码，View.onTouchEvent()方法中，如果View注册了CLICK或LONG_CLICK等事件监听器，那么就会让注册的事件监听器处理触摸事件，这样onTouchEvent就返回true。会根据ACTION的不同，执行不同的处理，比如如果是ACTION_UP，会执行performClick()方法，该方法会触发OnClickListener.onClick()的执行。<br>如果View没有注册任何的CLICK或LONG_CLICK等的事件监听器，那么onTouchEvent就返回false，表示onTouchEvent没有对传入的触摸事件MotionEvent做任何处理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们通过对上面Activity、ViewGroup、View各个层级对触摸事件的处理过程可以发现，Android中每个层级对触摸事件的处理都是从dispatchTouchEvent方法开始的，首先先调用下一层级的dispatchTouchEvent方法，将触摸事件传递给下一层级，如果下一层级对触摸事件进行了处理，就可认为本层级也对触摸事件进行了处理，那么本层级就不会对触摸事件仅需做其他特殊处理了；如果下一层级没有对触摸事件进行处理，即下一层级的dispatchTouchEvent方法返回false，那么才会调用本层级的onTouchEvent方法对触摸事件进行处理。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg" alt="fastabler">
          <p class="site-author-name" itemprop="name">fastabler</p>
          <p class="site-description motion-element" itemprop="description">Efforts can only pass,hard to be excellent.</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fastabler</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  




  
  

  

  

  

  


</body>
</html>

<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="Efforts can only pass,hard to be excellent.">
<meta property="og:type" content="website">
<meta property="og:title" content="黄金龙的博客">
<meta property="og:url" content="http://hjlinfo.top/page/2/index.html">
<meta property="og:site_name" content="黄金龙的博客">
<meta property="og:description" content="Efforts can only pass,hard to be excellent.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="黄金龙的博客">
<meta name="twitter:description" content="Efforts can only pass,hard to be excellent.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hjlinfo.top/page/2/">





  <title> 黄金龙的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?ad1350e91810844821a7ad3e1f8ac561";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">黄金龙的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">fastabler</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2016/12/26/Android中的TouchEvent触摸事件机制/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content>
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/26/Android中的TouchEvent触摸事件机制/" itemprop="url">
                  Android中的TouchEvent触摸事件机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-26T19:22:32+08:00">
                2016-12-26
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当我们的手指在Android屏幕上点击或滑动时，就会触发触摸事件TouchEvent。在App中ViewGroup和View存在多级嵌套，在最外层的是Activity，最内层的View，介于Activity与View之间的是一些ViewGroup。本文为了简化讨论，我们假设一个Activity中只有一个ViewGroup，这个ViewGroup中只有一个View。当我们用手指触摸到View的UI时，就会产生触摸事件TouchEvent，总的过程如下图所示：</p>
<p><img src="http://fastabler.online/images/20151219223049372.png" alt></p>
<p>首先是最外层的Activity接收到该事件，触发Activity的dispatchTouchEvent的执行，在该方法中Activity又会调用内部ViewGroup的dispatchTouchEvent方法的执行，在ViewGroup的dispatchTouchEvent方法中又会调用最内层的View的dispatchTouchEvent方法的执行，在View的dispatchTouchEvent方法中可能会执行View的onTouchEvent方法，然后ViewGroup也有可能执行ViewGroup的onTouchEvent方法，然后Activity也有可能执行Activity的onTouchEvent方法的执行。</p>
<p>上图是精简过的主要流程图，总共是两条主线：</p>
<p>第一条主线是，从Activity -&gt; ViewGroup -&gt; View，从外向内依次调用dispatchTouchEvent方法，Android会依次把MotionEvent参数传递给该方法。dispatchTouchEvent的作用是传递触摸事件，该主线体现了将触摸事件从外向内逐级传递派发的过程，dispatchTouchEvent是每次传递触摸事件的入口。</p>
<p>第二条主线是，从View -&gt; ViewGroup -&gt; Activity，从内向外依次调用onTouchEvent方法，Android会依次把MotionEvent参数传递给该方法。onTouchEvent的作用是处理触摸事件，该主线体现了将触摸事件从内向外逐级处理的过程。</p>
<p>dispatchTouchEvent和onTouchEvent都接收一个MotionEvent类型的参数，MotionEvent封装了触摸事件的数据信息，包括触摸事件的类型以及坐标位置等，详见博文《Android中的MotionEvent》。dispatchTouchEvent和onTouchEvent都有一个boolean类型的返回值，如果返回true，表示当前对象已经对触摸事件进行了处理；如果返回false，表示当前对象没有对触摸事件进行处理。</p>
<p>下面分别对Activity、ViewGroup、View的事件派发、处理的过程详细说明。</p>
<h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><h3 id="dispatchTouchEvent"><a href="#dispatchTouchEvent" class="headerlink" title="dispatchTouchEvent"></a>dispatchTouchEvent</h3><p>所有在UI上的触摸操作生成的触摸事件都首先会触发Activity中dispatchTouchEvent方法的执行，其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    if (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述方法的关键是，Activity会首先通过getWindow()方法获取当前的window对象，然后调用window的superDispatchTouchEvent方法，实际上，getWindow()返回的是一个PhoneWindow类型的实例，这样就会调用PhoneWindow的superDispatchTouchEvent方法，其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    return mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mDecor是PhoneWindow中一个DecorView类型的变量，DecorView代表了当前Window最顶级的View，可以看做是根View。由上代码看出，后面会执行DecorView的superDispatchTouchEvent方法，其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    return super.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上DectorView继承自FrameLayout，所以DectorView间接继承自ViewGroup，所以会DectorView执行其父类ViewGroup对应的dispatchTouchEvent方法。在该方法中，DectorView会找到其触摸的子节点，实际上其子节点也是一个ViewGroup，然后再执行该ViewGroup的dispatchTouchEvent方法，这样就实现了将触摸事件参数MotionEvent从Activity中传入到DecorView的子ViewGroup中了。我们会在后面探讨ViewGroup中的dispatchTouchEvent方法中的执行逻辑，此处就不再过多介绍了。</p>
<p>以上介绍了借助superDispatchTouchEvent和dispatchTouchEvent方法将触摸事件从Activity到ViewGroup中的传递过程，这两个方法均返回一个boolean类型的参数，如果返回true，表示触摸事件被处理了，反之表示触摸事件没有被处理。我们再看一下上面Activity中dispatchTouchEvent的源码，就会发现如果PhoneWindow的superDispatchTouchEvent返回了true，那么Activity的dispatchTouchEvent方法也就直接返回了true，表明触摸事件被Window给处理了，所以就不会执行后面Activity的 onTouchEvent方法。只有Window没处理触摸事件的情况下，Activity才会调用onTouchEvent方法去处理事件。</p>
<h3 id="onTouchEvent"><a href="#onTouchEvent" class="headerlink" title="onTouchEvent"></a>onTouchEvent</h3><p>onTouchEvent的源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    if (mWindow.shouldCloseOnTouch(this, event)) &#123;</span><br><span class="line">        finish();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只有当触摸事件没有被任何的View或ViewGroup处理过的时候，Activity才会执行自己的onTouchEvent去处理触摸事件。一种典型的情形就是，当前触摸点在Window范围之外，这样Window里面所有的View都不会接收更不会处理该触摸事件，这时候我们可以重写该方法实现一些自己的逻辑处理这种情形。如果我们处理了，就返回true，否则返回false。其默认实现基本一直返回false。</p>
<h2 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><h3 id="dispatchTouchEvent-1"><a href="#dispatchTouchEvent-1" class="headerlink" title="dispatchTouchEvent"></a>dispatchTouchEvent</h3><p>当Activity接收到触摸事件之后，会通过DectorView调用ViewGroup的dispatchTouchEvent方法，由于该方法的源码太长，此处就不贴源码了，点此查看其源码。此处主要说一下该方法中的主要逻辑。dispatchTouchEvent方法是ViewGroup对触摸事件进行处理的入口。</p>
<p>ViewGroup中定义了一个TouchTarget类型的成员变量mFirstTouchTarget，用于保存当前ViewGroup中处理了触摸事件的子View。</p>
<p>首先，dispatchTouchEvent方法会调用其自身的onInterceptTouchEvent方法，onInterceptTouchEvent是用来拦截ViewGroup将触摸事件传递给其子View的，如果该方法返回true，就表示ViewGroup应该拦截触摸事件；如果返回false，表示ViewGroup不应该拦截触摸事件，应该将触摸事件传递给子View。在dispathTouchEvent方法中还定义了一个boolean类型的handled变量，用于保存dispathTouchEvent方法的返回值，如果是true就表示触摸事件被当前的ViewGroup处理了，反之则表示没被处理。</p>
<p>然后，只有当onInterceptTouchEvent返回了false，ViewGroup才会依次遍历其子View，其会通过调用isTransformedTouchPointInView方法判断MotionEvent所携带的触摸事件的坐标是否落在子View的范围内，如果触摸事件的坐标恰好落在了该子View范围内，说明我们触摸了当前ViewGroup内的该子View，这样ViewGroup就会把触摸事件的坐标以及该子View传递给dispatchTransformedTouchEvent方法，在该方法内会调用子View的dispatchTouchEvent方法，其返回值表示自View是否处理了触摸事件，如果dispatchTransformedTouchEvent返回true，表示子View处理了触摸事件，这样ViewGroup会通过调用addTouchTarget方法将mFirstTouchTarget绑定该子View，并且变量alreadyDispatchedToNewTouchTarget也会设置为true，表示已经有子View处理了触摸事件。一旦有子View处理了触摸事件，ViewGroup就会通过break跳出for循环，不再对其他子View进行遍历。</p>
<p>在经过了对子View的for循环之后，如果没有任何的子View处理了触摸事件，那么mFirstTouchTarget就还是null，此时ViewGroup就会将null作为child参数传入dispatchTransformedTouchEvent方法中，该方法会调用super.dispatchTouchEvent方法，由于ViewGroup继承自View，以此处就相当于执行了View类中的dispatchTouchEvent方法，这样就很有可能执行ViewGroup从View中继承来的onTouchEvent方法。dispatchTransformedTouchEvent的返回值会作为局部变量handled的值。关于View类中的dispatchTouchEvent方法会在下面详细说明。</p>
<p>在经过了对子View的for循环之后，如果发现某个子View对触摸事件进行了处理，那么alreadyDispatchedToNewTouchTarget就是true，从而会将局部变量handled设置为true，即表示只要有子View处理了触摸事件，就表示当前的ViewGroup也处理了触摸事件，并且这种情况下ViewGroup不会调用从View中继承来的dispatchTouchEvent方法，从而不会触发ViewGroup的onTouchEvent方法的执行。</p>
<h3 id="onInterceptTouchEvent"><a href="#onInterceptTouchEvent" class="headerlink" title="onInterceptTouchEvent"></a>onInterceptTouchEvent</h3><p>之前提到过onInterceptTouchEvent用于拦截ViewGroup向子View传递触摸事件，ViewGroup中的默认实现一直返回false，即表示不拦截。我们可以重写该方法以实现我们自己的触摸事件拦截逻辑。</p>
<p>dispatchTransformedTouchEvent<br>点此查看源码，其主要的逻辑代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,</span><br><span class="line">        View child, int desiredPointerIdBits) &#123;</span><br><span class="line"></span><br><span class="line">  final boolean handled;</span><br><span class="line"></span><br><span class="line">  final MotionEvent transformedEvent;</span><br><span class="line"></span><br><span class="line">  ......        </span><br><span class="line"></span><br><span class="line">    // Perform any necessary transformations and dispatch.</span><br><span class="line">    if (child == null) &#123;</span><br><span class="line">        handled = super.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final float offsetX = mScrollX - child.mLeft;</span><br><span class="line">        final float offsetY = mScrollY - child.mTop;</span><br><span class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">        if (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">            transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Done.</span><br><span class="line">    transformedEvent.recycle();</span><br><span class="line">    return handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法的主要目的是将MotionEvent中的x、y的坐标转换成所传入的child变量所指定的的View的坐标系中的坐标，transformedEvent表示了已经完成了指定坐标系转换的MotionEvent。如果传入的child参数是null，表示传入的是当前的ViewGroup，此时就将直接调用super.dispatchTouchEvent(transformedEvent)，这样就让ViewGroup调用了父类View中的dispatchTouchEvent方法；如果传入的child参数不是null，表示传入的当前ViewGroup的一个子View，那么就会调用child.dispatchTouchEvent(transformedEvent)，从而将触摸事件从ViewGroup传递到子View中去。我们会在下面介绍View的dispatchTouchEvent的实现逻辑。</p>
<h3 id="onTouchEvent-1"><a href="#onTouchEvent-1" class="headerlink" title="onTouchEvent"></a>onTouchEvent</h3><p>ViewGroup的onTouchEvent继承自View的onTouchEvent方法，ViewGroup并没有重写，我们在下面会介绍View的onTouchEvent方法的实现逻辑。</p>
<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><h2 id="dispatchTouchEvent-2"><a href="#dispatchTouchEvent-2" class="headerlink" title="dispatchTouchEvent"></a>dispatchTouchEvent</h2><p>点此查看源码，其源码的主要逻辑如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    boolean result = false;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    if (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        //noinspection SimplifiableIfStatement</span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        //如果设置了OnTouchListener，那么会在此处执行OnTouchListener的onTouch方法</span><br><span class="line">        if (li != null &amp;&amp; li.mOnTouchListener != null</span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</span><br><span class="line">            //如果OnTouchListener的onTouch方法返回true，就表示触摸事件被处理了，result就会设置为true</span><br><span class="line">            result = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果触摸事件没有被OnTouchListener处理，那么就会执行View的onTouchEvent方法</span><br><span class="line">        if (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            //如果onTouchEvent返回了true，就表示触摸事件被View处理了，result就被设置为了true</span><br><span class="line">            result = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>dispatchTouchEvent是View处理触摸事件的入口。在该方法中，View首先会查看其有没有设置过OnTouchListener，如果设置过就调用OnTouchListener的onTouch方法，如果其返回了true，就表明触摸事件被处理了，result就会设置为true。如果触摸事件没有被OnTouchListener处理，那么就会执行View的onTouchEvent方法，如果onTouchEvent返回了true，就表示触摸事件被View处理了，result就被设置为了true。</p>
<p>由上可以看出，在dispatchTouchEvent方法中是先执行OnTouchListener的onTouch方法，一旦其返回true，就不会调用View自身的onTouchEvent方法了，只有OnTouchListener没有处理触摸事件才会在后面执行View的onTouchEvent方法。</p>
<h3 id="onTouchEvent-2"><a href="#onTouchEvent-2" class="headerlink" title="onTouchEvent"></a>onTouchEvent</h3><p>点此查看源码，View.onTouchEvent()方法中，如果View注册了CLICK或LONG_CLICK等事件监听器，那么就会让注册的事件监听器处理触摸事件，这样onTouchEvent就返回true。会根据ACTION的不同，执行不同的处理，比如如果是ACTION_UP，会执行performClick()方法，该方法会触发OnClickListener.onClick()的执行。<br>如果View没有注册任何的CLICK或LONG_CLICK等的事件监听器，那么onTouchEvent就返回false，表示onTouchEvent没有对传入的触摸事件MotionEvent做任何处理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们通过对上面Activity、ViewGroup、View各个层级对触摸事件的处理过程可以发现，Android中每个层级对触摸事件的处理都是从dispatchTouchEvent方法开始的，首先先调用下一层级的dispatchTouchEvent方法，将触摸事件传递给下一层级，如果下一层级对触摸事件进行了处理，就可认为本层级也对触摸事件进行了处理，那么本层级就不会对触摸事件仅需做其他特殊处理了；如果下一层级没有对触摸事件进行处理，即下一层级的dispatchTouchEvent方法返回false，那么才会调用本层级的onTouchEvent方法对触摸事件进行处理。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2016/12/25/Android中的MotionEvent/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content>
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/25/Android中的MotionEvent/" itemprop="url">
                  Android中的MotionEvent
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-25T17:22:03+08:00">
                2016-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>运动事件描述了动作的动作代码和一些列的坐标值。动作代码表明了当触点按下或者弹起等引起的状态变化。坐标值描述了位置信息以及以他的运动属性。</strong></p>
<p><strong>例如，当用户第一次触摸屏幕的时候，系统给窗体发出一个触摸事件，动作代码为ACTION_DOWN，并提供了一些列的坐标值，比如触摸的X、Y坐标，接触区域的压力、尺寸、方向等信息。<br>一些设备能够在同一时间报告多条运动轨迹。多点触控屏幕为每个手指都发出一条运动轨迹。手指或者其他能够产生运动轨迹的物体都可以叫做触点。运动事件包含所有触点的信息，即使有些触点自从上次事件之后就没有再移动，这些触点必须是当前处于活动状态的。</strong></p>
<p><strong>只有触点按下或者抬起的时候才会影响触点的数量，只有动作取消的时候除外。</strong></p>
<p><strong>每个触点都有一个唯一的id，这个id是在触点第一次按下的时候(动作代码为ACTION_DOWN或者ACTION_POINTER_DOWN)由系统自动分配的。触点的id会一直保持有效，当触点抬起的时候(动作代码为ACTION_UP或者ACTION_POINTER_UP)或者动作取消(动作代码为ACTION_CANCEL)的时候会导致触点的id失效。</strong></p>
<p><strong>MotionEvent类提供了许多可以查看触点的位置或者其他信息的方式，比如getX(int)、getY(int)、getAxisValue(int)、getPointerId(int)、getToolType(int)。这其中的大部分方法都将触点的索引值作为参数而不是触点的id。在事件中，每个触点的索引号的取值范围是从0到getPointerCount()-1。<br>在一次运动中触点出现的顺序是不确定的。因此，触点的索引值会由于事件的变化而变化，但是只要触点处于活动状态，该触点的id就不会改变。用getPointerId(int)方法可以得到触点的id值，从而根据得到的id值在一连串的动作中来追踪其运动轨迹。然而在连续的运动事件中，应该用findPointerIndex(int)方法通过触点的id值得到触点的索引值。</strong></p>
<p><strong>为了提高效率，代码为ACTION_MOVE的运动事件可能会将多个运动路径处理成一个。最常用的当前触点的坐标可以通过getX(int)和getY(int)获得。之前的坐标可以通过getHistoricalX(int,int)和getHistoricalY(int,int)获得。这些坐标之所以被成为”历史坐标”是因为这些坐标比当前坐标更早的出现了。要想按照时间顺序处理所有坐标，首先要处理历史坐标，然后再是当前坐标。</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2016/12/18/源码解析Android中View的layout布局过程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content>
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/18/源码解析Android中View的layout布局过程/" itemprop="url">
                  源码解析Android中View的layout布局过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-18T18:20:20+08:00">
                2016-12-18
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android中的Veiw从内存中到呈现在UI界面上需要依次经历三个阶段：量算 -&gt; 布局 -&gt; 绘图，关于View的量算、布局、绘图的总体机制可参见博文 <a href="http://fastabler.online/2016/12/11/Android中View的量算、布局以及绘图机制/" target="_blank" rel="noopener">《 Android中View的布局及绘图机制》</a>。量算是布局的基础，如果想了解量算的细节，可参见博文<a href="http://fastabler.online/2016/12/17/源码解析Android中View的Measure量算过程/" target="_blank" rel="noopener">《源码解析Android中View的measure量算过程》</a>。本文将从源码角度解析View的布局layout过程，本文会详细介绍View布局过程中的关键方法，并对源码加上了注释以进行说明。</p>
<p>对View进行布局的目的是计算出View的尺寸以及在其父控件中的位置，具体来说就是计算出View的四条边界分别到其父控件左边界、上边界的距离，即计算View的left、top、right、bottom的值。</p>
<p>##layout</p>
<p>layout()方法是View布局的入口，其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public void layout(int l, int t, int r, int b) &#123;</span><br><span class="line">        //成员变量mPrivateFlags3中的一些比特位存储着和layout相关的信息</span><br><span class="line">        if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123;</span><br><span class="line">            //如果在mPrivateFlags3的低位字节的第4位（从最右向左数第4位）的值为1，</span><br><span class="line">            //那么就表示在layout布局前需要先对View进行量算，</span><br><span class="line">            //这种情况下就会执行View的onMeasure方法对View进行量算</span><br><span class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">            //量算完成后就会将mPrivateFlags3低位字节的第4位重置为0，</span><br><span class="line">            //移除掉标签PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int oldL = mLeft;</span><br><span class="line">        int oldT = mTop;</span><br><span class="line">        int oldB = mBottom;</span><br><span class="line">        int oldR = mRight;</span><br><span class="line"></span><br><span class="line">        //如果isLayoutModeOptical()返回true，那么就会执行setOpticalFrame()方法，</span><br><span class="line">        //否则会执行setFrame()方法。并且setOpticalFrame()内部会调用setFrame()，</span><br><span class="line">        //所以无论如何都会执行setFrame()方法。</span><br><span class="line">        //setFrame()方法会将View新的left、top、right、bottom存储到View的成员变量中</span><br><span class="line">        //并且返回一个boolean值，如果返回true表示View的位置或尺寸发生了变化，</span><br><span class="line">        //否则表示未发生变化</span><br><span class="line">        boolean changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">            //如果View的布局发生了变化，或者mPrivateFlags有需要LAYOUT的标签PFLAG_LAYOUT_REQUIRED，</span><br><span class="line">            //那么就会执行以下代码</span><br><span class="line">            //首先会触发onLayout方法的执行，View中默认的onLayout方法是个空方法</span><br><span class="line">            //不过继承自ViewGroup的类都需要实现onLayout方法，从而在onLayout方法中依次循环子View，</span><br><span class="line">            //并调用子View的layout方法</span><br><span class="line">            onLayout(changed, l, t, r, b);</span><br><span class="line">            //在执行完onLayout方法之后，从mPrivateFlags中移除标签PFLAG_LAYOUT_REQUIRED</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">            //我们可以通过View的addOnLayoutChangeListener(View.OnLayoutChangeListener listener)方法</span><br><span class="line">            //向View中添加多个Layout发生变化的事件监听器</span><br><span class="line">            //这些事件监听器都存储在mListenerInfo.mOnLayoutChangeListeners这个ArrayList中</span><br><span class="line">            ListenerInfo li = mListenerInfo;</span><br><span class="line">            if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123;</span><br><span class="line">                //首先对mOnLayoutChangeListeners中的事件监听器进行拷贝</span><br><span class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">                int numListeners = listenersCopy.size();</span><br><span class="line">                for (int i = 0; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                    //遍历注册的事件监听器，依次调用其onLayoutChange方法，这样Layout事件监听器就得到了响应</span><br><span class="line">                    listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //从mPrivateFlags中移除强制Layout的标签PFLAG_FORCE_LAYOUT</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">        //向mPrivateFlags3中加入Layout完成的标签PFLAG3_IS_LAID_OUT</span><br><span class="line">        mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在layout()方法内部刚开始执行的时候，首先会根据mPrivateFlags3变量是否具有标志位PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT判断是否需要执行View的onMeasure()方法。如果具有标志位PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT，则执行onMeasure()方法，从而对View进行量算，量算的结果会保存到View的成员变量中。量算完成后就会将mPrivateFlags3低位字节的第4位重置为0，移除掉标签PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT。</p>
<p>如果isLayoutModeOptical()返回true，那么就会执行setOpticalFrame()方法，否则会执行setFrame()方法。并且setOpticalFrame()内部会调用setFrame()，所以无论如何都会执行setFrame()方法。setFrame()方法会将View新的left、top、right、bottom存储到View的成员变量中，并且返回一个boolean值，如果返回true表示View的位置或尺寸发生了变化，否则表示未发生变化。后面会对setFrame()方法详细介绍。</p>
<p>如果View的布局发生了变化，或者mPrivateFlags有需要LAYOUT的标签PFLAG_LAYOUT_REQUIRED，就会触发onLayout方法的执行，View中默认的onLayout方法是个空方法。不过继承自ViewGroup的类都需要实现onLayout方法，从而在onLayout方法中依次循环子View，并调用子View的layout方法。在执行完onLayout方法之后，从mPrivateFlags中移除标签PFLAG_LAYOUT_REQUIRED。然后会遍历注册的Layout Change事件监听器，依次调用其onLayoutChange方法，这样Layout事件监听器就得到了响应。</p>
<p>最后，从mPrivateFlags中移除强制Layout的标签PFLAG_FORCE_LAYOUT，向mPrivateFlags3中加入Layout完成的标签PFLAG3_IS_LAID_OUT。</p>
<p>##setFrame</p>
<p>setFrame()方法是具体用来完成给View分配尺寸以及位置工作的，在layout()方法中会调用setFrame()方法。其源码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">protected boolean setFrame(int left, int top, int right, int bottom) &#123;</span><br><span class="line">    boolean changed = false;</span><br><span class="line"></span><br><span class="line">    if (DBG) &#123;</span><br><span class="line">        Log.d(&quot;View&quot;, this + &quot; View.setFrame(&quot; + left + &quot;,&quot; + top + &quot;,&quot;</span><br><span class="line">                + right + &quot;,&quot; + bottom + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</span><br><span class="line">        //将新旧left、right、top、bottom进行对比，只要不完全相对就说明View的布局发生了变化，</span><br><span class="line">        //则将changed变量设置为true</span><br><span class="line">        changed = true;</span><br><span class="line"></span><br><span class="line">        //先保存一下mPrivateFlags中的PFLAG_DRAWN标签信息</span><br><span class="line">        int drawn = mPrivateFlags &amp; PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        //分别计算View的新旧尺寸</span><br><span class="line">        int oldWidth = mRight - mLeft;</span><br><span class="line">        int oldHeight = mBottom - mTop;</span><br><span class="line">        int newWidth = right - left;</span><br><span class="line">        int newHeight = bottom - top;</span><br><span class="line">        //比较View的新旧尺寸是否相同，如果尺寸发生了变化，那么sizeChanged的值为true</span><br><span class="line">        boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);</span><br><span class="line"></span><br><span class="line">        // Invalidate our old position</span><br><span class="line">        invalidate(sizeChanged);</span><br><span class="line"></span><br><span class="line">        //将新的left、top、right、bottom存储到View的成员变量中</span><br><span class="line">        mLeft = left;</span><br><span class="line">        mTop = top;</span><br><span class="line">        mRight = right;</span><br><span class="line">        mBottom = bottom;</span><br><span class="line">        //mRenderNode.setLeftTopRightBottom()方法会调用RenderNode中原生方法的nSetLeftTopRightBottom()方法，</span><br><span class="line">        //该方法会根据left、top、right、bottom更新用于渲染的显示列表</span><br><span class="line">        mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);</span><br><span class="line"></span><br><span class="line">        //向mPrivateFlags中增加标签PFLAG_HAS_BOUNDS，表示当前View具有了明确的边界范围</span><br><span class="line">        mPrivateFlags |= PFLAG_HAS_BOUNDS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (sizeChanged) &#123;</span><br><span class="line">            //如果View的尺寸和之前相比发生了变化，那么就执行sizeChange()方法，</span><br><span class="line">            //该方法中又会调用onSizeChanged()方法，并将View的新旧尺寸传递进去</span><br><span class="line">            sizeChange(newWidth, newHeight, oldWidth, oldHeight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || mGhostView != null) &#123;</span><br><span class="line">            //有可能在调用setFrame方法之前，invalidate方法就被调用了，</span><br><span class="line">            //这会导致mPrivateFlags移除了PFLAG_DRAWN标签。</span><br><span class="line">            //如果当前View处于可见状态就将mPrivateFlags强制添加PFLAG_DRAWN状态位，</span><br><span class="line">            //这样会确保下面的invalidate()方法会执行到其父控件级别。</span><br><span class="line">            mPrivateFlags |= PFLAG_DRAWN;</span><br><span class="line">            invalidate(sizeChanged);</span><br><span class="line">            //invalidateParentCaches()方法会移除其父控件的PFLAG_INVALIDATED标签，</span><br><span class="line">            //这样其父控件就会重建用于渲染的显示列表</span><br><span class="line">            invalidateParentCaches();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 重新恢复mPrivateFlags中原有的PFLAG_DRAWN标签信息</span><br><span class="line">        mPrivateFlags |= drawn;</span><br><span class="line"></span><br><span class="line">        mBackgroundSizeChanged = true;</span><br><span class="line">        if (mForegroundInfo != null) &#123;</span><br><span class="line">            mForegroundInfo.mBoundsChanged = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        notifySubtreeAccessibilityStateChangedIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">    return changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该方法中，会将新旧left、right、top、bottom进行对比，只要不完全相同就说明View的布局发生了变化，则将changed变量设置为true。然后比较View的新旧尺寸是否相同，如果尺寸发生了变化，并将其保存到变量sizeChanged中。如果尺寸发生了变化，那么sizeChanged的值为true。</p>
<p>然后将新的left、top、right、bottom存储到View的成员变量中保存下来。并执行mRenderNode.setLeftTopRightBottom()方法会，其会调用RenderNode中原生方法的nSetLeftTopRightBottom()方法，该方法会根据left、top、right、bottom更新用于渲染的显示列表。</p>
<p>如果View的尺寸和之前相比发生了变化，那么就执行sizeChange()方法，该方法中又会调用onSizeChanged()方法，并将View的新旧尺寸传递进去。</p>
<p>如果View处于可见状态，那么会调用invalidate和invalidateParentCaches方法。invalidateParentCaches()方法会移除其父控件的PFLAG_INVALIDATED标签，这样其父控件就会重建用于渲染的显示列表。</p>
<p>##sizeChange</p>
<p>sizeChange方法会在View的尺寸发生变化时调用，在setFrame()方法中就可能会调用sizeChange()方法。当然，在View的setLeft()、setTop()、setRight()、setBottom()等其他改变View尺寸的方法中也会调用sizeChange()方法，其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void sizeChange(int newWidth, int newHeight, int oldWidth, int oldHeight) &#123;</span><br><span class="line">    //将View的新旧尺寸传递给onSizeChanged()方法</span><br><span class="line">    onSizeChanged(newWidth, newHeight, oldWidth, oldHeight);</span><br><span class="line">    if (mOverlay != null) &#123;</span><br><span class="line">        mOverlay.getOverlayView().setRight(newWidth);</span><br><span class="line">        mOverlay.getOverlayView().setBottom(newHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    rebuildOutline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在该方法中其主要将View的新旧尺寸传递给onSizeChanged()方法使其执行。</p>
<p>##onSizeChanged</p>
<p>onSizeChanged()方法是个空方法，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法会在View的尺寸发生变化时，通过sizeChange()方法的执行而被调用。当View第一次加入到View树中时，该方法也会被调用，只不过传入的旧尺寸oldWidth和oldHeight都是0。</p>
<p>##总结</p>
<p>layout方法总的调用过程主线如下所示：</p>
<p>layout() -&gt; onMeasure() -&gt; setFrame() -&gt; sizeChange() -&gt; onSizeChanged() -&gt; onLayout() -&gt;遍历执行OnLayoutChangeListener.onLayoutChange()</p>
<p>希望本文对大家理解View的layout布局过程有所帮助！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2016/12/17/源码解析Android中View的Measure量算过程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content>
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/17/源码解析Android中View的Measure量算过程/" itemprop="url">
                  源码解析Android中View的Measure量算过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-17T17:04:06+08:00">
                2016-12-17
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android中的Veiw从内存中到呈现在UI界面上需要依次经历三个阶段：量算 -&gt; 布局 -&gt; 绘图，关于View的量算、布局、绘图的总体机制可参见博文<a href="http://fastabler.online/2016/12/11/Android中View的量算、布局以及绘图机制/" target="_blank" rel="noopener">《 Android中View的布局及绘图机制》</a>。如果想了解layout布局的细节，可参见博文<a href="http://fastabler.online/2016/12/18/源码解析Android中View的layout布局过程/" target="_blank" rel="noopener">《源码解析Android中View的layout布局过程》</a>。量算是布局和绘图的基础，所以量算是很重要的一个环节。本文将从源码角度解析View的量算过程，这其中会涉及某些关键类以及关键方法。</p>
<p>对View进行量算的目的是让View的父控件知道View想要多大的尺寸。</p>
<p>##量算过程概述</p>
<p>如果要进行量算的View是ViewGroup类型，那么ViewGroup会在onMeasure方法内会遍历子View依次进行量算，本文重点说明非ViewGroup的View的量算过程，因为我们一旦了解了非ViewGroup的View的量算过程，ViewGroup的量算理解起来就要简单许多，主要是ViewGroup在其内部对子View再依次执行量算。</p>
<p>整个应用量算的起点是ViewRootImpl类，从它开始依次对子View进行量算，如果子View是一个ViewGroup，那么又会遍历该ViewGroup的子View依次进行量算。也就是说，量算会从View树的根结点，纵向递归进行，从而实现自上而下对View树进行量算，直至完成对叶子节点View的量算。</p>
<p>那么到底如何对一个View进行量算呢？Android通过调用View的measure()方法对View进行量算，让该View的父控件知道该View想要多大的尺寸空间。</p>
<p>具体来说，View的父控件ViewGroup会调用View的measure方法，ViewGroup会将一些宽度和高度的限制条件传递给View的measure方法。</p>
<p>在View的measure方法会首先从成员变量中读取以前缓存过的量算结果，如果能找到该缓存值，那么就基本完事了，如果没有找到缓存值，那么measure方法会执行onMeasure回调方法，measure方法会将上述的宽度和高度的限制条件依次传递给onMeasure方法。onMeasure方法会完成具体的量算工作，并将量算的结果通过调用View的setMeasuredDimension方法保存到View的成员变量mMeasuredWidth 和mMeasuredHeight中。</p>
<p>量算完成之后，View的父控件就可以通过调用getMeasuredWidth、getMeasuredState、getMeasuredWidthAndState这三个方法获取View的量算结果。</p>
<p>以上就是非ViewGroup类型的View量算的总体过程。</p>
<p>##MeasureSpec简介</p>
<p>上面我们提到ViewGroup在调用View的measure方法时，会传入ViewGroup对View的宽度及高度的限制条件，这是合理的，例如ViewGroup的空间有限，它需要告诉子View要量算的尺寸的上限。</p>
<p>上面提到的尺寸的限制条件就是MeasureSpec，它可以通过一个Int类型的值来表示的，该Int值会同时包含两种信息：mode和size，即模式和尺寸。我们知道Java中Int类型的值是4个字节的，Android会用第一个高位字节存储mode，然后用剩余的三个字节存储size。</p>
<p>View有一个静态内部类MeasureSpec，该类有几个静态方法以及静态常量，我们可以用这些方法将mode和size打包成一个Int值或者是从一个Int值中解析出mode和size。</p>
<p>假设我们已有了一个包含MeasureSpec信息的Int值measureSpec，那么</p>
<p>通过调用MeasureSpec.getSize(int measureSpec)即可从measureSpec解析出三个字节所包含的尺寸size信息，该方法返回Int类型，也就是说我们得到的size实际上就是对原有的measureSpec的高位字节的8个二进制位都设置为0，该方法的返回值size虽然也是4个字节的Int值，但是已经完全不包含mode信息。</p>
<p>通过调用MeasureSpec.getMode(int measureSpec)即可从measureSpec解析出高位字节所包含的模式mode信息，该方法返回Int类型，也就是说我们得到的mode实际上对原有的measureSpec的低位的三个字节的24个二进制码都设置为0，该方法的返回值mode虽然也是4个字节的Int值，但是已经完全不包含size信息。</p>
<p>对于尺寸size，我们很好理解，比如表示某个宽度值或者表示某个高度值。那么mode是什么呢？</p>
<p>mode的取值有三种，分别是：</p>
<p>MeasureSpec.AT_MOST，即0x80000000，该值表示View最大可以取其父ViewGroup给其指定的尺寸，例如现在有个Int值widthMeasureSpec，ViewGroup将其传递给了View的measure方法，如果widthMeasureSpec中的mode值是AT_MOST，size是200，那么表示View能取的最大的宽度是200。</p>
<p>MeasureSpec.EXACTLY，即0x40000000，该值表示View必须使用其父ViewGroup指定的尺寸，还是以widthMeasureSpec为例，如果其mode值是EXACTLY，size是200，那么表示View的宽度必须是200，不多不少才行。</p>
<p>MeasureSpec.UNSPECIFIED，即0x00000000，该值表示View的父ViewGroup没有给View在尺寸上设置限制条件，这种情况下View可以忽略measureSpec中的size，View可以取自己想要的值作为量算的尺寸。</p>
<p>更多信息可参考API文档 android/view/View.MeasureSpec。</p>
<p>##measure方法</p>
<p>measure()的方法签名是public final void measure(int widthMeasureSpec, int heightMeasureSpec)。</p>
<p>当View的父控件ViewGroup对View进行量算时，会调用View的measure方法，ViewGroup会传入widthMeasureSpec和heightMeasureSpec，分别表示父控件对View的宽度和高度的一些限制条件。</p>
<p>measure方法的源码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    //首先判断当前View的layoutMode是不是特例LAYOUT_MODE_OPTICAL_BOUNDS</span><br><span class="line">    boolean optical = isLayoutModeOptical(this);</span><br><span class="line">    if (optical != isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">        //LAYOUT_MODE_OPTICAL_BOUNDS是特例情况，比较少见</span><br><span class="line">        Insets insets = getOpticalInsets();</span><br><span class="line">        int oWidth  = insets.left + insets.right;</span><br><span class="line">        int oHeight = insets.top  + insets.bottom;</span><br><span class="line">        widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);</span><br><span class="line">        heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//根据widthMeasureSpec和heightMeasureSpec计算key值，我们在下面用key值作为键，缓存我们量算的结果</span><br><span class="line">    long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL;</span><br><span class="line">    //mMeasureCache是LongSparseLongArray类型的成员变量，</span><br><span class="line">    //其缓存着View在不同widthMeasureSpec、heightMeasureSpec下量算过的结果</span><br><span class="line">    //如果mMeasureCache为空，我们就新new一个对象赋值给mMeasureCache</span><br><span class="line">    if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2);</span><br><span class="line">    //mOldWidthMeasureSpec和mOldHeightMeasureSpec分别表示上次对View进行量算时的widthMeasureSpec和heightMeasureSpec</span><br><span class="line">    //执行View的measure方法时，View总是先检查一下是不是真的有必要费很大力气去做真正的量算工作</span><br><span class="line">    //mPrivateFlags是一个Int类型的值，其记录了View的各种状态位</span><br><span class="line">    //如果(mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT，</span><br><span class="line">    //那么表示当前View需要强制进行layout（比如执行了View的forceLayout方法），所以这种情况下要尝试进行量算</span><br><span class="line">    //如果新传入的widthMeasureSpec/heightMeasureSpec与上次量算时的mOldWidthMeasureSpec/mOldHeightMeasureSpec不等，</span><br><span class="line">    //那么也就是说该View的父ViewGroup对该View的尺寸的限制情况有变化，这种情况下要尝试进行量算</span><br><span class="line">    if ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</span><br><span class="line">            widthMeasureSpec != mOldWidthMeasureSpec ||</span><br><span class="line">            heightMeasureSpec != mOldHeightMeasureSpec) &#123;</span><br><span class="line"></span><br><span class="line">        //通过按位操作，重置View的状态mPrivateFlags，将其标记为未量算状态</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line"></span><br><span class="line">        //对阿拉伯语、希伯来语等从右到左书写、布局的语言进行特殊处理</span><br><span class="line">        resolveRtlPropertiesIfNeeded();</span><br><span class="line"></span><br><span class="line">        //在View真正进行量算之前，View还想进一步确认能不能从已有的缓存mMeasureCache中读取缓存过的量算结果</span><br><span class="line">        //如果是强制layout导致的量算，那么将cacheIndex设置为-1，即不从缓存中读取量算结果</span><br><span class="line">        //如果不是强制layout导致的量算，那么我们就用上面根据measureSpec计算出来的key值作为缓存索引cacheIndex。</span><br><span class="line">        int cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -1 :</span><br><span class="line">                mMeasureCache.indexOfKey(key);</span><br><span class="line"></span><br><span class="line">        //sIgnoreMeasureCache是一个boolean类型的成员变量，其值是在View的构造函数中计算的，而且只计算一次</span><br><span class="line">        //一些老的App希望在一次layou过程中，onMeasure方法总是被调用，</span><br><span class="line">        //具体来说其值是通过如下计算的: sIgnoreMeasureCache = targetSdkVersion &lt; KITKAT;</span><br><span class="line">        //也就是说如果targetSdkVersion的API版本低于KITKAT，即API level小于19，那么sIgnoreMeasureCache为true</span><br><span class="line"></span><br><span class="line">        if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123;</span><br><span class="line">            //如果运行到此处，表示我们没有从缓存中找到量算过的尺寸或者是sIgnoreMeasureCache为true导致我们要忽略缓存结果</span><br><span class="line">            //此处调用onMeasure方法，并把尺寸限制条件widthMeasureSpec和heightMeasureSpec传入进去</span><br><span class="line">            //onMeasure方法中将会进行实际的量算工作，并把量算的结果保存到成员变量中</span><br><span class="line">            onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">            //onMeasure执行完后，通过位操作，重置View的状态mPrivateFlags，将其标记为在layout之前不必再进行量算的状态</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果运行到此处，那么表示当前的条件允许View从缓存成员变量mMeasureCache中读取量算过的结果</span><br><span class="line">            //用上面得到的cacheIndex从缓存mMeasureCache中取出值，不必在调用onMeasure方法进行量算了</span><br><span class="line">            long value = mMeasureCache.valueAt(cacheIndex);</span><br><span class="line">            //一旦我们从缓存中读到值，我们就可以调用setMeasuredDimensionRaw方法将当前量算的结果到成员变量中</span><br><span class="line">            setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value);</span><br><span class="line">            mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果我们自定义的View重写了onMeasure方法，但是没有调用setMeasuredDimension()方法，</span><br><span class="line">        //那么此处就会抛出异常，提醒开发者在onMeasure方法中调用setMeasuredDimension()方法</span><br><span class="line">        //Android是如何知道我们有没有在onMeasure方法中调用setMeasuredDimension()方法的呢？</span><br><span class="line">        //方法很简单，还是通过解析状态位mPrivateFlags。</span><br><span class="line">        //setMeasuredDimension()方法中会将mPrivateFlags设置为PFLAG_MEASURED_DIMENSION_SET状态，即已量算状态，</span><br><span class="line">        //此处就检查mPrivateFlags是否含有PFLAG_MEASURED_DIMENSION_SET状态即可判断setMeasuredDimension是否被调用</span><br><span class="line">        if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;View with id &quot; + getId() + &quot;: &quot;</span><br><span class="line">                    + getClass().getName() + &quot;#onMeasure() did not set the&quot;</span><br><span class="line">                    + &quot; measured dimension by calling&quot;</span><br><span class="line">                    + &quot; setMeasuredDimension()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //mOldWidthMeasureSpec和mOldHeightMeasureSpec保存着最近一次量算时的MeasureSpec，</span><br><span class="line">    //在量算完成后将这次新传入的MeasureSpec赋值给它们</span><br><span class="line">    mOldWidthMeasureSpec = widthMeasureSpec;</span><br><span class="line">    mOldHeightMeasureSpec = heightMeasureSpec;</span><br><span class="line"></span><br><span class="line">    //最后用上面计算出的key作为键，量算结果作为值，将该键值对放入成员变量mMeasureCache中，</span><br><span class="line">    //这样就实现了对本次量算结果的缓存，以便在下次measure方法执行的时候，有可能将其从中直接读出，</span><br><span class="line">    //从而省去实际量算的步骤</span><br><span class="line">    mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 |</span><br><span class="line">            (long) mMeasuredHeight &amp; 0xffffffffL);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>上面的注释对每行代码都进行了详细的说明，如果大家仔细读了的话，相信能一目了然，这里根据上面的注释简单总结一下measure方法都干了什么事：</p>
<p>首先，我们要知道并不是只要View的measure方法执行的时候View就一定要傻傻的真的去做量算工作，View也喜欢偷懒，如果View发现没有必要去量算的话，那它就不会真的去做量算的工作。</p>
<p>具体来说，View先查看是不是要强制量算以及这次measure中传入的MeasureSpec与上次量算的MeasureSpec是否相同，如果不是强制量算或者MeasureSpec与上次的量算的MeasureSpec相同，那么View就不必真的去量算了。</p>
<p>如果不满足上述条件，View就考虑去做量算工作。但是在量算之前，View还想偷懒，它会以MeasureSpec计算出的key值作为键，去成员变量mMeasureCache中查找是否缓存过对应key的量算结果，如果能找到，那么就简单调用一下setMeasuredDimensionRaw方法，将从缓存中读到的量算结果保存到成员变量mMeasuredWidth和mMeasuredHeight中。</p>
<p>如果不能从mMeasureCache中读到缓存过的量算结果，那么这次View就真的不能再偷懒了，只能乖乖地调用onMeasure方法去完成实际的量算工作，并且将尺寸限制条件widthMeasureSpec和heightMeasureSpec传递给onMeasure方法。关于onMeasure方法，我们会在下面详细介绍。</p>
<p>不论上面代码走了哪个判断的分支，最终View都会得到量算的结果，并且将结果缓存到成员变量mMeasureCache中，以便下次执行measure方法时能够从其中读取缓存值。</p>
<p>需要说明的是，View有一个成员变量mPrivateFlags，用以保存View的各种状态位，在量算开始前，会将其设置为未量算状态，在量算完成后会将其设置为已量算状态。</p>
<p>##onMeasure方法</p>
<p>我们在上面提到，当View在measure方法中发现不得不进行实际的量算工作时，将会调用onMeasure方法，并且将尺寸限制条件widthMeasureSpec和heightMeasureSpec作为参数传递给onMeasure方法。View的onMeasure方法不是空方法，它提供了一个默认的具体实现。<br>onMeasure方法的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    //onMeasure调用了setMeasuredDimension方法，</span><br><span class="line">    //setMeasuredDimension又需要调用getDefaultSize方法，</span><br><span class="line">    //getDefaultSize又需要调用getSuggestedMinimumWidth和getSuggestedMinimumHeight方法</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现onMeasure方法中会调用setMeasuredDimension方法，setMeasuredDimension又需要调用getDefaultSize方法，getDefaultSize又需要调用getSuggestedMinimumWidth和getSuggestedMinimumHeight方法，即<br>setMeasuredDimension -&gt; getDefaultSize -&gt; getSuggestedMinimumWidth/Height</p>
<p>那我们就先研究getSuggestedMinimumWidth/Height，然后再依次研究getDefaultSize和setMeasuredDimension，这样就能把onMeasure方法搞明白了。其实getSuggestedMinimumWidth和getSuggestedMinimumHeight的实现逻辑基本一样，我们此处只研究getSuggestedMinimumWidth方法即可。</p>
<p>getSuggestedMinimumWidth方法</p>
<p>getSuggestedMinimumWidth用于返回View推荐的最小宽度，其代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected int getSuggestedMinimumWidth() &#123;</span><br><span class="line">    //如果没有给View设置背景，那么就返回View本身的最小宽度mMinWidth</span><br><span class="line">    //如果给View设置了背景，那么就取View本身最小宽度mMinWidth和背景的最小宽度的最大值</span><br><span class="line">    return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有给View设置背景，那么就返回View本身的最小宽度mMinWidth</p>
<p>如果给View设置了背景，那么就取View本身最小宽度mMinWidth和背景的最小宽度的最大值</p>
<p>那你可能有疑问，View中保存的最小宽度mMinWidth的值是从哪来的呢？实际上有两种办法给View设置最小宽度。</p>
<p>第一种情况是，mMinWidth是在View的构造函数中被赋值的，View通过读取XML中定义的minWidth的值来设置View的最小宽度mMinWidth，以下代码片段是View构造函数中解析minWidth的部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//遍历到XML中定义的minWith属性</span><br><span class="line">case R.styleable.View_minWidth:</span><br><span class="line">//读取XML中定义的属性值作为mMinWidth，如果XML中未定义，则设置为0</span><br><span class="line">mMinWidth = a.getDimensionPixelSize(attr, 0);</span><br><span class="line">break;</span><br></pre></td></tr></table></figure></p>
<p>第二种情况是调用View的setMinimumWidth方法给View的最小宽度mMinWidth赋值，setMinimumWidth方法的代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setMinimumWidth(int minWidth) &#123;</span><br><span class="line">    mMinWidth = minWidth;</span><br><span class="line">    requestLayout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们就搞明白了getSuggestedMinimumWidth方法是怎么执行的了，getSuggestedMinimumHeight方法与其逻辑完全一致，只不过是把宽度换成了高度，在此就不再赘述了。</p>
<p>getDefaultSize</p>
<p>我们在onMeasure方法中发现，onMeasure会执行以下两行代码：getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec)<br>getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)</p>
<p>我们已经研究了getSuggestedMinimumWidth/Height，知道其会返回View的最小宽度和高度，现在我们开始研究getDefaultSize方法。</p>
<p>Android会将View想要的尺寸以及其父控件对其尺寸限制信息measureSpec传递给getDefaultSize方法，该方法要根据这些综合信息计算最终的量算的尺寸。</p>
<p>其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static int getDefaultSize(int size, int measureSpec) &#123;</span><br><span class="line">    //size表示的是View想要的尺寸信息，比如最小宽度或最小高度</span><br><span class="line">    int result = size;</span><br><span class="line">    //从measureSpec中解析出specMode信息</span><br><span class="line">    int specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    //从measureSpec中解析出specSize信息，不要将specSize与上面的size变量搞混</span><br><span class="line">    int specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    switch (specMode) &#123;</span><br><span class="line">    //如果mode是UNSPECIFIED，表示View的父ViewGroup没有给View在尺寸上设置限制条件</span><br><span class="line">    case MeasureSpec.UNSPECIFIED:</span><br><span class="line">        //此处当mode是UNSPECIFIED时，View就直接用自己想要的尺寸size作为量算的结果</span><br><span class="line">        result = size;</span><br><span class="line">        break;</span><br><span class="line">    //如果mode是UNSPECIFIED，那么表示View最大可以取其父ViewGroup给其指定的尺寸</span><br><span class="line">    //如果mode是EXACTLY，那么表示View必须使用其父ViewGroup指定的尺寸</span><br><span class="line">    case MeasureSpec.AT_MOST:</span><br><span class="line">    case MeasureSpec.EXACTLY:</span><br><span class="line">        //此处mode是UNSPECIFIED或EXACTLY时，View就用其父ViewGroup指定的尺寸作为量算的结果</span><br><span class="line">        result = specSize;      </span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过以上代码，我们就会发现View的父ViewGroup传递给View的限制条件measureSpec的作用在该方法中体现的淋漓尽致。</p>
<p>首先根据measuredSpec解析出对应的specMode和specSize</p>
<p>当mode是UNSPECIFIED时，View就直接用自己想要的尺寸size作为量算的结果</p>
<p>当mode是UNSPECIFIED或EXACTLY时，View就用其父ViewGroup指定的尺寸作为量算的结果</p>
<p>最终，View会根据measuredSpec限制条件，得到最终的量算的尺寸。</p>
<p>这样在onMeasure方法中，<br>当执行getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec)时，我们就得到了最终量算到的宽度值；<br>当执行getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)时，我们就得到了最终量算到的高度值。</p>
<p>##setMeasuredDimension</p>
<p>在前面我们研究onMeasure方法时就已经看到setMeasuredDimension会调用getDefaultSize方法，会将已经量算到的宽度值和高度值作为参数传递给setMeasuredDimension方法，我们研究一下该方法。</p>
<p>其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123;</span><br><span class="line">    boolean optical = isLayoutModeOptical(this);</span><br><span class="line">    if (optical != isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">        //layoutMode是LAYOUT_MODE_OPTICAL_BOUNDS的特殊情况，我们不考虑</span><br><span class="line">        Insets insets = getOpticalInsets();</span><br><span class="line">        int opticalWidth  = insets.left + insets.right;</span><br><span class="line">        int opticalHeight = insets.top  + insets.bottom;</span><br><span class="line"></span><br><span class="line">        measuredWidth  += optical ? opticalWidth  : -opticalWidth;</span><br><span class="line">        measuredHeight += optical ? opticalHeight : -opticalHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    //最终调用setMeasuredDimensionRaw方法，将量算结果传入进去</span><br><span class="line">    setMeasuredDimensionRaw(measuredWidth, measuredHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法会在开始判断layoutMode是不是LAYOUT_MODE_OPTICAL_BOUNDS的特殊情况，这种特例很少见，我们直接忽略掉。</p>
<p>setMeasuredDimension方法最后将量算的结果传递给方法setMeasuredDimensionRaw，我们再研究一下setMeasuredDimensionRaw这方法。</p>
<p>setMeasuredDimensionRaw</p>
<p>setMeasuredDimensionRaw接收两个参数，分别是已经量算完成的宽度和高度。</p>
<p>其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123;</span><br><span class="line">    //将量算完成的宽度measuredWidth保存到View的成员变量mMeasuredWidth中</span><br><span class="line">    mMeasuredWidth = measuredWidth;</span><br><span class="line">    //将量算完成的高度measuredHeight保存到View的成员变量mMeasuredHeight中</span><br><span class="line">    mMeasuredHeight = measuredHeight;</span><br><span class="line">    //最后将View的状态位mPrivateFlags设置为已量算状态</span><br><span class="line">    mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们发现，在该方法中做了三件事：</p>
<p>将量算完成的宽度measuredWidth保存到View的成员变量mMeasuredWidth中</p>
<p>将量算完成的高度measuredHeight保存到View的成员变量mMeasuredHeight中</p>
<p>最后将View的状态位mPrivateFlags设置为已量算状态</p>
<p>量算完成的尺寸的state</p>
<p>至此，View的量算过程就完成了，但是View的父ViewGroup如何读取到View量算的结果呢？</p>
<p>为此，View提供了三组方法，分别是： </p>
<ol>
<li>getMeasuredWidth和getMeasuredHeight方法 </li>
<li>getMeasuredWidthAndState和getMeasuredHeightAndState方法 </li>
<li>getMeasuredState方法</li>
</ol>
<p>有些人可能会纳闷，只要有了第一组方法不就行了吗？后面那两组方法有啥用？</p>
<p>此处我们要再仔细研究一下View中保存量算结果的成员变量mMeasuredWidth和mMeasuredHeight，下面的讨论我们都只讨论宽度，理解了宽度的处理方式，高度也是完全一样的。</p>
<p>mMeasuredWidth是一个Int类型的值，其是由4个字节组成的。</p>
<p>我们先假设mMeasuredWidth只存储了量算完成的宽度信息，而且View的父ViewGroup可以通过相关方法得到该值。但是存在这样一种情况：View在量算时，父ViewGroup给其传递的widthMeasureSpec中的specMode的值是AT_MOST，specSize是100，但是View的最小宽度是200，显然父ViewGroup指定的specSize不能满足View的大小，但是由于specMode的值是AT_MOST，View在getDefaultSize方法中不得不妥协，只能含泪将量算的最终宽度设置为100。然后其父ViewGroup通过某些方法获取到该View的量算宽度为100时，ViewGroup以为子View只需要100就够了，最终给了子View宽度为100的空间，这就导致了在UI界面上View特别窄，用户体验也就不好。</p>
<p>Android为让其View的父控件获取更多的信息，就在mMeasuredWidth上下了很大功夫，虽然是一个Int值，但是想让它存储更多信息，具体来说就是把mMeasuredWidth分成两部分：</p>
<p>其高位的第一个字节为第一部分，用于标记量算完的尺寸是不是达到了View想要的宽度，我们称该信息为量算的state信息。<br>其低位的三个字节为第二部分，用于存储实际的量算到的宽度。<br>由此我们可以看出Android真是物尽其用，一个变量能包含两个信息，这个有点类似于measureSpec的道理，但是二者又有不同：</p>
<p>measureSpec是将限制条件mode从ViewGroup传递给其子View。<br>mMeasuredWidth、mMeasuredHeight是将带有量算结果的state标志位信息从View传递给其父ViewGroup。<br>那么你可能会问，在本文中我们没看到对mMeasuredWidth的高位字节进行特殊处理啊？我们下面看一下View中的resolveSizeAndState方法。</p>
<p>resolveSizeAndState</p>
<p>resolveSizeAndState方法与getDefaultSize方法类似，其内部实现的逻辑是一样的，但是又有区别，getDefaultSize仅仅返回最终量算的尺寸信息，但resolveSizeAndState除了返回最终尺寸信息还会有可能返回量算的state标志位信息。</p>
<p>resolveSizeAndState方法的源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) &#123;</span><br><span class="line">    final int specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    final int specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line">    final int result;</span><br><span class="line">    switch (specMode) &#123;</span><br><span class="line">        case MeasureSpec.AT_MOST:</span><br><span class="line">            if (specSize &lt; size) &#123;</span><br><span class="line">                //当specMode为AT_MOST，并且父控件指定的尺寸specSize小于View自己想要的尺寸时，</span><br><span class="line">                //我们就会用掩码MEASURED_STATE_TOO_SMALL向量算结果加入尺寸太小的标记</span><br><span class="line">                //这样其父ViewGroup就可以通过该标记其给子View的尺寸太小了，</span><br><span class="line">                //然后可能分配更大一点的尺寸给子View</span><br><span class="line">                result = specSize | MEASURED_STATE_TOO_SMALL;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result = size;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case MeasureSpec.EXACTLY:</span><br><span class="line">            result = specSize;</span><br><span class="line">            break;</span><br><span class="line">        case MeasureSpec.UNSPECIFIED:</span><br><span class="line">        default:</span><br><span class="line">            result = size;</span><br><span class="line">    &#125;</span><br><span class="line">    return result | (childMeasuredState &amp; MEASURED_STATE_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当specMode为AT_MOST，并且父控件指定的尺寸specSize小于View自己想要的尺寸时，我们就会用掩码MEASURED_STATE_TOO_SMALL向量算结果加入尺寸太小的标记，这样其父ViewGroup就可以通过该标记其给子View的尺寸太小了，然后可能分配更大一点的尺寸给子View。</p>
<p>getDefaultSize方法只是onMeasure方法中获取最终尺寸的默认实现，其返回的信息比resolveSizeAndState要少，那么什么时候才会调用resolveSizeAndState方法呢？ 主要有两种情况：</p>
<p>Android中的许多layout类都调用了resolveSizeAndState方法，比如LinearLayout在量算过程中会调用resolveSizeAndState方法而非getDefaultSize方法。<br>我们自己在实现自定义的View或ViewGroup时，我们可以重写onMeasure方法，并在该方法内调用resolveSizeAndState方法。<br>getMeasuredXXX系列方法</p>
<p>现在我们再回过头来看以下三组方法：</p>
<p>getMeasuredWidth和getMeasuredHeight方法<br>该组方法只返回量算结果中的的尺寸信息，去掉了高位字节的state信息，以getMeasuredWidth方法为例，其源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final int getMeasuredWidth() &#123;</span><br><span class="line">    //MEASURED_SIZE_MASK的值为0x00ffffff，用mMeasuredWidth与掩码MEASURED_SIZE_MASK进行按位与运算，</span><br><span class="line">    //可以将返回值中的高位字节的8个bit位全置为0，从而去掉了高位字节的state信息</span><br><span class="line">    return mMeasuredWidth &amp; MEASURED_SIZE_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MEASURED_SIZE_MASK的值为0x00ffffff，用mMeasuredWidth与掩码MEASURED_SIZE_MASK进行按位与运算，可以将返回值中的高位字节的8个bit位全置为0，从而去掉了高位字节的state信息</p>
<p>getMeasuredWidthAndState和getMeasuredHeightAndState方法<br>该组方法返回的量算结果中同时包含尺寸和state信息（如果state存在的话），以getMeasuredWidthAndState方法为例，其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final int getMeasuredWidthAndState() &#123;</span><br><span class="line">    //该方法直接返回成员变量mMeasuredWidth，因为mMeasuredWidth本身已经包含了尺寸以及可能的state信息</span><br><span class="line">    return mMeasuredWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法直接返回成员变量mMeasuredWidth，因为mMeasuredWidth本身已经包含了尺寸以及可能的state信息</p>
<p>getMeasuredState方法<br>该方法返回的Int值中同时包含宽度量算的state以及高度量算的state，不包含任何的尺寸信息，其源码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final int getMeasuredState() &#123;</span><br><span class="line">    //将宽度量算的state存储在Int值的第一个字节中，即高位首字节</span><br><span class="line">    //将高度量算的state存储在Int值的第三个字节中</span><br><span class="line">    return (mMeasuredWidth&amp;MEASURED_STATE_MASK)</span><br><span class="line">            | ((mMeasuredHeight&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT)</span><br><span class="line">                    &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们简单分析一下以上代码：</p>
<p>掩码MEASURED_STATE_MASK的值为常量0xff000000，其高位字节的8个bit位全为1，剩余低位字节的三个字节的24个bit位全为0</p>
<p>MEASURED_HEIGHT_STATE_SHIFT的值为常量16</p>
<p>当执行(mMeasuredWidth&amp;MEASURED_STATE_MASK)时，将mMeasuredWidth与MEASURED_STATE_MASK进行按位与操作，该表达式的值高位字节保留了量算后宽度的state，过滤掉了其低位三个字节所存储的宽度size</p>
<p>由于我们已经用高位首字节存储了量算后宽度的state，所以高度的state就不能存储在高位首字节了。Android打算把它存储在第三个字节中。(mMeasuredHeight&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT)表示将mMeasuredHeight向右移16位，这样高度的state字节就从原来的第一个字节右移动到了第三个字节，由于高度的state向右移动了，所以其对应的掩码也有相应移动。(MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT)表示state的掩码也从第一个字节右移16位到了第三个字节，即掩码从0xff000000变成了0x0000ff00。然后用右移后的state与右移后的掩码执行按位与操作，这样就在第三个字节保留了高度的state信息，并且过滤掉了第1、2、4字节中的信息，即将这三个字节中的24个bit位置为0。</p>
<p>最后，将我们得到的宽度的state与高度的state进行按位或操作，这样就将宽度和高度的state都保存在一个Int值中：第一个字节存储宽度的state，第三个字节存储高度的state。</p>
<p>##总结</p>
<p>至此，View中量算的关键类以及方法我们基本都涉及到了，我们发现View的measure方法还是比较聪明的，知道如何偷懒利用以前量算过的数据，如果情况有变，那么就调用onMeasure方法进行实际的量算工作，在onMeasure中，View要根据父ViewGroup给其传递进来的widthMeasureSpec和heightMeasureSpec，并结合View自身想要的尺寸，综合考虑，计算出最终的量算的宽度和高度，并存储到相应的成员变量中，这才标志着该View量算有效的完成了，如果没有将值存入到成员变量中，View会抛出异常。在该成员变量中有可能也存储了量算过程中的state信息。由于View的measure已经实现了很多逻辑判断，所以我们在自定义View或ViewGroup时，都不应该重写measure方法，而应该重写onMeasure方法，在其中实现我们自己的量算逻辑。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2016/12/11/Android中View的量算、布局以及绘图机制/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content>
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/11/Android中View的量算、布局以及绘图机制/" itemprop="url">
                  Android中View的量算、布局以及绘图机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-11T16:38:25+08:00">
                2016-12-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>为了研究Android中View的布局及绘图机制，我创建了一个非常简单的App，该App只有一个Activity，该Activity对应的layout如下所示：</p>
<pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;
android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;
android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;
android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; tools:context=&quot;.MainActivity&quot;&gt;

&lt;TextView android:text=&quot;@string/hello_world&quot; android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre><p>该布局文件很简单，RelativeLayout下面就一个TextView。</p>
<p>我们启动App后，通过Hierarchy Viewer查看App中的布局层级，如下所示：<br><img src="http://fastabler.online/images/20151016204222311.png" alt></p>
<p>从上图我们可以看出，App的根结点是PhoneWindow\$DecorView，此处的\$表示DecorView是PhoneWindow下面的内部类实例。PhoneWindow\$DecorView下面有三个child，分别是LinearLayout实例、View@49da043和View@44ff410。View@49da043表示的是navigationBarBackground，View@44ff410表示的是statusBarBackground。LinearLayout下面有两个child，分别是ViewStub实例和FrameLayout实例，其中ViewStub不需要绘制，所以我们在下面的讨论中可以直接对其忽略。FrameLayout下有一个child，RelativeLayout实例，该RelativeLayout实例对应的就是布局文件activity_main.xml中的RelativeLayout，RelativeLayout下有一个child，即TextView。</p>
<p>以上提到的控件都是View的实例，有的则是ViewGroup的实例，ViewGroup继承自View，PhoneWindow\$DecorView、RelativeLayout、FrameLayout、RelativeLayout都直接或间接继承自ViewGroup，只有ViewGroup实例才能有子节点。</p>
<p>当我们在onCreate()方法中调用setContentView(R.layout.activity_main)方法后，Android会从layout的树形结构中自上而下开始对所有的View进行量算、布局、绘图，具体来说经过以下过程：</p>
<p>Android自上而下对所有View进行量算，这样Android就知道了每个View想要的尺寸大小，即宽高信息</p>
<p>在完成了对所有View的量算工作后，Android会自上而下对所有View进行布局，Android就知道了每个View在其父控件中的位置，即View到其父控件四边的left、right、top、bottom</p>
<p>在完成了对所有View的布局工作后，Android会自上而下对所有View进行绘图，这样Android就将所有的View渲染到屏幕上了</p>
<p>以下是涉及到的相关类的源码： </p>
<p><a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/view/View.java" target="_blank" rel="noopener">View源码</a></p>
<p><a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/view/ViewGroup.java" target="_blank" rel="noopener">ViewGroup源码</a></p>
<p><a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/view/ViewRootImpl.java" target="_blank" rel="noopener">ViewRootImpl源码</a></p>
<p><a href="https://github.com/android/platform_frameworks_base/blob/d59921149bb5948ffbcb9a9e832e9ac1538e05a0/core/java/com/android/internal/policy/PhoneWindow.java" target="_blank" rel="noopener">PhoneWindow\$DecorView源码</a></p>
<p><a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/widget/LinearLayout.java" target="_blank" rel="noopener">LinearLayout源码</a></p>
<p><a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/widget/FrameLayout.java" target="_blank" rel="noopener">FrameLayout源码</a></p>
<p><a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/widget/RelativeLayout.java" target="_blank" rel="noopener">RelativeLayout源码</a></p>
<p><a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/widget/TextView.java" target="_blank" rel="noopener">TextView源码</a></p>
<h2 id="量算"><a href="#量算" class="headerlink" title="量算"></a>量算</h2><h3 id="关于Measure："><a href="#关于Measure：" class="headerlink" title="关于Measure："></a>关于Measure：</h3><p>View用measure()方法进行量算，量算的目的是View让其父节点知道它想要多大的尺寸，所以说量算是后面对View进行布局以及绘图的基础。</p>
<p>View的measure()方法中会执行onMeasure()方法，View类本身的onMeasure()方法不是空方法，其将量算完的结果保存到View中。View的子类不应该重写measure()方法，如果需要的话应该重写onMeasure()方法，ViewGroup的子类都应该重写onMeasure()方法，比如PhoneWindow\$DecorView、RelativeLayout、FrameLayout、RelativeLayout都重写了onMeasure()方法，这些类都在onMeasure()方法中遍历child，并调用child的measure()方法，对child进行量算，纵向递归进行，从而实现自上而下对View树进行量算，直至完成对叶子节点View的量算。</p>
<p>量算的起点是ViewRootImpl类，ViewRootImpl是根View，即View树上面的根结点，严格来说ViewRootImpl不属于View，其实现了ViewParent接口， 其下才是PhoneWindow\$DecorView。</p>
<p>Android在对View树进行自上而下的量算时，采用的是深度优先算法，而非广度优先算法，即遍历到某个View时，Android会首先沿着该View一直纵向遍历并量算到处于叶子节点的View，只有对该View及其所有子孙View（如果存在子孙View的话）完成量算后，才会量算该View的兄弟节点View。</p>
<p>以下是Android对所有View自上而下量算的调用过程：</p>
<p><img src="http://fastabler.online/images/20151017110657231.png" alt></p>
<p>由上我们可以看出，首先ViewRootImpl执行了doTraversal()和performTraversals() 方法，然后执行ViewRootImpl的performMeasure()方法，该方法是Android对所有View进行量算的起点。在该方法中会从ViewRootImpl开始自上而上对View树进行遍历，首先ViewRootImpl对PhoneWindow\$DecorView进行量算，在执行到PhoneWindow\$DecorView的onMeasure()方法时，其遍历所有的child，对依次它们进行量算，首先对调用LinearLayout的measure()方法，对第一个子节点LinearLayout进行量算。</p>
<p>LinearLayout在measure()方法中会调用onMeasure()方法，在该方法中LinearLayout调用了measureVertical()方法，该方法会遍历其child并对其进行量算，由于其子节点ViewStub不用于渲染，所以此处不对其量算，对其忽略，对另一个child FrameLayout进行量算，调用FrameLayout的measure()方法。</p>
<p>FrameLayout在执行measure()方法时会执行onMeasure()方法，在该方法中会遍历所有的child，并对它们进行量算。其下只有一个child，即RelativeLayout，调用RelativeLayout的measure()方法，对其进行量算。</p>
<p>RelativeLayout在measure()方法中会执行onMeasure()方法，在该方法中会遍历所有的child，并对它们进行量算。其下只有一个child，即TextView，调用TextView的measure()方法对其进行量算，在其中会执行onMeasure()方法。</p>
<p>以上完成了对View树中LinearLayout及其所有子算View的量算工作，之后会对PhoneWindow\$DecorView中的另外两个View进行量算，这也体现了Android采用深度优先算法对View树进行遍历量算的过程。View@49da0d3和View@44ff410会依次执行measure()方法和onMeasure()方法。</p>
<p>这样整个View树自上而下的量算过程就结束了，经过量算Android知道了各个View想要渲染的尺寸大小，即宽度和高度信息。</p>
<p>关于量算中measure()和onMeasure()方法的一些细节可参见博文<a href="http://blog.csdn.net/iispring/article/details/49403315" target="_blank" rel="noopener">《源码解析Android中View的measure量算过程》</a>。</p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="关于Layout："><a href="#关于Layout：" class="headerlink" title="关于Layout："></a>关于Layout：</h3><p>布局的前提是已经对View进行了量算，View通过调用layout()方法进行布局，布局的目的是让Android知道View在其父控件中的位置，即距父控件四边的距离left、right、top、bottom。布局是绘图的基础，只有完成了布局，才能对View进行绘图。</p>
<p>View的layout()方法中会执行onLayout()方法，View类本身的onLayout()是空方法。View的子类不应该重写layout()方法，如果需要的话应该重写其onLayout()方法，ViewGroup的子类都应该重写onLayout()方法，比如PhoneWindow\$DecorView、RelativeLayout、FrameLayout、RelativeLayout都重写了onLayout()方法，这些类都在onLayout()方法中遍历child，并调用child的layout()方法，对child进行布局，纵向递归进行，从而实现自上而下对View树进行布局，直至完成对叶子节点View的布局。</p>
<p>布局的起点也是ViewRootImpl类，ViewRootImpl是根View，即View树上面的根结点，严格来说ViewRootImpl不属于View，其实现了ViewParent接口， 其下才是PhoneWindow\$DecorView。</p>
<p>Android在对View树进行自上而下的布局时，采用的是深度优先算法，而非广度优先算法，即遍历到某个View时，Android会首先沿着该View一直纵向遍历并布局到处于叶子节点的View，只有对该View及其所有子孙View（如果存在子孙View的话）完成布局后，才会布局该View的兄弟节点View。</p>
<p>Android中的布局过程与之前上面提到的量算过程很类似，以下是Android对所有View自上而下布局的调用过程：</p>
<p><img src="http://fastabler.online/images/20151017124528354.png" alt></p>
<p>由上我们可以看出，首先ViewRootImpl执行了doTraversal()和performTraversals() 方法，然后执行ViewRootImpl的performLayout()方法，该方法是Android对所有View进行布局的起点。在该方法中会从ViewRootImpl开始自上而下对View树进行遍历，首先ViewRootImpl执行PhoneWindow\$DecorView的layout()方法，对其进行布局。</p>
<p>PhoneWindow\$DecorView在其layout()方法中会执行onLayout()方法，PhoneWindow\$DecorView会在onLayout()方法中遍历其所有的child，并依次调用child的layout()方法，实现对child的布局。首先调用其第一个child LinearLayout的layout()方法。</p>
<p>LinearLayout在layout()方法中会执行onLayout()方法，在该方法中会调用layoutVertical()方法，该方法会遍历其所有的child并依次调用child的layout()方法进行布局。由于其子节点ViewStub不用于渲染，所以此处不对其进行布局，对其忽略，对另一个child FrameLayout进行布局，调用FrameLayout的layout()方法。</p>
<p>FrameLayout在layout()方法中会执行onLayout()方法，在该方法中会调用layoutChildren()方法，该方法会遍历其所有的child并依次调用child的layout()方法进行布局。其下只有一个child，即RelativeLayout，执行RelativeLayout的layout()方法，对其进行布局。</p>
<p>RelativeLayout在layout()方法中会执行onLayout()方法，在该方法中会遍历所有的child并依次调用child的layout()方法进行布局。其下只有一个child，即TextView，调用TextView的layout()方法对其进行布局，在其中会执行onLayout()方法。</p>
<p>以上完成了对View树中LinearLayout及其所有子孙View的布局工作，之后会对PhoneWindow\$DecorView中的另外两个View进行布局，这也体现了Android采用深度优先算法对View树进行遍历布局的过程。View@49da043和View@44ff410会依次执行layout()方法和onLayout()方法。</p>
<p>这样整个View树自上而下的布局过程就结束了，经过布局Android知道了各个View在其父控件中的位置。</p>
<p>关于布局layout的细节可参见博文<a href="http://blog.csdn.net/iispring/article/details/50366021" target="_blank" rel="noopener">《源码解析Android中View的layout布局过程》</a>。</p>
<h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><h3 id="关于Draw："><a href="#关于Draw：" class="headerlink" title="关于Draw："></a>关于Draw：</h3><p>绘图的前提是已经对View进行了量算和布局，View通过调用draw()方法进行绘图，绘图的目的就是让View在UI界面上呈现出来。</p>
<p>View的draw()方法中会依次onDraw()和dispatchDraw()方法，View类本身的onDraw()和dispatchDraw()方法都是空方法。View的子类不应该重写draw()方法，如果需要的话应该按具体情况选择重写onDraw()方法或dispatchDraw()方法，具体来说：</p>
<p>当我们需要自定义一个View（而非ViewGroup）时，我们需要重写View的onDraw()方法以实现对自定义View的绘制，即onDraw()用于绘制View自身UI。<br>Android中的ViewGroup类重写了View中的dispatchDraw()方法，ViewGroup.dispatchDraw()方法会遍历其所有的child，并依次调用child的draw()方法，即dispatchDraw()用于绘制ViewGroup的所有子孙View的UI，这是与onDraw()不同的。由于ViewGroup已经具体实现了dispatchDraw()方法，所以大部分情况下ViewGroup的子类无需再对其进行重写，例如PhoneWindow\$DecorView、RelativeLayout、FrameLayout、RelativeLayout都没有重写dispatchDraw()方法。只有在极少数情况下，为了实现某些特殊需求，我们才有可能重写ViewGroup的dispatchDraw()方法，但是即便重写该方法我们也应该在我们的实现中调用super.dispatchDraw()方法以便实现对子孙View进行绘制。<br>绘图的起点也是ViewRootImpl类，ViewRootImpl是根View，即View树上面的根结点，严格来说ViewRootImpl不属于View，其实现了ViewParent接口， 其下才是PhoneWindow\$DecorView。</p>
<p>Android在对View树进行自上而下的绘图时，采用的也是深度优先算法，而非广度优先算法，即遍历到某个View时，Android会首先沿着该View一直纵向遍历并绘图到处于叶子节点的View，只有对该View及其所有子孙View（如果存在子孙View的话）完成绘图后，才会渲染该View的兄弟节点View。</p>
<p>Android中的绘图过程与之前上面提到的量算、布局过程类似，以下是Android对所有View进行自上而下绘图的调用过程：</p>
<p><img src="http://fastabler.online/images/20151017134329148.png" alt></p>
<p>由上我们可以看出，首先ViewRootImpl执行了doTraversal()和performTraversals() 方法，然后执行ViewRootImpl的performDraw()方法，该方法是Android对所有View进行绘图的起点。在该方法中会从ViewRootImpl开始自上而下对View树进行遍历，首先ViewRootImpl执行PhoneWindow\$DecorView的draw()方法，对其绘图。</p>
<p>PhoneWindow\$DecorView在其draw()方法中会依次执行onDraw()方法和dispatchDraw()方法，在dispatchDraw()方法中会遍历所有的child，调用child的draw()方法，对child进行绘图。首先调用其第一个child LinearLayout的draw()方法。</p>
<p>LinearLayout在darw()方法中也会依次执行onDraw()方法和dispatchDraw()方法，在dispatchDraw()方法中会遍历所有的child，调用child的draw()方法，对child进行绘图。由于其子节点ViewStub不用于渲染，所以此处不对其进行绘图，对其忽略，对另一个child FrameLayout进行绘图，调用FrameLayout的draw()方法。</p>
<p>FrameLayout在draw()方法中也会依次执行onDraw()方法和dispatchDraw()方法，在dispatchDraw()方法中会遍历所有的child，调用child的draw()方法，对child进行绘图。其下只有一个child，即RelativeLayout，执行RelativeLayout的draw()方法，对其进行绘图。</p>
<p>RelativeLayout在draw()方法中也会依次执行onDraw()方法和dispatchDraw()方法，在dispatchDraw()方法中会遍历所有的child，调用child的draw()方法，对child进行绘图。其下只有一个child，即TextView，执行TextView的draw()方法，对其进行绘图，并在其中执行TextView的onDraw()方法，对TextView进行实际的渲染。</p>
<p>以上完成了对View树中LinearLayout及其所有子孙View的绘图工作，之后会对PhoneWindow\$DecorView中的另外两个View进行绘图，这也体现了Android采用深度优先算法对View树进行遍历绘图的过程。View@49da043和View@44ff410会依次执行draw()方法和onDraw()方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当我们在onCreate()方法中调用setContentView(R.layout.activity_main)方法后，Android会从layout的树形结构中自上而下开始对所有的View进行量算、布局、绘图：</p>
<p>量算、布局、绘图的起点都是ViewRootImpl</p>
<p>通过调用ViewRootImpl的performMeasure() 方法，开始驱动Android自上而下对所有View进行量算，这样Android就知道了每个View想要的尺寸大小，即宽高信息</p>
<p>在完成了对所有View的量算工作后，通过调用ViewRootImpl的performLayout()方法，开始驱动Android会自上而下对所有View进行布局，Android就知道了每个View在其父控件中的位置，即View到其父控件四边的left、right、top、bottom</p>
<p>在完成了对所有View的布局工作后，通过调用ViewRootImpl的performDraw()方法，开始驱动Android会自上而下对所有View进行绘图，这样Android就将所有的View渲染到屏幕上了</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://hjlinfo.top/2016/12/07/Activity的生命周期和启动模式的总结/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="fastabler">
    <meta itemprop="description" content>
    <meta itemprop="image" content="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="黄金龙的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="黄金龙的博客" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/07/Activity的生命周期和启动模式的总结/" itemprop="url">
                  Activity的生命周期和启动模式的总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-07T13:16:20+08:00">
                2016-12-07
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Activity毫无疑问是Android中最重要的组件之一了，做好一个android程序，首先就得要hold住他的生命周期。</p>
<h2 id="Activity的生命周期的总结，以及注意的细节"><a href="#Activity的生命周期的总结，以及注意的细节" class="headerlink" title="Activity的生命周期的总结，以及注意的细节"></a>Activity的生命周期的总结，以及注意的细节</h2><p>先来个图</p>
<p><img src="http://fastabler.online/images/20151222103300622.png" alt="Activity生命周期图"></p>
<h3 id="典型情况下的生命周期的分析"><a href="#典型情况下的生命周期的分析" class="headerlink" title="典型情况下的生命周期的分析"></a>典型情况下的生命周期的分析</h3><p>Activity的常用生命周期我们不做讨论，一个Activity从创建到结束的基本回调为：onCreate-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onStop-&gt;onDestroy。<br>从整个生命周期来说，onCreate跟onDestroy是相对的，分别标识着Activity的创建和销毁。onStart跟onStop是相对的，分别标识着Activity是否完全可见。onResume跟onPause是相对的，分别标识着Activity是否在前台。</p>
<h4 id="生命周期细节分析"><a href="#生命周期细节分析" class="headerlink" title="生命周期细节分析"></a>生命周期细节分析</h4><ul>
<li><p>onStart跟onResume、onPause跟onStop从他们的描述上讲是差不多的，甚至在实际开发的过程中我们只保留其中的一对。onStart跟onStop是相对的，分别标识着Activity是否完全可见。onResume跟onPause是相对的，分别标识着Activity是否在前台。其他情况没有本质区别。</p>
</li>
<li><p>ActivityA中的onPause要比即将打开的ActivityB的onResume先执行，即前一个AcitivtyA要先执行完onPause之后后一个ActivityB就开始走自己的生命周期了，当ActivityB位于前台之后（即执行完onResume）ActivityA的onStop才执行，<strong>基于此我们可以知道必须在onPause处理耗时少的任务，要不然会影响下一个Activity的执行</strong></p>
</li>
</ul>
<h3 id="异常情况下的生命周期的分析"><a href="#异常情况下的生命周期的分析" class="headerlink" title="异常情况下的生命周期的分析"></a>异常情况下的生命周期的分析</h3><p>Activity除了受用户操作导致的正常生命周期方法的调度，还会存在一些异常的情况：比如当系统内存不足、资源相关的系统配置发生改变。</p>
<h4 id="当资源相关的系统配置发生改变导致Activity被杀死并重新创建"><a href="#当资源相关的系统配置发生改变导致Activity被杀死并重新创建" class="headerlink" title="当资源相关的系统配置发生改变导致Activity被杀死并重新创建"></a>当资源相关的系统配置发生改变导致Activity被杀死并重新创建</h4><p>典型的是当我们旋转手机的时候，由于横排导致需要重新加载各种横屏资源，所以会导致Activity的杀死重建，会依次执行onPause、onStop、onDestroy，同时由于Activity是在异常情况下终止的，所以系统会调用onSavaInstanceState来保存异常情况前的状态。onSavaInstanceState调用在onPause之后，跟onStope没有明确的次序关系，有可能在前也有可能在后。Activity重新加载会依次执行onCreate、onStart、onRestoreInstanceState来恢复状态。也可以直接在onCreate中判断bundle是否为空来恢复之前的状态。当Activity异常终止并重新创建时，系统会自动帮我们保存并恢复Activity的视图结构，以及数据，如文本框中用户输入的数据，ListView滑动的位置等。</p>
<h4 id="当内存不足导致的优先级低的Activity被杀死"><a href="#当内存不足导致的优先级低的Activity被杀死" class="headerlink" title="当内存不足导致的优先级低的Activity被杀死"></a>当内存不足导致的优先级低的Activity被杀死</h4><p>这种情况是比较常见的。在国内许多定制的系统中，为了保证手机的运行速度，会频繁的进行检查杀死优先级低的Activity，有时候即使内存足够也会面临被杀死的情况。Activity按照优先级从高到低分别为</p>
<ol>
<li>前台Activity，正在和用户交互的Activity，优先级最高</li>
<li>可见但非前台Activity，比如Activity弹出了一个对话框，此时的Activity是可见的，但是无法和用户交互，</li>
<li>后台Activity，已经被暂停的Activity，优先级最低，当内存不足时最容易被处理</li>
</ol>
<h2 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h2><h3 id="Activity的LaunchMode"><a href="#Activity的LaunchMode" class="headerlink" title="Activity的LaunchMode"></a>Activity的LaunchMode</h3><p>如果没有Activity的启动模式，我们在启动的时候只能为单一的跳转，非常不灵活。当我们多次启动同一个Activity，系统会创建多个Activity实例一一放在任务栈中，当我们单机back键后Activity会一一回退。任务栈是一种“后进先出”的栈结构。当栈中无任务Activity后系统会回收这个任务栈。4种启动模式介绍，</p>
<ol>
<li>standard：标准模式。这也是系统默认的模式，每次启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在，一个任务栈中可以有多个实例，一个实例也可以存在于多个栈中。启动的时候在哪一个栈中启动就会直接加到那个任务栈中。</li>
<li>singleTop：栈顶复用模式。在这种模式下，如果新的Activity处于栈顶，那么此Activity不会重新创建，同时他的onNewIntent方法会被调用，通过此方法我们可以得到当前请求的信息。而onCreate、onStart、onResume等方法没有被调用，因为他并没有发生改变。但是如果新的Activity不是处于栈顶，那么新的Activity会被重新创建并放入到栈顶。</li>
<li>singleTask：栈内复用模式。这是一种单实例模式，即当新的Activity存在于栈中，新的Activity会把其之上的Activity全部清除，让自己成为栈顶，并且栈中只会有一个相同的实例。</li>
<li>singleInstance：单实例模式。这其实是singleTask模式的加强版，即具有此模式的新的Activity会单独的位于一个任务栈中。</li>
</ol>
<p>上面介绍的几种启动模式，我们假设目前有两个任务栈，前台任务栈A、B，后台任务栈C、D。当我们从B启动D的时候，会拉起整个后台任务栈，即C、D，当点击back键会先返回到C，再点击返回到B。当从B启动C的时候，D不会跟着拉起来。用图解释可能会更加易懂：<br><img src="http://okzxn9yra.bkt.clouddn.com/taskstack1.png" alt="任务栈图"><br><img src="http://okzxn9yra.bkt.clouddn.com/taskstack2.png" alt="任务栈图"></p>
<h3 id="Activity的Flags"><a href="#Activity的Flags" class="headerlink" title="Activity的Flags"></a>Activity的Flags</h3><p>Activity的Flags有很多，这里主要介绍几个比较常见的标记位。标记位的作用很多，有的标记可以设置Activity的启动模式，有的标记位可以影响Activity的运行状态，还有的标记位可以设置视图的显示。大部分情况下我们不需要为Activity设置标记位。</p>
<ul>
<li>FLAG_ACTIVITY_NEW_TASK：这个标记为的作用是指定“singleTask”启动模式，其效果和在manifest设置效果相同</li>
<li>FLAG_ACTIVITY_SINGLE_TOP：这个标记位的作用是为Activity指定“singleTop”启动模式，其效果和在manifest设置效果相同。</li>
<li>FLAG_ACTIVITY_CLEAR_TOP：具有此标记位的Activity，当他启动时，在同一个任务栈中所有位于他顶部的Activity都要出栈，这个模式一般和FLAG_ACTIVITY_NEW_TASK配合使用。</li>
<li>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：具有此标记为都Activity不会出现在Activity历史列表中，等同于在minifest中设置属性android:excludeFromRecent=”true”.</li>
</ul>
<h3 id="IntentFilter的匹配规则"><a href="#IntentFilter的匹配规则" class="headerlink" title="IntentFilter的匹配规则"></a>IntentFilter的匹配规则</h3><p>启动Activity分为两种，显示调用和隐式调用。显示调用需要明确指明被调用对象的组件信息，包括包名和类名，而隐式调用则不需要明确指定组件信息，原则上一个Intent不能即为显式又为隐式，如果二者共存的话显示为主。隐式调用需要明确组件的IntentFilter，如果不匹配则无法启动目标Activity。IntentFilter的过滤信息为action、category、data。</p>
<ul>
<li>action的匹配规则要求action存在且必须和过滤规则中的其中一个action相同，只要有一个相同就可以，如果设置了多个action，只要有一个action匹配Intent就可以。</li>
<li>category的匹配规则要求如果Intent中存在category，那么所有的category必须和过滤规则中的其中一个category相同。换句话说，对于每一个category都必须必配已经定义了的。Intent中可以没有category，如果一旦有就必须完全匹配。</li>
<li>data的匹配规则跟action类似</li>
</ul>
<p>以上就是关于Activity的一些总结，其中的细节可以查看相关文档。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="http://fastabler.online/images/53e59d9a3ce6cf6e9c4f4a56f50553f8.jpeg" alt="fastabler">
          <p class="site-author-name" itemprop="name">fastabler</p>
          <p class="site-description motion-element" itemprop="description">Efforts can only pass,hard to be excellent.</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fastabler</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  




  
  

  

  

  

  


</body>
</html>
